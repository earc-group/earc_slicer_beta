.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Tessellation 3"
.TH Tessellation 3 "2016-10-05" "perl v5.28.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenGL::Tessellation \- discussion of tessellation in POGL
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    # somewhere in your drawing routine or drawlist compilation
\&
\&    my $tess = gluNewTess();
\&
\&    gluTessCallback($tess, GLU_TESS_BEGIN,     \*(AqDEFAULT\*(Aq);
\&    gluTessCallback($tess, GLU_TESS_END,       \*(AqDEFAULT\*(Aq);
\&    gluTessCallback($tess, GLU_TESS_VERTEX,    \*(AqDEFAULT\*(Aq);
\&    gluTessCallback($tess, GLU_TESS_COMBINE,   \*(AqDEFAULT\*(Aq);
\&    gluTessCallback($tess, GLU_TESS_ERROR,     \*(AqDEFAULT\*(Aq);
\&    gluTessCallback($tess, GLU_TESS_EDGE_FLAG, \*(AqDEFAULT\*(Aq);
\&
\&    gluTessBeginPolygon($tess);
\&    gluTessBeginContour($tess);
\&
\&    gluTessVertex_p($tess, 0,     200, 0);
\&    gluTessVertex_p($tess, 150,  \-200, 0);
\&    gluTessVertex_p($tess, 0,    \-100, 0);
\&    gluTessVertex_p($tess, \-150, \-200, 0);
\&
\&    gluTessEndContour($tess);
\&    gluTessEndPolygon($tess);
\&
\&    gluDeleteTess($tess);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
OpenGL rendering hardware typically does not have support for drawing
concave polygons or drawing polygons with windows.  OpenGL provides
glu extentions that allow for translating concave polygon vertices
into triangles that can be rendered quickly on \s-1GL\s0 hardware.  The
OpenGL red book chapter 11 has the full discussion of Tessellators and
the OpenGL functions (http://glprogramming.com/red/chapter11.html, or
use your favorite search engine and search for \*(L"opengl gluNewTess\*(R").
It is a good idea to read that chapter before reading the rest of this
document.
.PP
As much as possible, the \s-1POGL\s0 implementation of the tessellation
functions tries to remain faithful to the OpenGL specification.  Where
it doesn't match exactly, \s-1POGL\s0 follows the spirit of the specification,
but offloads what it can to c based implementations.
.PP
Tessellation functions are safe to call during drawlist creation.  It
is advisable to use drawlists, or to store the generated polygon data
into OpenGL::Array objects as these methods offer faster redraws.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP """gluNewTess""" 4
.el .IP "\f(CWgluNewTess\fR" 4
.IX Item "gluNewTess"
.Vb 1
\&    my $tess = gluNewTess();
.Ve
.Sp
Returns a reference that can be passed to the remaining tesselation
functions.
.Sp
Note: this isn't the c\-reference returned by the normal \fBgluNewTess()\fR c
function, it is a struct which contains that reference as well as
other members allowing callbacks to interface cleanly with the perl
code.  This means that if you have loaded other c\-libraries that use
standard opengl tessellation, you will not be able to use this perl
reference directly.
.Sp
The \s-1POGL\s0 implementation of \fBgluNewTess()\fR allows for two additional
parameters to be passed.  The first is a boolean value indicating that
default c callbacks and perl callbacks should be passed rgba color
data.  The second is a boolean value indicating that xyz normal data
should be passed.  Eventually one additional flag indicating that
texture data should be passed will be added as well.
.Sp
.Vb 3
\&    my $tess = gluNewTess();
\&    # gluTessVertex_p should be passed only x,y,z vertex data
\&    # as in gluTessVertex_p($tess, $x, $y, $z);
\&
\&    my $tess = gluNewTess(\*(Aqdo_colors\*(Aq);
\&    # gluTessVertex_p should be passed x,y,z AND r,g,b,a vertex data
\&    # as in gluTessVertex_p($tess, $x, $y, $z, $r, $g, $b, $a);
\&
\&    my $tess = gluNewTess(\*(Aqdo_colors\*(Aq, \*(Aqdo_normals\*(Aq);
\&    # gluTessVertex_p should be passed x,y,z AND r,g,b,a AND nx,ny,nz vertex data
\&    # as in gluTessVertex_p($tess, $x, $y, $z, $r, $g, $b, $a, $nx, $ny, $nz);
\&
\&    my $tess = gluNewTess(undef, \*(Aqdo_normals\*(Aq);
\&    # gluTessVertex_p should be passed x,y,z AND nx,ny,nz vertex data (no colors)
\&    # as in gluTessVertex_p($tess, $x, $y, $z, $nx, $ny, $nz);
.Ve
.Sp
Any true value can be passed in place of 'do_colors' and 'do_normals'
though using 'do_colors' and 'do_normals' acts as documentation.
.Sp
Behavior in these modes will be discussed further for functions to
which they apply.
.ie n .IP """gluDeleteTess""" 4
.el .IP "\f(CWgluDeleteTess\fR" 4
.IX Item "gluDeleteTess"
.Vb 1
\&    gluDeleteTess($tess);
.Ve
.Sp
This deletes the tessellation structure and frees up any remaining
associated memory.
.ie n .IP """gluTessCallback""" 4
.el .IP "\f(CWgluTessCallback\fR" 4
.IX Item "gluTessCallback"
.Vb 1
\&   gluTessCallback($tess, GLU_TESS_BEGIN, \*(AqDEFAULT\*(Aq);
\&
\&   gluTessCallback($tess, GLU_TESS_BEGIN, \e&glBegin);
\&
\&   gluTessCallback($tess, GLU_TESS_BEGIN, sub { my $enum = shift; glBegin($enum) });
\&
\&   gluTessCallback($tess, GLU_TESS_BEGIN);  # unsets current handler
.Ve
.Sp
Registers handlers for each of the tessellation callback types.  Takes
a tessellation reference generated by gluNewTess, a type, and a
coderef or the word '\s-1DEFAULT\s0'.  If the word '\s-1DEFAULT\s0' is passed, a
default c\-level callback will be installed (which will be discussed
for each callback).  If no 3rd argument is given, then any handler
currently set will be removed.  Valid callback types are
.Sp
.Vb 6
\&    GLU_TESS_BEGIN
\&    GLU_TESS_END
\&    GLU_TESS_VERTEX
\&    GLU_TESS_COMBINE
\&    GLU_TESS_ERROR
\&    GLU_TESS_EDGE_FLAG
\&
\&    GLU_TESS_BEGIN_DATA
\&    GLU_TESS_END_DATA
\&    GLU_TESS_VERTEX_DATA
\&    GLU_TESS_COMBINE_DATA
\&    GLU_TESS_ERROR_DATA
\&    GLU_TESS_EDGE_FLAG_DATA
.Ve
.Sp
These types and their passed parameters will be discussed in the
\&\s-1CALLBACKS\s0 section.
.Sp
The types ending with \*(L"_DATA\*(R" are similar to their non\-_DATA
counterpart, but when called are passed the option \f(CW$polygon_data\fR that
can be set during gluTessBeginPolygon.
.ie n .IP """gluTessBeginPolygon""" 4
.el .IP "\f(CWgluTessBeginPolygon\fR" 4
.IX Item "gluTessBeginPolygon"
.Vb 1
\&    gluTessBeginPolygon($tess);
\&
\&    gluTessBeginPolygon($tess, $polygon_data);
.Ve
.Sp
Begins the tessellation transaction.  It must eventually be
ended with a gluTessEndPolygon before the tessellator will normally
begin work.
.Sp
An optional second argument can be passed which can be any perl
scalar or reference.  If a callback is registered using a type ending
in _DATA, this perl scalar or reference will be passed as an additional
argument to that callback.
.Sp
.Vb 5
\&    gluTessCallback($tess, GLU_TESS_END_DATA, sub {
\&        my $polygon_data = shift;
\&        glEnd();
\&        print "glEnd: (".($polygon_data\->[2] eq 8 ? "YES" : "NO").")\en";
\&    });
\&
\&    gluTessBeginPoly($tess, [6,7,8]); # arrayref will be passed to _DATA callbacks
.Ve
.Sp
A sample Object Oriented tesselation sample listed at the end of this
document makes use of this \*(L"opaque\*(R" polygon data.
.ie n .IP """gluTessEndPolygon""" 4
.el .IP "\f(CWgluTessEndPolygon\fR" 4
.IX Item "gluTessEndPolygon"
.Vb 1
\&    gluTessEndPolygon($tess);
.Ve
.Sp
Finishes the tessellation transaction, which normally will immediately
fire the necessary callbacks generated by the tessellation process.
Once finished, it cleans up any accumulated temporary vertice data.
.ie n .IP """gluTessBeginContour""" 4
.el .IP "\f(CWgluTessBeginContour\fR" 4
.IX Item "gluTessBeginContour"
.Vb 1
\&    gluTessBeginContour($tess);
.Ve
.Sp
Starts a new contour of the tessellation of the current polygon.
Please read the OpenGL documentation, and red book chapter on
tessellation for more help on when to use different contours.  Should
eventually be followed by a gluTessEndContour call.
.Sp
(At a high level, tessellated polygons may have windows and multiple
separate portions.  Each inner and outer border of these portions
should be represented by a different contour.)
.ie n .IP """gluTessVertex_p""" 4
.el .IP "\f(CWgluTessVertex_p\fR" 4
.IX Item "gluTessVertex_p"
.Vb 1
\&    gluTessVertex_p($tess, $x, $y, $z);
\&
\&    gluTessVertex_p($tess, $x, $y, $z, $vertex_data);
.Ve
.Sp
Adds a vertex to the current contour of the current polygon being
tessellated.
.Sp
If the vertex callback type is set to \s-1GLU_TESS_VERTEX,\s0 the optional
\&\f(CW$vertex_data\fR argument will be passed to the vertex callback, and to
the combine callback (if \s-1GLU_TESS_VERTEX_DATA\s0 is used, then the
\&\f(CW$polygon_data\fR passed to gluTessBeginPolygon will be passed instead).
This optional opaque vertex data can be any perl scalar or reference
and can be used to pass useful information along during the
tessellation process.
.Sp
If the 'do_colors' or 'do_normals' parameters were passed to gluNewTess,
then those additional properties \s-1MUST\s0 be passed as additional arguments.
.Sp
.Vb 3
\&    # my $tess = gluNewTess(\*(Aqdo_colors\*(Aq);
\&    gluTessVertex_p($tess, $x, $y, $z, $r, $g, $b, $a);
\&    gluTessVertex_p($tess, $x, $y, $z, $r, $g, $b, $a, $vertex_data);
\&
\&    # my $tess = gluNewTess(\*(Aqdo_colors\*(Aq, \*(Aqdo_normals\*(Aq);
\&    gluTessVertex_p($tess, $x, $y, $z, $r, $g, $b, $a, $nx, $ny, $nz);
\&    gluTessVertex_p($tess, $x, $y, $z, $r, $g, $b, $a, $nx, $ny, $nz, $vertex_data);
\&
\&    # my $tess = gluNewTess(undef, \*(Aqdo_normals\*(Aq);
\&    gluTessVertex_p($tess, $x, $y, $z, $nx, $ny, $nz);
\&    gluTessVertex_p($tess, $x, $y, $z, $nx, $ny, $nz, $vertex_data);
.Ve
.SH "CALLBACKS"
.IX Header "CALLBACKS"
All of the callbacks support a '\s-1DEFAULT\s0' handler that can be installed
by passing the word '\s-1DEFAULT\s0' in place of the callback code reference.
The \s-1DEFAULT\s0 c implementations are there to avoid needing to round trip
out to perl.  The defaults employed are described for each of the
callback types.
.PP
With the exception of the \s-1COMBINE\s0 callback, return values from
callbacks are discarded.
.ie n .IP """GLU_TESS_BEGIN""" 4
.el .IP "\f(CWGLU_TESS_BEGIN\fR" 4
.IX Item "GLU_TESS_BEGIN"
.Vb 1
\&   gluTessCallback($tess, GLU_TESS_BEGIN, \*(AqDEFAULT\*(Aq);
\&
\&   gluTessCallback($tess, GLU_TESS_BEGIN, \e&glBegin);
\&
\&   gluTessCallback($tess, GLU_TESS_BEGIN, sub {
\&       my $enum = shift;
\&       glBegin($enum);
\&   });
.Ve
.Sp
The '\s-1DEFAULT\s0' option installs a c\-handler that calls the glBegin c
function directly without round-tripping out to perl.
.Sp
If \f(CW$polygon_data\fR was set during gluTessBeginPolygon, it is discarded.
.ie n .IP """GLU_TESS_BEGIN_DATA""" 4
.el .IP "\f(CWGLU_TESS_BEGIN_DATA\fR" 4
.IX Item "GLU_TESS_BEGIN_DATA"
Similar to \s-1GLU_TESS_BEGIN\s0 but will be passed optional \f(CW$polygon_data\fR
set in gluTessBeginPolygon if any.  The '\s-1DEFAULT\s0' handler will ignore
this data.
.Sp
.Vb 5
\&   gluTessCallback($tess, GLU_TESS_BEGIN_DATA, sub {
\&       my ($enum, $polygon_data) = @_;
\&       glBegin($enum);
\&       print "glBegin \- and I received polygon_data\en" if $polygon_data;
\&   });
.Ve
.ie n .IP """GLU_TESS_END""" 4
.el .IP "\f(CWGLU_TESS_END\fR" 4
.IX Item "GLU_TESS_END"
.Vb 1
\&   gluTessCallback($tess, GLU_TESS_END, \*(AqDEFAULT\*(Aq);
\&
\&   gluTessCallback($tess, GLU_TESS_END, \e&glEnd);
\&
\&   gluTessCallback($tess, GLU_TESS_END, sub { glEnd() });
.Ve
.Sp
The '\s-1DEFAULT\s0' option installs a c\-handler that calls the glEnd c
function directly without round-tripping out to perl.
.Sp
If \f(CW$polygon_data\fR was set during gluTessBeginPolygon, it is discarded.
.ie n .IP """GLU_TESS_END_DATA""" 4
.el .IP "\f(CWGLU_TESS_END_DATA\fR" 4
.IX Item "GLU_TESS_END_DATA"
Similar to \s-1GLU_TESS_END\s0 but will be passed optional \f(CW$polygon_data\fR set
in gluTessBeginPolygon if any.  The '\s-1DEFAULT\s0' handler will ignore this
data.
.Sp
.Vb 5
\&   gluTessCallback($tess, GLU_TESS_END_DATA, sub {
\&       my ($polygon_data) = @_;
\&       glEnd();
\&       print "glEnd \- and I received polygon_data\en" if $polygon_data;
\&   });
.Ve
.ie n .IP """GLU_TESS_VERTEX""" 4
.el .IP "\f(CWGLU_TESS_VERTEX\fR" 4
.IX Item "GLU_TESS_VERTEX"
The \s-1GLU_TESS_VERTEX\s0 callback handler has slightly different
behavior depending on how gluNewTess was called.  The optional behaviors
allow for sane default processing of colors and normals without needing
to roundtrip out to perl.
.Sp
.Vb 1
\&   my $tess = gluNewTess();
\&
\&   gluTessCallback($tess, GLU_TESS_VERTEX, \*(AqDEFAULT\*(Aq);
\&
\&   # the following will break if vertex_data is passed to gluTessVertex_p
\&   gluTessCallback($tess, GLU_TESS_VERTEX, \e&glVertex3f);
\&
\&   gluTessCallback($tess, GLU_TESS_VERTEX, sub {
\&       my ($x, $y, $z) = @_;
\&       glVertex3f($x, $y, $z);
\&   });
\&
\&   # you can also pass vertex_data to gluTessVertex_p
\&   gluTessCallback($tess, GLU_TESS_VERTEX, sub {
\&       my ($x, $y, $z, $vertex_data) = @_;
\&       glVertex3f($x, $y, $z);
\&       print "glVertex \- and I received vertex_data\en" if $vertex_data;
\&   });
.Ve
.Sp
The '\s-1DEFAULT\s0' option installs a c\-handler that calls the glVertex c
function directly without round-tripping out to perl.  The \s-1DEFAULT\s0
handler discards any polygon_data or vertex_data.
.Sp
\&\s-1IF\s0 \f(CW$vertex_data\fR was set during gluTessVertex_p it will be passed as the final
argument.
.Sp
If gluNewTess was passed 'do_colors' then the \s-1GLU_TESS_VERTEX\s0 callback
will also be passed the rgba information.  The '\s-1DEFAULT\s0' option
will pass the color information to glColor4f before calling glVertex3f.
.Sp
.Vb 1
\&   my $tess = gluNewTess(\*(Aqdo_colors\*(Aq);
\&
\&   gluTessCallback($tess, GLU_TESS_VERTEX, sub {
\&       my ($x, $y, $z, $r, $g, $b, $a, $vertex_data) = @_;
\&       glColor4f($r, $g, $b, $a);
\&       glVertex3f($x, $y, $z);
\&   });
.Ve
.Sp
If gluNewTess was passed 'do_normals' then the \s-1GLU_TESS_VERTEX\s0 callback
will also be passed the normal x,y,z information.  The '\s-1DEFAULT\s0' option
will pass the normal information to glNormal3f before calling glVertex3f.
.Sp
.Vb 1
\&   my $tess = gluNewTess(\*(Aqdo_colors\*(Aq, \*(Aqdo_normals\*(Aq);
\&
\&   gluTessCallback($tess, GLU_TESS_VERTEX, sub {
\&       my ($x, $y, $z, $r, $g, $b, $a, $nx, $ny, $nz, $vertex_data) = @_;
\&       glColor4f($r, $g, $b, $a);
\&       glNormalf($nx, $ny, $nz);
\&       glVertex3f($x, $y, $z);
\&   });
\&
\&   # OR
\&
\&   my $tess = gluNewTess(undef, \*(Aqdo_normals\*(Aq);
\&
\&   gluTessCallback($tess, GLU_TESS_VERTEX, sub {
\&       my ($x, $y, $z, $nx, $ny, $nz, $vertex_data) = @_;
\&       glNormalf($nx, $ny, $nz);
\&       glVertex3f($x, $y, $z);
\&   });
.Ve
.Sp
In all cases, any optional vertex_data will be passed as the final argument.
.ie n .IP """GLU_TESS_VERTEX_DATA""" 4
.el .IP "\f(CWGLU_TESS_VERTEX_DATA\fR" 4
.IX Item "GLU_TESS_VERTEX_DATA"
Similar to \s-1GLU_TESS_VERTEX\s0 but will be passed optional \f(CW$polygon_data\fR
set in gluTessBeginPolygon (if any) rather than the optional
\&\f(CW$vertex_data\fR passed to gluTessVertex_p.  The '\s-1DEFAULT\s0' handler will
ignore this data.
.Sp
.Vb 5
\&   gluTessCallback($tess, GLU_TESS_VERTEX_DATA, sub {
\&       my ($x, $y, $z, $vertex_data) = @_;
\&       glVertex3f($x, $y, $z);
\&       print "glVertex \- and I received vertex_data\en" if $vertex_data;
\&   });
.Ve
.ie n .IP """GLU_TESS_COMBINE""" 4
.el .IP "\f(CWGLU_TESS_COMBINE\fR" 4
.IX Item "GLU_TESS_COMBINE"
.Vb 2
\&   gluTessCallback($tess, GLU_TESS_COMBINE, \*(AqDEFAULT\*(Aq);
\&   # works with gluTessCallback($tess, GLU_TESS_VERTEX, \*(AqDEFAULT\*(Aq);
\&
\&
\&   # OR
\&
\&
\&   # the following callback is valid for gluNewTess() (no do_colors or do_normals)
\&   # using gluTessVertex_p($tess, $x, $y, $z);
\&   my $tess = gluNewTess();
\&   gluTessCallback($tess, GLU_TESS_COMBINE, sub {
\&       my ($x, $y, $z,           # new vertex location
\&           $v0, $v1, $v2, $v3,   # border vertex arrayrefs
\&           $w0, $w1, $w2, $w3,   # border vertex weights
\&           $polygon_data) = @_;  # optional data passed to gluTessBeginPolygon
\&       return ($x, $y, $z);
\&   });
\&   # works with gluTessCallback($tess, GLU_TESS_VERTEX, \*(AqDEFAULT\*(Aq);
\&
\&
\&   # OR
\&
\&
\&   # the following callback is valid for gluNewTess() when vertex data is passed
\&   # using gluTessVertex_p($tess, $x, $y, $z, [$r, $g, $b, $a]);
\&   # The DEFAULT callback cannot automatically proceess this type of data
\&   # but passing data to a custom handler this way could handle any arbitrary data passed to it
\&   my $tess = gluNewTess();
\&   use constant _r => 0;
\&   use constant _g => 1;
\&   use constant _b => 2;
\&   use constant _a => 3;
\&   gluTessCallback($tess, GLU_TESS_COMBINE, sub {
\&       my ($x, $y, $z,           # new vertex location
\&           $v0, $v1, $v2, $v3,   # border vertex arrayrefs
\&           $w0, $w1, $w2, $w3,   # border vertex weights
\&           $polygon_data) = @_;  # optional data passed to gluTessBeginPolygon
\&
\&       # $v0 will contain [$x, $y, $z, [$r, $g, $b, $a]]
\&       my @rgba = map {$_\->[3]} $v0, $v1, $v2, $v3;
\&
\&       # generate a point with color weighted from the surrounding vertices
\&       # then return that color information in the same way we received it (an rgba arrayref)
\&       return (
\&           $x, $y, $z,
\&           [$w0*$rgba[0]\->[_r] + $w1*$rgba[1]\->[_r] + $w2*$rgba[2]\->[_r] + $w3*$rgba[3]\->[_r],
\&            $w0*$rgba[0]\->[_g] + $w1*$rgba[1]\->[_g] + $w2*$rgba[2]\->[_g] + $w3*$rgba[3]\->[_g],
\&            $w0*$rgba[0]\->[_b] + $w1*$rgba[1]\->[_b] + $w2*$rgba[2]\->[_b] + $w3*$rgba[3]\->[_b],
\&            $w0*$rgba[0]\->[_a] + $w1*$rgba[1]\->[_a] + $w2*$rgba[2]\->[_a] + $w3*$rgba[3]\->[_a]],
\&           );
\&   });
\&   # works with gluTessCallback($tess, GLU_TESS_VERTEX, sub {
\&   #    my ($x, $y, $z, $rgba) = @_;
\&   #    glColor4f(@$rgba);
\&   #    glVertex3f($x, $y, $z);
\&   # });
\&
\&
\&   # OR
\&
\&
\&   # the following callback is valid for gluNewTess(\*(Aqdo_colors\*(Aq)
\&   # using gluTessVertex_p($tess, $x, $y, $z, $r, $g, $b, $a);
\&   # the DEFAULT callback COULD automatically proceess this type of data as well if additional vertex data is not passed
\&   my $tess = gluNewTess(\*(Aqdo_colors\*(Aq);
\&   use constant _r => 3;
\&   use constant _g => 4;
\&   use constant _b => 5;
\&   use constant _a => 6;
\&   gluTessCallback($tess, GLU_TESS_COMBINE, sub {
\&       my ($x, $y, $z,           # new vertex location
\&           $v0, $v1, $v2, $v3,   # border vertex arrayrefs
\&           $w0, $w1, $w2, $w3,   # border vertex weights
\&           $polygon_data) = @_;  # optional data passed to gluTessBeginPolygon
\&
\&       # $v0 will contain [$x, $y, $z, $r, $g, $b, $a]
\&
\&       return ( # generate a point with color weighted from the surrounding vertices
\&           $x, $y, $z,
\&           $w0*$v0\->[_r] + $w1*$v1\->[_r] + $w2*$v2\->[_r] + $w3*$v3\->[_r],
\&           $w0*$v0\->[_g] + $w1*$v1\->[_g] + $w2*$v2\->[_g] + $w3*$v3\->[_g],
\&           $w0*$v0\->[_b] + $w1*$v1\->[_b] + $w2*$v2\->[_b] + $w3*$v3\->[_b],
\&           $w0*$v0\->[_a] + $w1*$v1\->[_a] + $w2*$v2\->[_a] + $w3*$v3\->[_a],
\&           ($v0\->[7] || $v1\->[7] || $v2\->[7] || $v3\->[7]), # if we received vertex data \- return some for the new vertex
\&           );
\&   });
\&   # works with gluTessCallback($tess, GLU_TESS_VERTEX, \*(AqDEFAULT\*(Aq);
\&   # OR
\&   # works with gluTessCallback($tess, GLU_TESS_VERTEX, sub {
\&   #    my ($x, $y, $z, $r, $g, $b, $a, $vertex_data) = @_;
\&   #    glColor4f($r, $g, $b, $a);
\&   #    glVertex3f($x, $y, $z);
\&   # });
.Ve
.Sp
The combine callback is called if the tessellator decides a new vertex
is needed.  This will happen with self intersecting polygons.  In this
case, the \s-1COMBINE\s0 callback can be used to interpolate appropriate
values for normals, and colors, or for any desired information.
.Sp
The combine callback will be passed the following:
.RS 4
.ie n .IP """$x, $y, $z""" 4
.el .IP "\f(CW$x, $y, $z\fR" 4
.IX Item "$x, $y, $z"
The x y and z coordinates of the new vertex being created.
.ie n .IP """$v0, $v1, $v2, $v3""" 4
.el .IP "\f(CW$v0, $v1, $v2, $v3\fR" 4
.IX Item "$v0, $v1, $v2, $v3"
Arrayrefs of vertex information for the vertices bordering this
new vertex (the ones that caused the new vertex to be created).
.Sp
By default if \fBgluNewTess()\fR is called, these arrayrefs will be passed:
.Sp
.Vb 2
\&     my ($x, $y, $z, $vertex_data) = @$v0;
\&     # received from gluTessVertex_p($tess, $x, $y, $z, $vertex_data);
.Ve
.Sp
If gluNewTess('do_colors') is called, the following will be passed:
.Sp
.Vb 2
\&     my ($x, $y, $z, $r, $g, $b, $a, $vertex_data) = @$v0;
\&     # received from gluTessVertex_p($tess, $x, $y, $z, $r, $g, $b, $a, $vertex_data);
.Ve
.Sp
If gluNewTess('do_colors', 'do_normals') is called, the following will be passed:
.Sp
.Vb 2
\&     my ($x, $y, $z, $r, $g, $b, $a, $nx, $ny, $nz, $vertex_data) = @$v0;
\&     # received from gluTessVertex_p($tess, $x, $y, $z, $r, $g, $b, $a, $nx, $ny, $nz, $vertex_data);
.Ve
.Sp
If gluNewTess(undef, 'do_normals') is called, the following will be passed:
.Sp
.Vb 2
\&     my ($x, $y, $z, $nx, $ny, $nz, $vertex_data) = @$v0;
\&     # received from gluTessVertex_p($tess, $x, $y, $z, $nx, $ny, $nz, $vertex_data);
.Ve
.Sp
In all cases, the data returned by the \s-1COMBINE\s0 callback should be in the same
format that each of the vertices are in when passed into the \s-1COMBINE\s0 callback.
.ie n .IP """$w0, $w1, $w2, $w3""" 4
.el .IP "\f(CW$w0, $w1, $w2, $w3\fR" 4
.IX Item "$w0, $w1, $w2, $w3"
Weights of the participating vertices (weight \f(CW$w0\fR corresponds to vertex \f(CW$v0\fR).
.ie n .IP """optional $polygon_data""" 4
.el .IP "\f(CWoptional $polygon_data\fR" 4
.IX Item "optional $polygon_data"
Any optional data passed to gluTessBeginPolygon.  Normally this would
only be passed to \s-1GLU_TESS_COMBINE_DATA,\s0 but \s-1GLU_TESS_COMBINE_DATA\s0
and \s-1GLU_TESS_COMBINE\s0 share the same code implementation.
.RE
.RS 4
.RE
.ie n .IP """GLU_TESS_COMBINE_DATA""" 4
.el .IP "\f(CWGLU_TESS_COMBINE_DATA\fR" 4
.IX Item "GLU_TESS_COMBINE_DATA"
Identical in function to the \s-1GLU_TESS_COMBINE\s0 handler.  They
use the same callback implementation.
.ie n .IP """GLU_TESS_ERROR""" 4
.el .IP "\f(CWGLU_TESS_ERROR\fR" 4
.IX Item "GLU_TESS_ERROR"
.Vb 1
\&   gluTessCallback($tess, GLU_TESS_ERROR, \*(AqDEFAULT\*(Aq);
\&
\&   gluTessCallback($tess, GLU_TESS_ERROR, \e&glEdgeFlag);
\&
\&   gluTessCallback($tess, GLU_TESS_ERROR, sub {
\&       my $errno = shift;
\&       my $err = gluErrorString($errno);
\&       warn "Received a glu tess error ($errno \- $err)\en";
\&    });
.Ve
.Sp
The '\s-1DEFAULT\s0' option installs a c\-handler that warns with the
appropriate gluErrorString.
.Sp
If \f(CW$polygon_data\fR was set during gluTessBeginPolygon, it is discarded.
.ie n .IP """GLU_TESS_ERROR_DATA""" 4
.el .IP "\f(CWGLU_TESS_ERROR_DATA\fR" 4
.IX Item "GLU_TESS_ERROR_DATA"
Similar to \s-1GLU_TESS_ERROR\s0 but will be passed optional \f(CW$polygon_data\fR
set in gluTessBeginPolygon if any.  The '\s-1DEFAULT\s0' handler will ignore
this data.
.Sp
.Vb 6
\&   gluTessCallback($tess, GLU_TESS_ERROR_DATA, sub {
\&       my ($errno, $polygon_data) = @_;
\&       my $err = gluErrorString($errno);
\&       warn "Received a glu tess error ($errno \- $err)\en";
\&       warn "And I received polygon_data\en" if $polygon_data;
\&   });
.Ve
.ie n .IP """GLU_TESS_EDGE_FLAG""" 4
.el .IP "\f(CWGLU_TESS_EDGE_FLAG\fR" 4
.IX Item "GLU_TESS_EDGE_FLAG"
.Vb 1
\&   gluTessCallback($tess, GLU_TESS_EDGE_FLAG, \*(AqDEFAULT\*(Aq);
\&
\&   gluTessCallback($tess, GLU_TESS_EDGE_FLAG, \e&glEdgeFlag);
\&
\&   gluTessCallback($tess, GLU_TESS_EDGE_FLAG, sub {
\&       my ($flag) = @_;
\&       glEdgeFlag($flag);
\&    });
.Ve
.Sp
The '\s-1DEFAULT\s0' option installs a c\-handler that calls the glEdgeFlag c
function directly without round-tripping out to perl.
.Sp
If \f(CW$polygon_data\fR was set during gluTessBeginPolygon, it is discarded.
.ie n .IP """GLU_TESS_EDGE_FLAG_DATA""" 4
.el .IP "\f(CWGLU_TESS_EDGE_FLAG_DATA\fR" 4
.IX Item "GLU_TESS_EDGE_FLAG_DATA"
Similar to \s-1GLU_TESS_EDGE_FLAG\s0 but will be passed \f(CW$polygon_data\fR set in
gluTessBeginPolygon if any.  The '\s-1DEFAULT\s0' handler will ignore this
data.
.Sp
.Vb 5
\&   gluTessCallback($tess, GLU_TESS_EDGE_FLAG_DATA, sub {
\&       my ($flag, $polygon_data) = @_;
\&       glEdgeFlag($flag);
\&       print "glEdgeFlag \- and I received polygon_data\en" if $polygon_data;
\&   });
.Ve
.SH "Example: Basic Arrowhead"
.IX Header "Example: Basic Arrowhead"
.Vb 1
\&    use OpenGL qw(:all);
\&
\&    glutInit();
\&    glutInitWindowSize(501, 501);
\&    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE);
\&    glutCreateWindow("Tessellation");
\&    glMatrixMode(GL_PROJECTION());
\&    glLoadIdentity();
\&    glOrtho(\-250,250,\-250,250,\-1.0,1.0);
\&    glMatrixMode(GL_MODELVIEW);
\&
\&    my $view_triangles = 1; # set to zero to show polygon
\&    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE) if $view_triangles;
\&
\&    glutDisplayFunc(sub {
\&        glColor3f(1,1,1);
\&
\&        my $tess = gluNewTess();
\&        gluTessCallback($tess, GLU_TESS_BEGIN,     \*(AqDEFAULT\*(Aq);
\&        gluTessCallback($tess, GLU_TESS_END,       \*(AqDEFAULT\*(Aq);
\&        gluTessCallback($tess, GLU_TESS_VERTEX,    \*(AqDEFAULT\*(Aq);
\&        gluTessCallback($tess, GLU_TESS_COMBINE,   \*(AqDEFAULT\*(Aq);
\&        gluTessCallback($tess, GLU_TESS_ERROR,     \*(AqDEFAULT\*(Aq);
\&        gluTessCallback($tess, GLU_TESS_EDGE_FLAG, \*(AqDEFAULT\*(Aq) if ! $view_triangles;
\&        gluTessBeginPolygon($tess);
\&        gluTessBeginContour($tess);
\&
\&        gluTessVertex_p($tess, 0,    200,  0);
\&        gluTessVertex_p($tess, 150,  \-200, 0);
\&        gluTessVertex_p($tess, 0,    \-100, 0);
\&        gluTessVertex_p($tess, \-150, \-200, 0);
\&
\&        gluTessEndContour($tess);
\&        gluTessEndPolygon($tess);
\&        gluDeleteTess($tess);
\&
\&        glutSwapBuffers();
\&    });
\&
\&    glutMainLoop();
.Ve
.SH "Example: Multiple contours"
.IX Header "Example: Multiple contours"
.Vb 1
\&    use OpenGL qw(:all);
\&
\&    glutInit();
\&    glutInitWindowSize(501, 501);
\&    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE);
\&    glutCreateWindow("Tessellation");
\&    glMatrixMode(GL_PROJECTION());
\&    glLoadIdentity();
\&    glOrtho(\-250,250,\-250,250,\-1.0,1.0);
\&    glMatrixMode(GL_MODELVIEW);
\&
\&    my $view_triangles = 1; # set to zero to show polygon
\&    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE) if $view_triangles;
\&
\&    glutDisplayFunc(sub {
\&        glColor3f(1,1,1);
\&        my $v = [[[125,0,0], [150,150,0], [0,125,0], [\-150,150,0],
\&                  [\-125,0,0], [\-150,\-150,0], [0,\-125,0], [150,\-150,0], [125,0,0]],
\&                 [[75,0,0], [100,100,0], [0,75,0], [\-100,100,0],
\&                  [\-75,0,0], [\-100,\-100,0], [0,\-75,0], [100,\-100,0], [75,0,0]]
\&                ];
\&
\&        my $tess = gluNewTess();
\&        gluTessCallback($tess, GLU_TESS_BEGIN,     \*(AqDEFAULT\*(Aq);
\&        gluTessCallback($tess, GLU_TESS_END,       \*(AqDEFAULT\*(Aq);
\&        gluTessCallback($tess, GLU_TESS_VERTEX,    \*(AqDEFAULT\*(Aq);
\&        gluTessCallback($tess, GLU_TESS_COMBINE,   \*(AqDEFAULT\*(Aq);
\&        gluTessCallback($tess, GLU_TESS_ERROR,     \*(AqDEFAULT\*(Aq);
\&        gluTessCallback($tess, GLU_TESS_EDGE_FLAG, \*(AqDEFAULT\*(Aq) if ! $view_triangles;
\&        gluTessBeginPolygon($tess);
\&        foreach (@$v) {
\&            gluTessBeginContour($tess);
\&            foreach (@$_) {
\&                gluTessVertex_p($tess, @$_);
\&            }
\&            gluTessEndContour($tess);
\&        }
\&        gluTessEndPolygon($tess);
\&        gluDeleteTess($tess);
\&
\&        glutSwapBuffers();
\&    });
\&
\&    glutMainLoop();
.Ve
.SH "Example: Sample OO Tessellation interface using polygon_data"
.IX Header "Example: Sample OO Tessellation interface using polygon_data"
.Vb 1
\&    use OpenGL qw(:all);
\&
\&    glutInit();
\&    glutInitWindowSize(501, 501);
\&    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE);
\&    glutCreateWindow("Tessellation");
\&    glMatrixMode(GL_PROJECTION());
\&    glLoadIdentity();
\&    glOrtho(\-250,250,\-250,250,\-1.0,1.0);
\&    glMatrixMode(GL_MODELVIEW);
\&
\&    my $view_triangles = 0;
\&    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE) if $view_triangles;
\&
\&    glutDisplayFunc(sub {
\&        glColor3f(1,1,1);
\&        my $v = [[[125,0,0], [150,150,0, 0,1,0], [0,125,0], [\-150,150,0, 1,0,0],
\&                  [\-125,0,0], [\-150,\-150,0, 0,0,1], [0,\-125,0], [150,\-150,0, 1,1,0], [125,0,0]],
\&                 [[75,0,0], [100,100,0], [0,75,0], [\-100,100,0],
\&                  [\-75,0,0], [\-100,\-100,0], [0,\-75,0], [100,\-100,0], [75,0,0]]
\&                ];
\&
\&        OpenGL::Tess\->new(do_colors => 1, no_edge_flag => $view_triangles)\->draw_contours(@$v);
\&
\&        glutSwapBuffers();
\&    });
\&
\&    glutMainLoop();
\&
\&    ###\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-###
\&
\&
\&    package OpenGL::Tess;
\&
\&    # Sample object oriented Tessellator
\&    # OpenGL::Tess\->new(do_colors => 1, no_edge_flag => $view_triangles)\->draw_contours(@$v);
\&
\&    use strict;
\&
\&    sub new {
\&        my $class = shift;
\&        my $self  = bless {@_}, $class;
\&        my $tess = $self\->{\*(Aq_tess\*(Aq} = OpenGL::gluNewTess($self\->do_colors);
\&        for my $cb (qw(begin end vertex combine error edge_flag)) {
\&            my $enum = OpenGL\->can("GLU_TESS_\eU${cb}_DATA") || die "Couldn\*(Aqt find callback for $cb";
\&            my $name = "_$cb";
\&            OpenGL::gluTessCallback($tess, $enum\->(), sub { $_[\-1]\->$name(@_) });
\&        }
\&        return $self;
\&    }
\&
\&    sub DESTROY {
\&        my $tess = shift\->{\*(Aq_tess\*(Aq};
\&        OpenGL::gluDeleteTess($tess) if $tess;
\&    }
\&
\&    sub tess {
\&        my $self = shift;
\&        return $self\->{\*(Aq_tess\*(Aq} || die "Missing tess";
\&    }
\&
\&    sub do_colors { shift\->{\*(Aqdo_colors\*(Aq} }
\&
\&    sub begin_polygon {
\&        my $self = shift;
\&        my $tess = $self\->tess;
\&        # self will be passed as last arg ([\-1]) to all callbacks as opaque polygon data
\&        return OpenGL::gluTessBeginPolygon($tess, $self);
\&    }
\&
\&    sub end_polygon   { OpenGL::gluTessEndPolygon(  shift\->tess) }
\&    sub begin_contour { OpenGL::gluTessBeginContour(shift\->tess) }
\&    sub end_contour   { OpenGL::gluTessEndContour(  shift\->tess) }
\&
\&    sub draw_contours {
\&        my $self = shift;
\&        $self\->begin_polygon;
\&        foreach my $c (@_) {
\&            $self\->begin_contour;
\&            $self\->add_vertex(@$_) for @$c;
\&            $self\->end_contour;
\&        }
\&        $self\->end_polygon;
\&    }
\&
\&    sub add_vertex {
\&        my $self = shift;
\&        die \*(AqUsage $self\->add_vertex($x,$y,$z)\*(Aq if @_ < 3;
\&        if ($self\->do_colors) {
\&            push @_, 1 for @_ .. 6;
\&            OpenGL::gluTessVertex_p($self\->tess, @_[0..6]);
\&        } else {
\&            OpenGL::gluTessVertex_p($self\->tess, @_[0..3]);
\&        }
\&    }
\&
\&    sub _begin {
\&        my ($self, $enum) = @_;
\&        OpenGL::glBegin($enum);
\&    }
\&
\&    sub _end { OpenGL::glEnd() }
\&
\&    sub _vertex {
\&        my ($self, $x, $y, $z, $r, $g, $b, $a) = @_;
\&        OpenGL::glColor4f($r, $g, $b, $a) if $self\->do_colors;
\&        OpenGL::glVertex3f($x, $y, $z);
\&    }
\&
\&    sub _edge_flag {
\&        my ($self, $flag) = @_;
\&        return if $self\->{\*(Aqno_edge_flag\*(Aq};
\&        OpenGL::glEdgeFlag($flag);
\&    }
\&
\&    sub _error {
\&        my ($self, $errno) = @_;
\&        warn _\|_PACKAGE_\|_ ." error: ".OpenGL::gluErrorString($errno);
\&    }
\&
\&    sub _combine {
\&        my ($self, $x, $y, $z, $v0, $v1, $v2, $v3, $w0, $w1, $w2, $w3) = @_;
\&        return ($x, $y, $z) if !$self\->do_colors;
\&        return ($x, $y, $z,
\&                $w0*$v0\->[3] + $w1*$v1\->[3] + $w2*$v2\->[3] + $w3*$v3\->[3],
\&                $w0*$v0\->[4] + $w1*$v1\->[4] + $w2*$v2\->[4] + $w3*$v3\->[4],
\&                $w0*$v0\->[5] + $w1*$v1\->[5] + $w2*$v2\->[5] + $w3*$v3\->[5],
\&                $w0*$v0\->[6] + $w1*$v1\->[6] + $w2*$v2\->[6] + $w3*$v3\->[6]);
\&    }
\&
\&    1;
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\&  Paul Seamons \- paul AT seamons dot com \- 2011
.Ve
