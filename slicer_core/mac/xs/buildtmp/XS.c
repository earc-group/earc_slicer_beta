/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.35 from the
 * contents of main.xs. Do not edit this file, edit main.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "buildtmp/main.xs"
/*
 * WARNING: This file was auto-generated. Changes will be lost!
 */

#include <cstring>
#include <cstdlib>
#include <ostream>
#include <sstream>
#include <libslic3r/GCodeSender.hpp>

#ifdef __cplusplus
extern "C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "ppport.h"
#undef do_open
#undef do_close
#ifdef __cplusplus
}
#endif

#line 34 "buildtmp/XS.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 178 "buildtmp/XS.c"

/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/SLAPrint.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/SLAPrint.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__SLAPrint_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SLAPrint_new)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, model");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	SLAPrint *	RETVAL;
	Model*	model;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(model) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(model) )) {
              model = (Model *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("model is not of type %s (got %s)", Slic3r::perl_class_name(model), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SLAPrint::new() -- model is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 21 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SLAPrint.xsp\""
    try {
      RETVAL = new SLAPrint( model );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 225 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__SLAPrint_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SLAPrint_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SLAPrint *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SLAPrint *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SLAPrint::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SLAPrint.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 272 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__SLAPrint_apply_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SLAPrint_apply_config)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, config");
    {
	SLAPrint *	THIS;
	DynamicPrintConfig*	config;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SLAPrint *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SLAPrint::apply_config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(config) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(config) )) {
              config = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("config is not of type %s (got %s)", Slic3r::perl_class_name(config), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SLAPrint::apply_config() -- config is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SLAPrint.xsp\""
     THIS->config.apply(*config, true); 
#line 315 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__SLAPrint_slice); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SLAPrint_slice)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SLAPrint *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SLAPrint *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SLAPrint::slice() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 56 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SLAPrint.xsp\""
    try {
      THIS->slice();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 352 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__SLAPrint_layer_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SLAPrint_layer_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SLAPrint *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SLAPrint *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SLAPrint::layer_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 69 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SLAPrint.xsp\""
     RETVAL = THIS->layers.size(); 
#line 383 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__SLAPrint_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SLAPrint_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SLAPrint *	THIS;
	DynamicPrintConfig *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SLAPrint *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SLAPrint::config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 75 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SLAPrint.xsp\""
     RETVAL = new DynamicPrintConfig; RETVAL->apply(THIS->config); 
#line 414 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__SLAPrint_layer_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SLAPrint_layer_slices)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, i");
    {
	SLAPrint *	THIS;
	ExPolygons	RETVAL;
	size_t	i = (size_t)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SLAPrint *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SLAPrint::layer_slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 81 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SLAPrint.xsp\""
     RETVAL = THIS->layers[i].slices; 
#line 454 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExPolygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__SLAPrint_layer_solid_infill); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SLAPrint_layer_solid_infill)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, i");
    {
	SLAPrint *	THIS;
	ExPolygons	RETVAL;
	size_t	i = (size_t)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SLAPrint *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SLAPrint::layer_solid_infill() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 87 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SLAPrint.xsp\""
     RETVAL = THIS->layers[i].solid_infill; 
#line 500 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExPolygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__SLAPrint_layer_perimeters); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SLAPrint_layer_perimeters)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, i");
    {
	SLAPrint *	THIS;
	ExPolygons	RETVAL;
	size_t	i = (size_t)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SLAPrint *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SLAPrint::layer_perimeters() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 93 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SLAPrint.xsp\""
     RETVAL = THIS->layers[i].perimeters; 
#line 546 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExPolygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__SLAPrint_layer_infill); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SLAPrint_layer_infill)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, i");
    {
	SLAPrint *	THIS;
	Ref<ExtrusionEntityCollection>	RETVAL;
	size_t	i = (size_t)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SLAPrint *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SLAPrint::layer_infill() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 99 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SLAPrint.xsp\""
     RETVAL = &THIS->layers[i].infill; 
#line 592 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExtrusionEntityCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__SLAPrint_layer_solid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SLAPrint_layer_solid)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, i");
    {
	SLAPrint *	THIS;
	bool	RETVAL;
	dXSTARG;
	size_t	i = (size_t)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SLAPrint *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SLAPrint::layer_solid() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 105 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SLAPrint.xsp\""
     RETVAL = THIS->layers[i].solid; 
#line 633 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__SLAPrint_write_svg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SLAPrint_write_svg)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, file");
    {
	SLAPrint *	THIS;
	std::string	file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SLAPrint *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SLAPrint::write_svg() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      file = std::string(c, len);
    }
;
#line 111 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SLAPrint.xsp\""
    try {
      THIS->write_svg( file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 679 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__SLAPrint_heights); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SLAPrint_heights)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SLAPrint *	THIS;
	std::vector<double>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SLAPrint *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SLAPrint::heights() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 126 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SLAPrint.xsp\""
        for (std::vector<SLAPrint::Layer>::const_iterator it = THIS->layers.begin();
            it != THIS->layers.end();
            ++it)
            RETVAL.push_back(it->print_z);
#line 712 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSVnv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__SLAPrint_sm_pillars); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SLAPrint_sm_pillars)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SLAPrint *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SLAPrint *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SLAPrint::sm_pillars() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 136 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SLAPrint.xsp\""
        AV* av = newAV();
        for (std::vector<SLAPrint::SupportPillar>::const_iterator it = THIS->sm_pillars.begin();
            it != THIS->sm_pillars.end();
            ++it)
        {
            HV* hv = newHV();
            (void)hv_stores( hv, "top_layer",       newSViv(it->top_layer) );
            (void)hv_stores( hv, "bottom_layer",    newSViv(it->bottom_layer) );
            (void)hv_stores( hv, "point",           perl_to_SV_clone_ref((Point)*it) );
            av_push(av, newRV_noinc((SV*)hv));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 767 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/SLAPrint.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/GUI.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "slic3r/GUI/xsGUI.hpp"

XS_EUPXS(XS_Slic3r__GUI_disable_screensaver); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI_disable_screensaver)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 18 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GUI.xsp\""
     Slic3r::GUI::disable_screensaver(); 
#line 796 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI_enable_screensaver); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI_enable_screensaver)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 23 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GUI.xsp\""
     Slic3r::GUI::enable_screensaver(); 
#line 811 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/GUI.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Geometry.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/Geometry.hpp"

XS_EUPXS(XS_Slic3r__Geometry_arrange); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_arrange)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "total_parts, part, dist, bb= NULL");
    {
	Pointfs	RETVAL;
	size_t	total_parts = (size_t)SvUV(ST(0))
;
	Pointf*	part;
	coordf_t	dist = (coordf_t)SvNV(ST(2))
;
	BoundingBoxf*	bb;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(part) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(part) )) {
              part = (Pointf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("part is not of type %s (got %s)", Slic3r::perl_class_name(part), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::arrange() -- part is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 4)
	    bb = NULL;
	else {
    if( sv_isobject(ST(3)) && (SvTYPE(SvRV(ST(3))) == SVt_PVMG) ) {
	if ( sv_isa(ST(3), Slic3r::perl_class_name(bb) ) ||  sv_isa(ST(3), Slic3r::perl_class_name_ref(bb) )) {
	      bb = (BoundingBoxf *)SvIV((SV*)SvRV( ST(3) ));
	} else {
	      croak("bb is not of type %s (got %s)", Slic3r::perl_class_name(bb), HvNAME(SvSTASH(SvRV(ST(3)))));
	      XSRETURN_UNDEF;
	}
    } else {
	warn( "Slic3r::Geometry::arrange() -- bb is not a blessed SV reference" );
	XSRETURN_UNDEF;
    }
;
	}
#line 18 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Geometry.xsp\""
        Pointfs points;
        if (! Slic3r::Geometry::arrange(total_parts, *part, dist, bb, points))
            CONFESS("%zu parts won't fit in your print area!\n", total_parts);
        RETVAL = points;
#line 878 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Pointfs::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry_directions_parallel); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_directions_parallel)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "angle1, angle2");
    {
	double	angle1 = (double)SvNV(ST(0))
;
	double	angle2 = (double)SvNV(ST(1))
;
	bool	RETVAL;
	dXSTARG;
#line 31 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Geometry.xsp\""
        RETVAL = Slic3r::Geometry::directions_parallel(angle1, angle2);
#line 913 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry_directions_parallel_within); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_directions_parallel_within)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "angle1, angle2, max_diff");
    {
	double	angle1 = (double)SvNV(ST(0))
;
	double	angle2 = (double)SvNV(ST(1))
;
	double	max_diff = (double)SvNV(ST(2))
;
	bool	RETVAL;
	dXSTARG;
#line 41 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Geometry.xsp\""
        RETVAL = Slic3r::Geometry::directions_parallel(angle1, angle2, max_diff);
#line 937 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry_convex_hull); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_convex_hull)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "points");
    {
	Points	points;
	Clone<Polygon>	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        points.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &points[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::convex_hull",
	             "points")
;
#line 49 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Geometry.xsp\""
        RETVAL = Slic3r::Geometry::convex_hull(points);
#line 969 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polygon>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry_chained_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_chained_path)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "points");
    {
	Points	points;
	std::vector<Points::size_type>	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        points.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &points[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::chained_path",
	             "points")
;
#line 57 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Geometry.xsp\""
        Slic3r::Geometry::chained_path(points, RETVAL);
#line 1008 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSViv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry_chained_path_from); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_chained_path_from)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "points, start_from");
    {
	Points	points;
	Point*	start_from;
	std::vector<Points::size_type>	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        points.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &points[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::chained_path_from",
	             "points")
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(start_from) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(start_from) )) {
              start_from = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("start_from is not of type %s (got %s)", Slic3r::perl_class_name(start_from), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::chained_path_from() -- start_from is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 66 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Geometry.xsp\""
        Slic3r::Geometry::chained_path(points, RETVAL, *start_from);
#line 1067 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSViv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry_rad2deg); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_rad2deg)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "angle");
    {
	double	angle = (double)SvNV(ST(0))
;
	double	RETVAL;
	dXSTARG;
#line 74 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Geometry.xsp\""
        RETVAL = Slic3r::Geometry::rad2deg(angle);
#line 1100 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry_rad2deg_dir); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_rad2deg_dir)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "angle");
    {
	double	angle = (double)SvNV(ST(0))
;
	double	RETVAL;
	dXSTARG;
#line 82 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Geometry.xsp\""
        RETVAL = Slic3r::Geometry::rad2deg_dir(angle);
#line 1120 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry_deg2rad); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry_deg2rad)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "angle");
    {
	double	angle = (double)SvNV(ST(0))
;
	double	RETVAL;
	dXSTARG;
#line 90 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Geometry.xsp\""
        RETVAL = Slic3r::Geometry::deg2rad(angle);
#line 1140 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__constant)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;
#line 103 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Geometry.xsp\""
    RETVAL = ix;
#line 1159 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Geometry.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/MotionPlanner.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/MotionPlanner.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__MotionPlanner_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__MotionPlanner_new)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, islands");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	MotionPlanner *	RETVAL;
	ExPolygons	islands;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        islands.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &islands[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::MotionPlanner::new",
	             "islands")
;
#line 21 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/MotionPlanner.xsp\""
    try {
      RETVAL = new MotionPlanner( islands );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1215 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__MotionPlanner_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__MotionPlanner_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	MotionPlanner *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (MotionPlanner *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::MotionPlanner::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/MotionPlanner.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1262 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__MotionPlanner_islands_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__MotionPlanner_islands_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	MotionPlanner *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (MotionPlanner *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::MotionPlanner::islands_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/MotionPlanner.xsp\""
    try {
      RETVAL = THIS->islands_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1301 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__MotionPlanner_shortest_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__MotionPlanner_shortest_path)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, from, to");
    {
	MotionPlanner *	THIS;
	Clone<Polyline>	RETVAL;
	Point*	from;
	Point*	to;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (MotionPlanner *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::MotionPlanner::shortest_path() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(from) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(from) )) {
              from = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("from is not of type %s (got %s)", Slic3r::perl_class_name(from), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::MotionPlanner::shortest_path() -- from is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(to) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(to) )) {
              to = (Point *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("to is not of type %s (got %s)", Slic3r::perl_class_name(to), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::MotionPlanner::shortest_path() -- to is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 65 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/MotionPlanner.xsp\""
     RETVAL = THIS->shortest_path(*from, *to); 
#line 1360 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/MotionPlanner.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Layer.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/Layer.hpp"

XS_EUPXS(XS_Slic3r__Layer__Region_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Ref<Layer>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 19 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      RETVAL = THIS->layer();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1418 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Layer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_region)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Ref<PrintRegion>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::region() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 33 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      RETVAL = THIS->region();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1464 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<PrintRegion>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_slices)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Ref<SurfaceCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 47 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = &THIS->slices; 
#line 1502 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<SurfaceCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_thin_fills); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_thin_fills)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Ref<ExtrusionEntityCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::thin_fills() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 53 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = &THIS->thin_fills; 
#line 1540 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExtrusionEntityCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_fill_surfaces); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_fill_surfaces)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Ref<SurfaceCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::fill_surfaces() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 59 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = &THIS->fill_surfaces; 
#line 1578 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<SurfaceCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_bridged); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_bridged)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::bridged() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 65 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = THIS->bridged; 
#line 1616 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_unsupported_bridge_edges); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_unsupported_bridge_edges)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Ref<PolylineCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::unsupported_bridge_edges() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 71 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = &THIS->unsupported_bridge_edges; 
#line 1660 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<PolylineCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_perimeters); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_perimeters)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Ref<ExtrusionEntityCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::perimeters() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 77 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = &THIS->perimeters; 
#line 1698 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExtrusionEntityCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_fills); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_fills)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	Ref<ExtrusionEntityCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::fills() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 83 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = &THIS->fills; 
#line 1736 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExtrusionEntityCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_flow)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "THIS, role, bridge= false, width= -1");
    {
	LayerRegion *	THIS;
	Clone<Flow>	RETVAL;
	FlowRole	role = (FlowRole)SvUV(ST(1))
;
	bool	bridge;
	double	width;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    bridge = false;
	else {
	    bridge = (bool)SvUV(ST(2))
;
	}

	if (items < 4)
	    width = -1;
	else {
	    width = (double)SvNV(ST(3))
;
	}
#line 89 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = THIS->flow(role, bridge, width); 
#line 1792 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Flow>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Region_merge_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_merge_slices)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::merge_slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 95 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      THIS->merge_slices();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1837 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Region_prepare_fill_surfaces); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_prepare_fill_surfaces)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::prepare_fill_surfaces() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 108 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      THIS->prepare_fill_surfaces();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1874 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Region_make_perimeters); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_make_perimeters)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, slices, fill_surfaces");
    {
	LayerRegion *	THIS;
	SurfaceCollection*	slices;
	SurfaceCollection*	fill_surfaces;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::make_perimeters() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(slices) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(slices) )) {
              slices = (SurfaceCollection *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("slices is not of type %s (got %s)", Slic3r::perl_class_name(slices), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::make_perimeters() -- slices is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(fill_surfaces) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(fill_surfaces) )) {
              fill_surfaces = (SurfaceCollection *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("fill_surfaces is not of type %s (got %s)", Slic3r::perl_class_name(fill_surfaces), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::make_perimeters() -- fill_surfaces is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 121 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     THIS->make_perimeters(*slices, fill_surfaces); 
#line 1931 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Region_infill_area_threshold); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Region_infill_area_threshold)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerRegion *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Region::infill_area_threshold() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 126 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      RETVAL = THIS->infill_area_threshold();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 1970 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_as_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_as_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	Ref<Layer>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::as_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 144 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = THIS; 
#line 2001 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Layer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_id)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 150 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      RETVAL = THIS->id();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 2048 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_set_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_set_id)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, id");
    {
	Layer *	THIS;
	int	id = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::set_id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 164 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      THIS->set_id( id );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 2088 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	Ref<PrintObject>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 177 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      RETVAL = THIS->object();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 2126 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<PrintObject>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_upper_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_upper_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	Ref<Layer>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::upper_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 191 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = THIS->upper_layer; 
#line 2164 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Layer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_lower_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_lower_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	Ref<Layer>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::lower_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 197 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = THIS->lower_layer; 
#line 2202 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Layer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_slicing_errors); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_slicing_errors)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::slicing_errors() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 203 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = THIS->slicing_errors; 
#line 2241 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_slice_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_slice_z)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	coordf_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::slice_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 209 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = THIS->slice_z; 
#line 2273 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_print_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_print_z)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	coordf_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::print_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 215 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = THIS->print_z; 
#line 2305 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_height)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	coordf_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::height() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 221 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = THIS->height; 
#line 2337 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_set_print_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_set_print_z)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, z");
    {
	Layer *	THIS;
	coordf_t	z = (coordf_t)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::set_print_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 227 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     THIS->print_z = z; 
#line 2369 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_set_height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_set_height)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, h");
    {
	Layer *	THIS;
	coordf_t	h = (coordf_t)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::set_height() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 232 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     THIS->height = h; 
#line 2400 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_set_upper_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_set_upper_layer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, layer");
    {
	Layer *	THIS;
	Layer*	layer;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::set_upper_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(layer) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(layer) )) {
              layer = (Layer *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("layer is not of type %s (got %s)", Slic3r::perl_class_name(layer), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::set_upper_layer() -- layer is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 237 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     THIS->upper_layer = layer; 
#line 2443 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_set_lower_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_set_lower_layer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, layer");
    {
	Layer *	THIS;
	Layer*	layer;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::set_lower_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(layer) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(layer) )) {
              layer = (Layer *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("layer is not of type %s (got %s)", Slic3r::perl_class_name(layer), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::set_lower_layer() -- layer is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 242 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     THIS->lower_layer = layer; 
#line 2486 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_has_upper_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_has_upper_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::has_upper_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 247 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = (THIS->upper_layer != NULL); 
#line 2517 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_has_lower_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_has_lower_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::has_lower_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 253 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = (THIS->lower_layer != NULL); 
#line 2549 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_region_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_region_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::region_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 259 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      RETVAL = THIS->region_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 2589 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_get_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_get_region)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	Layer *	THIS;
	Ref<LayerRegion>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::get_region() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 273 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      RETVAL = THIS->get_region( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 2630 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<LayerRegion>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_add_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_add_region)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, print_region");
    {
	Layer *	THIS;
	Ref<LayerRegion>	RETVAL;
	PrintRegion*	print_region;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::add_region() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(print_region) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(print_region) )) {
              print_region = (PrintRegion *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("print_region is not of type %s (got %s)", Slic3r::perl_class_name(print_region), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::add_region() -- print_region is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 287 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      RETVAL = THIS->add_region( print_region );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 2690 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<LayerRegion>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_slices)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	Ref<ExPolygonCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 301 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = &THIS->slices; 
#line 2728 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExPolygonCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_ptr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_ptr)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::ptr() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 307 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = (int)(intptr_t)THIS; 
#line 2767 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_as_support_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_as_support_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;
	Ref<SupportLayer>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::as_support_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 313 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = dynamic_cast<SupportLayer*>(THIS); 
#line 2798 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<SupportLayer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_make_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_make_slices)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::make_slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 319 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      THIS->make_slices();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 2843 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_merge_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_merge_slices)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::merge_slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 332 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      THIS->merge_slices();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 2880 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_any_internal_region_slice_contains_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_any_internal_region_slice_contains_polyline)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, polyline");
    {
	Layer *	THIS;
	bool	RETVAL;
	dXSTARG;
	Polyline*	polyline;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::any_internal_region_slice_contains_polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(polyline) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(polyline) )) {
              polyline = (Polyline *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("polyline is not of type %s (got %s)", Slic3r::perl_class_name(polyline), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::any_internal_region_slice_contains_polyline() -- polyline is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 345 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = THIS->any_internal_region_slice_contains(*polyline); 
#line 2925 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_any_bottom_region_slice_contains_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_any_bottom_region_slice_contains_polyline)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, polyline");
    {
	Layer *	THIS;
	bool	RETVAL;
	dXSTARG;
	Polyline*	polyline;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::any_bottom_region_slice_contains_polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(polyline) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(polyline) )) {
              polyline = (Polyline *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("polyline is not of type %s (got %s)", Slic3r::perl_class_name(polyline), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::any_bottom_region_slice_contains_polyline() -- polyline is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 351 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = THIS->any_bottom_region_slice_contains(*polyline); 
#line 2971 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer_make_perimeters); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_make_perimeters)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::make_perimeters() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 357 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      THIS->make_perimeters();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 3009 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer_make_fills); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer_make_fills)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Layer *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Layer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::make_fills() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 370 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      THIS->make_fills();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 3046 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Support_as_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_as_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	Ref<Layer>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::as_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 387 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = THIS; 
#line 3076 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Layer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_support_islands); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_support_islands)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	Ref<ExPolygonCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::support_islands() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 393 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = &THIS->support_islands; 
#line 3114 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExPolygonCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_support_fills); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_support_fills)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	Ref<ExtrusionEntityCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::support_fills() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 399 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = &THIS->support_fills; 
#line 3152 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExtrusionEntityCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_support_interface_fills); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_support_interface_fills)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	Ref<ExtrusionEntityCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::support_interface_fills() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 405 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = &THIS->support_interface_fills; 
#line 3190 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExtrusionEntityCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_id)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 413 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      RETVAL = THIS->id();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 3237 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_set_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_set_id)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, id");
    {
	SupportLayer *	THIS;
	int	id = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::set_id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 427 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      THIS->set_id( id );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 3277 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Support_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	Ref<PrintObject>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 440 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      RETVAL = THIS->object();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 3315 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<PrintObject>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_upper_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_upper_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	Ref<SupportLayer>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::upper_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 454 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = (SupportLayer*)THIS->upper_layer; 
#line 3353 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<SupportLayer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_lower_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_lower_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	Ref<SupportLayer>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::lower_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 460 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = (SupportLayer*)THIS->lower_layer; 
#line 3391 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<SupportLayer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_slicing_errors); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_slicing_errors)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::slicing_errors() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 466 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = THIS->slicing_errors; 
#line 3430 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_slice_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_slice_z)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	coordf_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::slice_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 472 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = THIS->slice_z; 
#line 3462 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_print_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_print_z)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	coordf_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::print_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 478 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = THIS->print_z; 
#line 3494 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_height)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	coordf_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::height() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 484 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = THIS->height; 
#line 3526 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_set_upper_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_set_upper_layer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, layer");
    {
	SupportLayer *	THIS;
	SupportLayer*	layer;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::set_upper_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(layer) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(layer) )) {
              layer = (SupportLayer *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("layer is not of type %s (got %s)", Slic3r::perl_class_name(layer), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::set_upper_layer() -- layer is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 490 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     THIS->upper_layer = layer; 
#line 3570 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Support_set_lower_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_set_lower_layer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, layer");
    {
	SupportLayer *	THIS;
	SupportLayer*	layer;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::set_lower_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(layer) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(layer) )) {
              layer = (SupportLayer *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("layer is not of type %s (got %s)", Slic3r::perl_class_name(layer), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::set_lower_layer() -- layer is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 495 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     THIS->lower_layer = layer; 
#line 3613 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__Support_has_upper_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_has_upper_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::has_upper_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 500 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = (THIS->upper_layer != NULL); 
#line 3644 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_has_lower_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_has_lower_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::has_lower_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 506 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = (THIS->lower_layer != NULL); 
#line 3676 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_region_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_region_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::region_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 512 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      RETVAL = THIS->region_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 3716 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_get_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_get_region)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	SupportLayer *	THIS;
	Ref<LayerRegion>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::get_region() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 526 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      RETVAL = THIS->get_region( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 3757 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<LayerRegion>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_add_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_add_region)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, print_region");
    {
	SupportLayer *	THIS;
	Ref<LayerRegion>	RETVAL;
	PrintRegion*	print_region;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::add_region() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(print_region) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(print_region) )) {
              print_region = (PrintRegion *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("print_region is not of type %s (got %s)", Slic3r::perl_class_name(print_region), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::add_region() -- print_region is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 540 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
    try {
      RETVAL = THIS->add_region( print_region );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 3817 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<LayerRegion>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_slices)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SupportLayer *	THIS;
	Ref<ExPolygonCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 554 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = &THIS->slices; 
#line 3855 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExPolygonCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_any_internal_region_slice_contains_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_any_internal_region_slice_contains_polyline)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, polyline");
    {
	SupportLayer *	THIS;
	bool	RETVAL;
	dXSTARG;
	Polyline*	polyline;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::any_internal_region_slice_contains_polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(polyline) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(polyline) )) {
              polyline = (Polyline *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("polyline is not of type %s (got %s)", Slic3r::perl_class_name(polyline), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::any_internal_region_slice_contains_polyline() -- polyline is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 560 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = THIS->any_internal_region_slice_contains(*polyline); 
#line 3908 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__Support_any_bottom_region_slice_contains_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__Support_any_bottom_region_slice_contains_polyline)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, polyline");
    {
	SupportLayer *	THIS;
	bool	RETVAL;
	dXSTARG;
	Polyline*	polyline;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SupportLayer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::any_bottom_region_slice_contains_polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(polyline) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(polyline) )) {
              polyline = (Polyline *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("polyline is not of type %s (got %s)", Slic3r::perl_class_name(polyline), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::Support::any_bottom_region_slice_contains_polyline() -- polyline is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 566 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Layer.xsp\""
     RETVAL = THIS->any_bottom_region_slice_contains(*polyline); 
#line 3954 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Layer.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/SlicingAdaptive.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/SlicingAdaptive.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__SlicingAdaptive_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SlicingAdaptive_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	SlicingAdaptive *	RETVAL;
#line 21 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SlicingAdaptive.xsp\""
    try {
      RETVAL = new SlicingAdaptive();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 3995 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__SlicingAdaptive_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SlicingAdaptive_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SlicingAdaptive *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SlicingAdaptive *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SlicingAdaptive::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SlicingAdaptive.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4042 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__SlicingAdaptive_clear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SlicingAdaptive_clear)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SlicingAdaptive *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SlicingAdaptive *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SlicingAdaptive::clear() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SlicingAdaptive.xsp\""
    try {
      THIS->clear();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4079 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__SlicingAdaptive_add_mesh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SlicingAdaptive_add_mesh)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, mesh");
    {
	SlicingAdaptive *	THIS;
	TriangleMesh*	mesh;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SlicingAdaptive *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SlicingAdaptive::add_mesh() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(mesh) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(mesh) )) {
              mesh = (TriangleMesh *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("mesh is not of type %s (got %s)", Slic3r::perl_class_name(mesh), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SlicingAdaptive::add_mesh() -- mesh is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 64 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SlicingAdaptive.xsp\""
    try {
      THIS->add_mesh( mesh );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4130 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__SlicingAdaptive_prepare); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SlicingAdaptive_prepare)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, object_size");
    {
	SlicingAdaptive *	THIS;
	coordf_t	object_size = (coordf_t)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SlicingAdaptive *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SlicingAdaptive::prepare() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 77 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SlicingAdaptive.xsp\""
    try {
      THIS->prepare( object_size );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4169 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__SlicingAdaptive_next_layer_height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SlicingAdaptive_next_layer_height)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "THIS, z, quality_factor, min_layer_height, max_layer_height");
    {
	SlicingAdaptive *	THIS;
	float	RETVAL;
	dXSTARG;
	coordf_t	z = (coordf_t)SvNV(ST(1))
;
	coordf_t	quality_factor = (coordf_t)SvNV(ST(2))
;
	coordf_t	min_layer_height = (coordf_t)SvNV(ST(3))
;
	coordf_t	max_layer_height = (coordf_t)SvNV(ST(4))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SlicingAdaptive *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SlicingAdaptive::next_layer_height() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 90 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SlicingAdaptive.xsp\""
    try {
      RETVAL = THIS->next_layer_height( z, quality_factor, min_layer_height, max_layer_height );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4216 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__SlicingAdaptive_horizontal_facet_distance); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__SlicingAdaptive_horizontal_facet_distance)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, z, max_layer_height");
    {
	SlicingAdaptive *	THIS;
	float	RETVAL;
	dXSTARG;
	coordf_t	z = (coordf_t)SvNV(ST(1))
;
	coordf_t	max_layer_height = (coordf_t)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SlicingAdaptive *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::SlicingAdaptive::horizontal_facet_distance() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 104 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SlicingAdaptive.xsp\""
    try {
      RETVAL = THIS->horizontal_facet_distance( z, max_layer_height );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4260 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/SlicingAdaptive.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/ConditionalGcode.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/ConditionalGCode.hpp"

XS_EUPXS(XS_Slic3r__ConditionalGCode_apply_math); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ConditionalGCode_apply_math)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "input");
    {
	std::string	RETVAL;
	std::string	input;

    {
      size_t len;
      const char * c = SvPVutf8(ST(0), len);
      input = std::string(c, len);
    }
;
#line 19 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ConditionalGcode.xsp\""
        RETVAL = Slic3r::apply_math(input);
#line 4297 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/ConditionalGcode.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/SurfaceCollection.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/SurfaceCollection.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Surface__Collection__new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection__new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	SurfaceCollection *	RETVAL;
#line 21 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SurfaceCollection.xsp\""
    try {
      RETVAL = new SurfaceCollection();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4343 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Surface__Collection_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SurfaceCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SurfaceCollection.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4390 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Surface__Collection_clear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_clear)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SurfaceCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::clear() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SurfaceCollection.xsp\""
     THIS->surfaces.clear(); 
#line 4419 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Surface__Collection_append); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_append)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, surface");
    {
	SurfaceCollection *	THIS;
	Surface*	surface;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::append() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(surface) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(surface) )) {
              surface = (Surface *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("surface is not of type %s (got %s)", Slic3r::perl_class_name(surface), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::append() -- surface is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 56 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SurfaceCollection.xsp\""
     THIS->surfaces.push_back(*surface); 
#line 4462 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Surface__Collection_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SurfaceCollection *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 61 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SurfaceCollection.xsp\""
     RETVAL = THIS->surfaces.size(); 
#line 4493 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface__Collection_simplify); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_simplify)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, tolerance");
    {
	SurfaceCollection *	THIS;
	double	tolerance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::simplify() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 67 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SurfaceCollection.xsp\""
    try {
      THIS->simplify( tolerance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4533 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Surface__Collection_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SurfaceCollection *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 82 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SurfaceCollection.xsp\""
        AV* av = newAV();
        av_fill(av, THIS->surfaces.size()-1);
        int i = 0;
        for (Surfaces::iterator it = THIS->surfaces.begin(); it != THIS->surfaces.end(); ++it) {
            av_store(av, i++, perl_to_SV_ref(*it));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 4569 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface__Collection_filter_by_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_filter_by_type)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, surface_type");
    {
	SurfaceType	surface_type = (SurfaceType)SvUV(ST(1))
;
	SurfaceCollection *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::filter_by_type() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 96 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SurfaceCollection.xsp\""
        AV* av = newAV();
        for (Surfaces::iterator it = THIS->surfaces.begin(); it != THIS->surfaces.end(); ++it) {
            if ((*it).surface_type == surface_type) av_push(av, perl_to_SV_ref(*it));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 4607 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface__Collection_replace); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_replace)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, index, surface");
    {
	int	index = (int)SvIV(ST(1))
;
	Surface*	surface;
	SurfaceCollection *	THIS;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(surface) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(surface) )) {
              surface = (Surface *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("surface is not of type %s (got %s)", Slic3r::perl_class_name(surface), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::replace() -- surface is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::replace() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 109 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SurfaceCollection.xsp\""
        THIS->surfaces[index] = *surface;
#line 4654 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Surface__Collection_set_surface_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_set_surface_type)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, index, surface_type");
    {
	int	index = (int)SvIV(ST(1))
;
	SurfaceType	surface_type = (SurfaceType)SvUV(ST(2))
;
	SurfaceCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::set_surface_type() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 116 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SurfaceCollection.xsp\""
        THIS->surfaces[index].surface_type = surface_type;
#line 4687 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Surface__Collection_group); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__Collection_group)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SurfaceCollection *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SurfaceCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::Collection::group() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 121 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SurfaceCollection.xsp\""
        // perform grouping
        std::vector<SurfacesConstPtr> groups;
        THIS->group(&groups);

        // build return arrayref
        AV* av = newAV();
        av_fill(av, groups.size()-1);
        size_t i = 0;
        for (std::vector<SurfacesConstPtr>::const_iterator it = groups.begin(); it != groups.end(); ++it) {
            AV* innerav = newAV();
            av_fill(innerav, it->size()-1);
            size_t j = 0;
            for (SurfacesConstPtr::const_iterator it_s = it->begin(); it_s != it->end(); ++it_s) {
                av_store(innerav, j++, perl_to_SV_clone_ref(**it_s));
            }
            av_store(av, i++, newRV_noinc((SV*)innerav));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 4734 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/SurfaceCollection.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/GCodeSender.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#ifdef BOOST_LIBS
#define XSpp_d0c954f0_097200
#include <xsinit.h>
#include "libslic3r/GCodeSender.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)
#define XSubPPtmpAAAA 1


XS_EUPXS(XS_Slic3r__GCode__Sender_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	GCodeSender *	RETVAL;
#line 24 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeSender.xsp\""
    try {
      RETVAL = new GCodeSender();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4780 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__GCode__Sender_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeSender *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 41 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeSender.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4827 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__Sender_connect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_connect)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, port, baud_rate");
    {
	GCodeSender *	THIS;
	bool	RETVAL;
	dXSTARG;
	std::string	port;
	unsigned int	baud_rate = (unsigned int)SvUV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::connect() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      port = std::string(c, len);
    }
;
#line 54 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeSender.xsp\""
    try {
      RETVAL = THIS->connect( port, baud_rate );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4876 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Sender_disconnect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_disconnect)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeSender *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::disconnect() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 68 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeSender.xsp\""
    try {
      THIS->disconnect();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4914 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__Sender_is_connected); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_is_connected)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeSender *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::is_connected() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 81 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeSender.xsp\""
    try {
      RETVAL = THIS->is_connected();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 4953 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Sender_wait_connected); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_wait_connected)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "THIS, timeout= 3");
    {
	GCodeSender *	THIS;
	bool	RETVAL;
	dXSTARG;
	unsigned int	timeout;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::wait_connected() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 2)
	    timeout = 3;
	else {
	    timeout = (unsigned int)SvUV(ST(1))
;
	}
#line 95 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeSender.xsp\""
    try {
      RETVAL = THIS->wait_connected( timeout );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5001 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Sender_queue_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_queue_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeSender *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::queue_size() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 109 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeSender.xsp\""
    try {
      RETVAL = THIS->queue_size();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5041 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Sender_send); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_send)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, s, priority= false");
    {
	GCodeSender *	THIS;
	std::string	s;
	bool	priority;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::send() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      s = std::string(c, len);
    }
;

	if (items < 3)
	    priority = false;
	else {
	    priority = (bool)SvUV(ST(2))
;
	}
#line 123 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeSender.xsp\""
    try {
      THIS->send( s, priority );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5095 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__Sender_pause_queue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_pause_queue)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeSender *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::pause_queue() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 136 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeSender.xsp\""
    try {
      THIS->pause_queue();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5132 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__Sender_resume_queue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_resume_queue)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeSender *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::resume_queue() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 149 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeSender.xsp\""
    try {
      THIS->resume_queue();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5169 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__Sender_purge_queue); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_purge_queue)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "THIS, priority= false");
    {
	GCodeSender *	THIS;
	bool	priority;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::purge_queue() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 2)
	    priority = false;
	else {
	    priority = (bool)SvUV(ST(1))
;
	}
#line 162 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeSender.xsp\""
    try {
      THIS->purge_queue( priority );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5214 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__Sender_purge_log); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_purge_log)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeSender *	THIS;
	std::vector<std::string>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::purge_log() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 175 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeSender.xsp\""
    try {
      RETVAL = THIS->purge_log();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5252 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      const std::string& str = RETVAL[i];
	      STRLEN len = str.length();
	      av_store(av, i, newSVpvn_utf8(str.c_str(), len, true));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Sender_getT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_getT)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeSender *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::getT() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 189 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeSender.xsp\""
    try {
      RETVAL = THIS->getT();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5306 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Sender_getB); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Sender_getB)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeSender *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeSender *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Sender::getB() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 203 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeSender.xsp\""
    try {
      RETVAL = THIS->getB();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5350 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#endif

/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/GCodeSender.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/XS.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>

XS_EUPXS(XS_Slic3r_VERSION); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r_VERSION)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;
#line 25 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/XS.xsp\""
        RETVAL = newSVpv(SLIC3R_VERSION, 0);
#line 5384 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r_GITVERSION); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r_GITVERSION)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;
#line 31 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/XS.xsp\""
        RETVAL = newSVpv(SLIC3R_GIT, 0);
#line 5402 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r_xspp_test_croak_hangs_on_strawberry); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r_xspp_test_croak_hangs_on_strawberry)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 37 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/XS.xsp\""
    	try {
    		throw 1;
    	} catch (...) {
    		croak("xspp_test_croak_hangs_on_strawberry: exception catched\n");
    	}
#line 5423 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/XS.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Flow.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/Flow.hpp"

XS_EUPXS(XS_Slic3r__Flow_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 18 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Flow.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5472 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Flow__new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow__new)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "CLASS, width, height, nozzle_diameter");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Flow *	RETVAL;
	float	width = (float)SvNV(ST(1))
;
	float	height = (float)SvNV(ST(2))
;
	float	nozzle_diameter = (float)SvNV(ST(3))
;
#line 34 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Flow.xsp\""
    try {
      RETVAL = new Flow( width, height, nozzle_diameter );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5506 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Flow_set_height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_set_height)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, height");
    {
	Flow *	THIS;
	float	height = (float)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::set_height() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Flow.xsp\""
     THIS->height = height; 
#line 5547 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Flow_set_bridge); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_set_bridge)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, bridge");
    {
	Flow *	THIS;
	bool	bridge = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::set_bridge() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 56 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Flow.xsp\""
     THIS->bridge = bridge; 
#line 5578 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Flow_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;
	Clone<Flow>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 61 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Flow.xsp\""
     RETVAL = THIS; 
#line 5608 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Flow>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_width); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_width)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;
	float	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::width() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 67 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Flow.xsp\""
     RETVAL = THIS->width; 
#line 5647 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_height)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;
	float	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::height() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 73 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Flow.xsp\""
     RETVAL = THIS->height; 
#line 5679 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_nozzle_diameter); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_nozzle_diameter)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;
	float	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::nozzle_diameter() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 79 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Flow.xsp\""
     RETVAL = THIS->nozzle_diameter; 
#line 5711 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_bridge); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_bridge)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::bridge() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 85 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Flow.xsp\""
     RETVAL = THIS->bridge; 
#line 5743 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_spacing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_spacing)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;
	float	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::spacing() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 91 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Flow.xsp\""
    try {
      RETVAL = THIS->spacing();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5783 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_spacing_to); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_spacing_to)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	Flow *	THIS;
	float	RETVAL;
	dXSTARG;
	Flow*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::spacing_to() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (Flow *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::spacing_to() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 105 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Flow.xsp\""
     RETVAL = THIS->spacing(*other); 
#line 5829 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_scaled_width); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_scaled_width)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::scaled_width() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 111 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Flow.xsp\""
    try {
      RETVAL = THIS->scaled_width();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5869 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_scaled_spacing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_scaled_spacing)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::scaled_spacing() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 125 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Flow.xsp\""
    try {
      RETVAL = THIS->scaled_spacing();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5909 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_mm3_per_mm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_mm3_per_mm)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Flow *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Flow *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Flow::mm3_per_mm() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 139 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Flow.xsp\""
    try {
      RETVAL = THIS->mm3_per_mm();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 5949 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow__new_from_width); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow__new_from_width)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "CLASS, role, width, nozzle_diameter, height, bridge_flow_ratio");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	FlowRole	role = (FlowRole)SvUV(ST(1))
;
	std::string	width;
	float	nozzle_diameter = (float)SvNV(ST(3))
;
	float	height = (float)SvNV(ST(4))
;
	float	bridge_flow_ratio = (float)SvNV(ST(5))
;
	Flow *	RETVAL;

    {
      size_t len;
      const char * c = SvPVutf8(ST(2), len);
      width = std::string(c, len);
    }
;
#line 161 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Flow.xsp\""
        ConfigOptionFloatOrPercent optwidth;
        optwidth.deserialize(width);
        RETVAL = new Flow(Flow::new_from_config_width(role, optwidth, nozzle_diameter, height, bridge_flow_ratio));
#line 5986 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow__new_from_spacing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow__new_from_spacing)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "CLASS, spacing, nozzle_diameter, height, bridge");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	float	spacing = (float)SvNV(ST(1))
;
	float	nozzle_diameter = (float)SvNV(ST(2))
;
	float	height = (float)SvNV(ST(3))
;
	bool	bridge = (bool)SvUV(ST(4))
;
	Flow *	RETVAL;
#line 175 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Flow.xsp\""
        RETVAL = new Flow(Flow::new_from_spacing(spacing, nozzle_diameter, height, bridge));
#line 6020 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow__constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow__constant)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;
#line 198 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Flow.xsp\""
    RETVAL = ix;
#line 6046 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Flow_solid_spacing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Flow_solid_spacing)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "width, distance");
    {
	coord_t	RETVAL;
	dXSTARG;
	coord_t	width = (coord_t)SvIV(ST(0))
;
	coord_t	distance = (coord_t)SvIV(ST(1))
;
#line 206 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Flow.xsp\""
     RETVAL = Flow::solid_spacing(width, distance); 
#line 6068 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Flow.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Point.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/libslic3r.h"
#include "libslic3r/Point.hpp"
#include "libslic3r/Polygon.hpp"
#include "libslic3r/Polyline.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Point_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_new)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "CLASS, _x= 0, _y= 0");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Point *	RETVAL;
	coord_t	_x;
	coord_t	_y;

	if (items < 2)
	    _x = 0;
	else {
	    _x = (coord_t)SvIV(ST(1))
;
	}

	if (items < 3)
	    _y = 0;
	else {
	    _y = (coord_t)SvIV(ST(2))
;
	}
#line 24 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
    try {
      RETVAL = new Point( _x, _y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6128 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Point_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 41 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6175 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Point_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 54 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL=THIS; 
#line 6205 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	Point *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 60 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6252 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Point_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_translate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, x, y");
    {
	Point *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 73 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
    try {
      THIS->translate( x, y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6293 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Point_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 86 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = to_SV_pureperl(THIS); 
#line 6323 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 92 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = to_SV_pureperl(THIS); 
#line 6355 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_x)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::x() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 98 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->x; 
#line 6388 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_y)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::y() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 104 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->y; 
#line 6420 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_set_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_set_x)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	Point *	THIS;
	long	val = (long)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::set_x() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 110 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     THIS->x = val; 
#line 6452 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Point_set_y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_set_y)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	Point *	THIS;
	long	val = (long)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::set_y() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 115 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     THIS->y = val; 
#line 6483 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Point_nearest_point_index); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_nearest_point_index)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, points");
    {
	Point *	THIS;
	int	RETVAL;
	dXSTARG;
	Points	points;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::nearest_point_index() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        points.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &points[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Point::nearest_point_index",
	             "points")
;
#line 120 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
    try {
      RETVAL = THIS->nearest_point_index( points );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 6537 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_nearest_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_nearest_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, points");
    {
	Point *	THIS;
	Clone<Point>	RETVAL;
	Points	points;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::nearest_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        points.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &points[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Point::nearest_point",
	             "points")
;
#line 134 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     Point p; THIS->nearest_point(points, &p); RETVAL = p; 
#line 6583 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_distance_to); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_distance_to)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Point *	THIS;
	double	RETVAL;
	dXSTARG;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::distance_to() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::distance_to() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 140 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->distance_to(*point); 
#line 6636 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_distance_to_line); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_distance_to_line)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, line");
    {
	Point *	THIS;
	double	RETVAL;
	dXSTARG;
	Line*	line;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::distance_to_line() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(line) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(line) )) {
              line = (Line *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("line is not of type %s (got %s)", Slic3r::perl_class_name(line), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::distance_to_line() -- line is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 146 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->distance_to(*line); 
#line 6682 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_perp_distance_to_line); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_perp_distance_to_line)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, line");
    {
	Point *	THIS;
	double	RETVAL;
	dXSTARG;
	Line*	line;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::perp_distance_to_line() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(line) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(line) )) {
              line = (Line *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("line is not of type %s (got %s)", Slic3r::perl_class_name(line), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::perp_distance_to_line() -- line is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 152 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->perp_distance_to(*line); 
#line 6728 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_ccw); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_ccw)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, p1, p2");
    {
	Point *	THIS;
	double	RETVAL;
	dXSTARG;
	Point*	p1;
	Point*	p2;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::ccw() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(p1) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(p1) )) {
              p1 = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("p1 is not of type %s (got %s)", Slic3r::perl_class_name(p1), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::ccw() -- p1 is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(p2) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(p2) )) {
              p2 = (Point *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("p2 is not of type %s (got %s)", Slic3r::perl_class_name(p2), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::ccw() -- p2 is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 158 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->ccw(*p1, *p2); 
#line 6788 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_ccw_angle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_ccw_angle)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, p1, p2");
    {
	Point *	THIS;
	double	RETVAL;
	dXSTARG;
	Point*	p1;
	Point*	p2;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::ccw_angle() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(p1) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(p1) )) {
              p1 = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("p1 is not of type %s (got %s)", Slic3r::perl_class_name(p1), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::ccw_angle() -- p1 is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(p2) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(p2) )) {
              p2 = (Point *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("p2 is not of type %s (got %s)", Slic3r::perl_class_name(p2), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::ccw_angle() -- p2 is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 164 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->ccw_angle(*p1, *p2); 
#line 6848 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_projection_onto_polygon); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_projection_onto_polygon)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, polygon");
    {
	Point *	THIS;
	Clone<Point>	RETVAL;
	Polygon*	polygon;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::projection_onto_polygon() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(polygon) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(polygon) )) {
              polygon = (Polygon *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("polygon is not of type %s (got %s)", Slic3r::perl_class_name(polygon), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::projection_onto_polygon() -- polygon is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 170 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = new Point(THIS->projection_onto(*polygon)); 
#line 6893 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_projection_onto_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_projection_onto_polyline)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, polyline");
    {
	Point *	THIS;
	Clone<Point>	RETVAL;
	Polyline*	polyline;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::projection_onto_polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(polyline) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(polyline) )) {
              polyline = (Polyline *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("polyline is not of type %s (got %s)", Slic3r::perl_class_name(polyline), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::projection_onto_polyline() -- polyline is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 176 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = new Point(THIS->projection_onto(*polyline)); 
#line 6945 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_projection_onto_line); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_projection_onto_line)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, line");
    {
	Point *	THIS;
	Clone<Point>	RETVAL;
	Line*	line;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::projection_onto_line() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(line) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(line) )) {
              line = (Line *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("line is not of type %s (got %s)", Slic3r::perl_class_name(line), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::projection_onto_line() -- line is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 182 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = new Point(THIS->projection_onto(*line)); 
#line 6997 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_negative); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_negative)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::negative() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 188 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = new Point(THIS->negative()); 
#line 7035 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_coincides_with_epsilon); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_coincides_with_epsilon)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Point *	THIS;
	bool	RETVAL;
	dXSTARG;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::coincides_with_epsilon() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::coincides_with_epsilon() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 194 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->coincides_with_epsilon(*point); 
#line 7088 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_rotate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, angle, center_sv");
    {
	double	angle = (double)SvNV(ST(1))
;
	SV*	center_sv = ST(2)
;
	Point *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::rotate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 204 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
        Point center;
        from_SV_check(center_sv, &center);
        THIS->rotate(angle, center);
#line 7124 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Point_coincides_with); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point_coincides_with)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point_sv");
    {
	SV*	point_sv = ST(1)
;
	Point *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point::coincides_with() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 212 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
        Point point;
        from_SV_check(point_sv, &point);
        RETVAL = THIS->coincides_with(point);
#line 7159 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Point3_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point3_new)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 4)
       croak_xs_usage(cv,  "CLASS, _x= 0, _y= 0, _z= 0");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Point3 *	RETVAL;
	long	_x;
	long	_y;
	long	_z;

	if (items < 2)
	    _x = 0;
	else {
	    _x = (long)SvIV(ST(1))
;
	}

	if (items < 3)
	    _y = 0;
	else {
	    _y = (long)SvIV(ST(2))
;
	}

	if (items < 4)
	    _z = 0;
	else {
	    _z = (long)SvIV(ST(3))
;
	}
#line 229 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
    try {
      RETVAL = new Point3( _x, _y, _z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 7212 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Point3_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point3_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point3 *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point3::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 246 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 7259 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Point3_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point3_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point3 *	THIS;
	Clone<Point3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point3::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 259 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS; 
#line 7289 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point3_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point3_x)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point3 *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point3::x() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 265 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->x; 
#line 7328 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point3_y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point3_y)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point3 *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point3::y() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 271 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->y; 
#line 7360 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Point3_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Point3_z)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Point3 *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Point3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Point3::z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 277 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->z; 
#line 7392 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Pointf_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_new)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 3)
       croak_xs_usage(cv,  "CLASS, _x= 0, _y= 0");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Pointf *	RETVAL;
	double	_x;
	double	_y;

	if (items < 2)
	    _x = 0;
	else {
	    _x = (double)SvNV(ST(1))
;
	}

	if (items < 3)
	    _y = 0;
	else {
	    _y = (double)SvNV(ST(2))
;
	}
#line 289 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
    try {
      RETVAL = new Pointf( _x, _y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 7437 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Pointf_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 306 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 7484 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf *	THIS;
	Clone<Pointf>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 319 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS; 
#line 7514 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 325 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = to_SV_pureperl(THIS); 
#line 7552 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 331 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = to_SV_pureperl(THIS); 
#line 7584 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_x)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::x() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 337 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->x; 
#line 7617 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf_y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_y)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::y() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 343 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->y; 
#line 7649 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf_set_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_set_x)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	Pointf *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::set_x() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 349 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     THIS->x = val; 
#line 7681 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf_set_y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_set_y)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	Pointf *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::set_y() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 354 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     THIS->y = val; 
#line 7712 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_translate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, x, y");
    {
	Pointf *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 359 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
    try {
      THIS->translate( x, y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 7753 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	Pointf *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 372 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 7792 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_rotate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, angle, center");
    {
	Pointf *	THIS;
	double	angle = (double)SvNV(ST(1))
;
	Pointf*	center;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::rotate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(center) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(center) )) {
              center = (Pointf *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("center is not of type %s (got %s)", Slic3r::perl_class_name(center), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::rotate() -- center is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 385 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     THIS->rotate(angle, *center); 
#line 7837 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf_negative); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_negative)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf *	THIS;
	Clone<Pointf>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::negative() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 390 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->negative(); 
#line 7867 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf_vector_to); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf_vector_to)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Pointf *	THIS;
	Clone<Pointf>	RETVAL;
	Pointf*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::vector_to() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf::vector_to() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 396 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->vector_to(*point); 
#line 7919 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Pointf3_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_new)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 4)
       croak_xs_usage(cv,  "CLASS, _x= 0, _y= 0, _z= 0");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Pointf3 *	RETVAL;
	double	_x;
	double	_y;
	double	_z;

	if (items < 2)
	    _x = 0;
	else {
	    _x = (double)SvNV(ST(1))
;
	}

	if (items < 3)
	    _y = 0;
	else {
	    _y = (double)SvNV(ST(2))
;
	}

	if (items < 4)
	    _z = 0;
	else {
	    _z = (double)SvNV(ST(3))
;
	}
#line 408 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
    try {
      RETVAL = new Pointf3( _x, _y, _z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 7979 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Pointf3_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf3 *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 425 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8026 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf3_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf3 *	THIS;
	Clone<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 438 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS; 
#line 8056 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf3_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_x)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::x() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 444 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->x; 
#line 8095 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf3_y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_y)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::y() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 450 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->y; 
#line 8127 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf3_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_z)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 456 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->z; 
#line 8159 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf3_set_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_set_x)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	Pointf3 *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::set_x() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 462 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     THIS->x = val; 
#line 8191 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf3_set_y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_set_y)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	Pointf3 *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::set_y() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 467 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     THIS->y = val; 
#line 8222 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf3_set_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_set_z)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	Pointf3 *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::set_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 472 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     THIS->z = val; 
#line 8253 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf3_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_translate)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, x, y, z");
    {
	Pointf3 *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;
	double	z = (double)SvNV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 477 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
    try {
      THIS->translate( x, y, z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8296 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf3_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	Pointf3 *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 490 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8335 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Pointf3_distance_to); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_distance_to)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Pointf3 *	THIS;
	double	RETVAL;
	dXSTARG;
	Pointf3*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::distance_to() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::distance_to() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 503 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->distance_to(*point); 
#line 8380 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf3_negative); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_negative)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Pointf3 *	THIS;
	Clone<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::negative() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 509 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->negative(); 
#line 8411 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Pointf3_vector_to); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Pointf3_vector_to)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Pointf3 *	THIS;
	Clone<Pointf3>	RETVAL;
	Pointf3*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Pointf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::vector_to() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Pointf3::vector_to() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 515 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Point.xsp\""
     RETVAL = THIS->vector_to(*point); 
#line 8463 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Point.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "clipper.hpp"
#include "libslic3r/ClipperUtils.hpp"

XS_EUPXS(XS_Slic3r__Geometry__Clipper_offset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_offset)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 5)
       croak_xs_usage(cv,  "polygons, delta, scale= CLIPPER_OFFSET_SCALE, joinType= ClipperLib::jtMiter, miterLimit= 3");
    {
	Polygons	RETVAL;
	Polygons	polygons;
	float	delta = (float)SvNV(ST(1))
;
	double	scale;
	ClipperLib::JoinType	joinType;
	double	miterLimit;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        polygons.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &polygons[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::offset",
	             "polygons")
;

	if (items < 3)
	    scale = CLIPPER_OFFSET_SCALE;
	else {
	    scale = (double)SvNV(ST(2))
;
	}

	if (items < 4)
	    joinType = ClipperLib::jtMiter;
	else {
	    joinType = (ClipperLib::JoinType)SvUV(ST(3))
;
	}

	if (items < 5)
	    miterLimit = 3;
	else {
	    miterLimit = (double)SvNV(ST(4))
;
	}
#line 19 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp\""
    try {
      RETVAL = offset( polygons, delta, scale, joinType, miterLimit );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8549 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_offset_ex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_offset_ex)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 5)
       croak_xs_usage(cv,  "polygons, delta, scale= CLIPPER_OFFSET_SCALE, joinType= ClipperLib::jtMiter, miterLimit= 3");
    {
	ExPolygons	RETVAL;
	Polygons	polygons;
	float	delta = (float)SvNV(ST(1))
;
	double	scale;
	ClipperLib::JoinType	joinType;
	double	miterLimit;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        polygons.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &polygons[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::offset_ex",
	             "polygons")
;

	if (items < 3)
	    scale = CLIPPER_OFFSET_SCALE;
	else {
	    scale = (double)SvNV(ST(2))
;
	}

	if (items < 4)
	    joinType = ClipperLib::jtMiter;
	else {
	    joinType = (ClipperLib::JoinType)SvUV(ST(3))
;
	}

	if (items < 5)
	    miterLimit = 3;
	else {
	    miterLimit = (double)SvNV(ST(4))
;
	}
#line 33 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp\""
    try {
      RETVAL = offset_ex( polygons, delta, scale, joinType, miterLimit );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8628 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExPolygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_offset2); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_offset2)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 6)
       croak_xs_usage(cv,  "polygons, delta1, delta2, scale= CLIPPER_OFFSET_SCALE, joinType= ClipperLib::jtMiter, miterLimit= 3");
    {
	Polygons	RETVAL;
	Polygons	polygons;
	float	delta1 = (float)SvNV(ST(1))
;
	float	delta2 = (float)SvNV(ST(2))
;
	double	scale;
	ClipperLib::JoinType	joinType;
	double	miterLimit;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        polygons.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &polygons[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::offset2",
	             "polygons")
;

	if (items < 4)
	    scale = CLIPPER_OFFSET_SCALE;
	else {
	    scale = (double)SvNV(ST(3))
;
	}

	if (items < 5)
	    joinType = ClipperLib::jtMiter;
	else {
	    joinType = (ClipperLib::JoinType)SvUV(ST(4))
;
	}

	if (items < 6)
	    miterLimit = 3;
	else {
	    miterLimit = (double)SvNV(ST(5))
;
	}
#line 47 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp\""
    try {
      RETVAL = offset2( polygons, delta1, delta2, scale, joinType, miterLimit );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8709 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_offset2_ex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_offset2_ex)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 6)
       croak_xs_usage(cv,  "polygons, delta1, delta2, scale= CLIPPER_OFFSET_SCALE, joinType= ClipperLib::jtMiter, miterLimit= 3");
    {
	ExPolygons	RETVAL;
	Polygons	polygons;
	float	delta1 = (float)SvNV(ST(1))
;
	float	delta2 = (float)SvNV(ST(2))
;
	double	scale;
	ClipperLib::JoinType	joinType;
	double	miterLimit;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        polygons.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &polygons[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::offset2_ex",
	             "polygons")
;

	if (items < 4)
	    scale = CLIPPER_OFFSET_SCALE;
	else {
	    scale = (double)SvNV(ST(3))
;
	}

	if (items < 5)
	    joinType = ClipperLib::jtMiter;
	else {
	    joinType = (ClipperLib::JoinType)SvUV(ST(4))
;
	}

	if (items < 6)
	    miterLimit = 3;
	else {
	    miterLimit = (double)SvNV(ST(5))
;
	}
#line 61 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp\""
    try {
      RETVAL = offset2_ex( polygons, delta1, delta2, scale, joinType, miterLimit );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8790 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExPolygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_diff); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_diff)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "subject, clip, safety_offset= false");
    {
	Polygons	RETVAL;
	Polygons	subject;
	Polygons	clip;
	bool	safety_offset;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::diff",
	             "subject")
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        clip.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &clip[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::diff",
	             "clip")
;

	if (items < 3)
	    safety_offset = false;
	else {
	    safety_offset = (bool)SvUV(ST(2))
;
	}
#line 75 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp\""
    try {
      RETVAL = diff( subject, clip, safety_offset );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8866 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_diff_ex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_diff_ex)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "subject, clip, safety_offset= false");
    {
	ExPolygons	RETVAL;
	Polygons	subject;
	Polygons	clip;
	bool	safety_offset;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::diff_ex",
	             "subject")
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        clip.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &clip[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::diff_ex",
	             "clip")
;

	if (items < 3)
	    safety_offset = false;
	else {
	    safety_offset = (bool)SvUV(ST(2))
;
	}
#line 89 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp\""
    try {
      RETVAL = diff_ex( subject, clip, safety_offset );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 8942 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExPolygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_diff_pl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_diff_pl)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "subject, clip");
    {
	Polylines	RETVAL;
	Polylines	subject;
	Polygons	clip;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::diff_pl",
	             "subject")
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        clip.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &clip[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::diff_pl",
	             "clip")
;
#line 103 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp\""
    try {
      RETVAL = diff_pl( subject, clip );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9010 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polylines::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_intersection); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_intersection)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "subject, clip, safety_offset= false");
    {
	Polygons	RETVAL;
	Polygons	subject;
	Polygons	clip;
	bool	safety_offset;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::intersection",
	             "subject")
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        clip.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &clip[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::intersection",
	             "clip")
;

	if (items < 3)
	    safety_offset = false;
	else {
	    safety_offset = (bool)SvUV(ST(2))
;
	}
#line 117 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp\""
    try {
      RETVAL = intersection( subject, clip, safety_offset );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9086 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_intersection_ex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_intersection_ex)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "subject, clip, safety_offset= false");
    {
	ExPolygons	RETVAL;
	Polygons	subject;
	Polygons	clip;
	bool	safety_offset;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::intersection_ex",
	             "subject")
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        clip.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &clip[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::intersection_ex",
	             "clip")
;

	if (items < 3)
	    safety_offset = false;
	else {
	    safety_offset = (bool)SvUV(ST(2))
;
	}
#line 131 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp\""
    try {
      RETVAL = intersection_ex( subject, clip, safety_offset );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9162 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExPolygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_intersection_pl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_intersection_pl)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "subject, clip");
    {
	Polylines	RETVAL;
	Polylines	subject;
	Polygons	clip;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::intersection_pl",
	             "subject")
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        clip.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &clip[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::intersection_pl",
	             "clip")
;
#line 145 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp\""
    try {
      RETVAL = intersection_pl( subject, clip );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9230 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polylines::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_intersection_ppl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_intersection_ppl)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "subject, clip");
    {
	Polylines	RETVAL;
	Polygons	subject;
	Polygons	clip;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::intersection_ppl",
	             "subject")
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        clip.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &clip[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::intersection_ppl",
	             "clip")
;
#line 159 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp\""
    try {
      RETVAL = intersection_pl( subject, clip );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9298 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polylines::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_union); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_union)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "subject, safety_offset= false");
    {
	Polygons	RETVAL;
	Polygons	subject;
	bool	safety_offset;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::union",
	             "subject")
;

	if (items < 2)
	    safety_offset = false;
	else {
	    safety_offset = (bool)SvUV(ST(1))
;
	}
#line 173 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp\""
    try {
      RETVAL = union_( subject, safety_offset );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9359 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_union_ex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_union_ex)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "subject, safety_offset= false");
    {
	ExPolygons	RETVAL;
	Polygons	subject;
	bool	safety_offset;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::union_ex",
	             "subject")
;

	if (items < 2)
	    safety_offset = false;
	else {
	    safety_offset = (bool)SvUV(ST(1))
;
	}
#line 187 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp\""
    try {
      RETVAL = union_ex( subject, safety_offset );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9420 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExPolygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_union_pt_chained); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_union_pt_chained)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "subject, safety_offset= false");
    {
	Polygons	RETVAL;
	Polygons	subject;
	bool	safety_offset;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::union_pt_chained",
	             "subject")
;

	if (items < 2)
	    safety_offset = false;
	else {
	    safety_offset = (bool)SvUV(ST(1))
;
	}
#line 201 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp\""
    try {
      RETVAL = union_pt_chained( subject, safety_offset );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9481 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_simplify_polygons); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_simplify_polygons)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "subject");
    {
	Polygons	RETVAL;
	Polygons	subject;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::simplify_polygons",
	             "subject")
;
#line 215 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp\""
    try {
      RETVAL = simplify_polygons( subject );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9534 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper__constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper__constant)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;
#line 236 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp\""
    RETVAL = ix;
#line 9566 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__Clipper_union_pt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__Clipper_union_pt)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "subject, safety_offset = false");
    {
	Polygons	subject;
	bool	safety_offset;
	SV *	RETVAL;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        subject.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &subject[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::Clipper::union_pt",
	             "subject")
;

	if (items < 2)
	    safety_offset = false;
	else {
	    safety_offset = (bool)SvUV(ST(1))
;
	}
#line 244 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp\""
        // perform operation
        ClipperLib::PolyTree polytree = union_pt(subject, safety_offset);
        RETVAL = polynode_children_2_perl(polytree);
#line 9608 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Clipper.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/TriangleMesh.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__TriangleMesh_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	TriangleMesh *	RETVAL;
#line 21 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      RETVAL = new TriangleMesh();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9650 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__TriangleMesh_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9697 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	Clone<TriangleMesh>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
     RETVAL = THIS; 
#line 9727 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<TriangleMesh>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_ReadSTLFile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_ReadSTLFile)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, input_file");
    {
	TriangleMesh *	THIS;
	std::string	input_file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::ReadSTLFile() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      input_file = std::string(c, len);
    }
;
#line 57 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      THIS->ReadSTLFile( input_file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9780 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_write_ascii); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_write_ascii)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, output_file");
    {
	TriangleMesh *	THIS;
	std::string	output_file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::write_ascii() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      output_file = std::string(c, len);
    }
;
#line 70 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      THIS->write_ascii( output_file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9825 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_write_binary); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_write_binary)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, output_file");
    {
	TriangleMesh *	THIS;
	std::string	output_file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::write_binary() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      output_file = std::string(c, len);
    }
;
#line 83 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      THIS->write_binary( output_file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9870 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_check_topology); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_check_topology)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::check_topology() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 96 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      THIS->check_topology();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9907 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_repair); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_repair)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::repair() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 109 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      THIS->repair();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9944 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_volume); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_volume)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	float	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::volume() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 122 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      RETVAL = THIS->volume();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 9983 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_WriteOBJFile); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_WriteOBJFile)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, output_file");
    {
	TriangleMesh *	THIS;
	std::string	output_file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::WriteOBJFile() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      output_file = std::string(c, len);
    }
;
#line 136 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      THIS->WriteOBJFile( output_file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10029 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	TriangleMesh *	THIS;
	float	factor = (float)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 149 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10068 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_scale_xyz); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_scale_xyz)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, versor");
    {
	TriangleMesh *	THIS;
	Pointf3*	versor;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::scale_xyz() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(versor) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(versor) )) {
              versor = (Pointf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("versor is not of type %s (got %s)", Slic3r::perl_class_name(versor), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::scale_xyz() -- versor is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 162 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
     THIS->scale(*versor); 
#line 10111 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_translate)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, x, y, z");
    {
	TriangleMesh *	THIS;
	float	x = (float)SvNV(ST(1))
;
	float	y = (float)SvNV(ST(2))
;
	float	z = (float)SvNV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 167 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      THIS->translate( x, y, z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10154 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_rotate_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_rotate_x)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	TriangleMesh *	THIS;
	float	angle = (float)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::rotate_x() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 180 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      THIS->rotate_x( angle );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10193 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_rotate_y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_rotate_y)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	TriangleMesh *	THIS;
	float	angle = (float)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::rotate_y() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 193 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      THIS->rotate_y( angle );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10232 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_rotate_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_rotate_z)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	TriangleMesh *	THIS;
	float	angle = (float)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::rotate_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 206 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      THIS->rotate_z( angle );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10271 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_mirror_x); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_mirror_x)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::mirror_x() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 219 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      THIS->mirror_x();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10308 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_mirror_y); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_mirror_y)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::mirror_y() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 232 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      THIS->mirror_y();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10345 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_mirror_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_mirror_z)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::mirror_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 245 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      THIS->mirror_z();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10382 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_align_to_origin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_align_to_origin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::align_to_origin() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 258 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      THIS->align_to_origin();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10419 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_rotate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, angle, center");
    {
	TriangleMesh *	THIS;
	double	angle = (double)SvNV(ST(1))
;
	Point*	center;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::rotate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(center) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(center) )) {
              center = (Point *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("center is not of type %s (got %s)", Slic3r::perl_class_name(center), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::rotate() -- center is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 271 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      THIS->rotate( angle, center );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10472 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_split); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_split)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	TriangleMeshPtrs	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::split() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 284 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      RETVAL = THIS->split();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10510 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (TriangleMeshPtrs::iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, to_SV(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_cut_by_grid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_cut_by_grid)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, grid");
    {
	TriangleMesh *	THIS;
	TriangleMeshPtrs	RETVAL;
	Pointf*	grid;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::cut_by_grid() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(grid) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(grid) )) {
              grid = (Pointf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("grid is not of type %s (got %s)", Slic3r::perl_class_name(grid), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::cut_by_grid() -- grid is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 298 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
     RETVAL = THIS->cut_by_grid(*grid); 
#line 10568 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (TriangleMeshPtrs::iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, to_SV(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_merge); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_merge)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, mesh");
    {
	TriangleMesh *	THIS;
	TriangleMesh*	mesh;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::merge() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(mesh) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(mesh) )) {
              mesh = (TriangleMesh *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("mesh is not of type %s (got %s)", Slic3r::perl_class_name(mesh), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::merge() -- mesh is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 304 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
     THIS->merge(*mesh); 
#line 10625 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_horizontal_projection); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_horizontal_projection)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	ExPolygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::horizontal_projection() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 309 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      RETVAL = THIS->horizontal_projection();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10663 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExPolygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_convex_hull); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_convex_hull)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	Clone<Polygon>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::convex_hull() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 323 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      RETVAL = THIS->convex_hull();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10715 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polygon>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	Clone<BoundingBoxf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 337 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      RETVAL = THIS->bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10761 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBoxf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_center); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_center)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	Clone<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::center() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 351 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
     RETVAL = THIS->bounding_box().center(); 
#line 10799 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_facets_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_facets_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::facets_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 357 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      RETVAL = THIS->facets_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10846 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_reset_repair_stats); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_reset_repair_stats)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::reset_repair_stats() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 371 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      THIS->reset_repair_stats();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10884 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_reverse_normals); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_reverse_normals)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::reverse_normals() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 384 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    try {
      THIS->reverse_normals();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 10921 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_ReadFromPerl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_ReadFromPerl)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, vertices, facets");
    {
	SV*	vertices = ST(1)
;
	SV*	facets = ST(2)
;
	TriangleMesh *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::ReadFromPerl() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 401 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
        stl_file &stl = THIS->stl;
        stl.error = 0;
        stl.stats.type = inmemory;

        // count facets and allocate memory
        AV* facets_av = (AV*)SvRV(facets);
        stl.stats.number_of_facets = av_len(facets_av)+1;
        stl.stats.original_num_facets = stl.stats.number_of_facets;
        stl_allocate(&stl);

        // read geometry
        AV* vertices_av = (AV*)SvRV(vertices);
        for (int i = 0; i < stl.stats.number_of_facets; i++) {
            AV* facet_av = (AV*)SvRV(*av_fetch(facets_av, i, 0));
            stl_facet facet;
            facet.normal.x = 0;
            facet.normal.y = 0;
            facet.normal.z = 0;
            for (unsigned int v = 0; v <= 2; v++) {
                AV* vertex_av = (AV*)SvRV(*av_fetch(vertices_av, SvIV(*av_fetch(facet_av, v, 0)), 0));
                facet.vertex[v].x = SvNV(*av_fetch(vertex_av, 0, 0));
                facet.vertex[v].y = SvNV(*av_fetch(vertex_av, 1, 0));
                facet.vertex[v].z = SvNV(*av_fetch(vertex_av, 2, 0));
            }
            facet.extra[0] = 0;
            facet.extra[1] = 0;

            stl.facet_start[i] = facet;
        }

        stl_get_size(&stl);
#line 10984 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_stats); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_stats)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::stats() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 436 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
        HV* hv = newHV();
        (void)hv_stores( hv, "number_of_facets",    newSViv(THIS->stl.stats.number_of_facets) );
        (void)hv_stores( hv, "number_of_parts",     newSViv(THIS->stl.stats.number_of_parts) );
        (void)hv_stores( hv, "volume",              newSVnv(THIS->stl.stats.volume) );
        (void)hv_stores( hv, "degenerate_facets",   newSViv(THIS->stl.stats.degenerate_facets) );
        (void)hv_stores( hv, "edges_fixed",         newSViv(THIS->stl.stats.edges_fixed) );
        (void)hv_stores( hv, "facets_removed",      newSViv(THIS->stl.stats.facets_removed) );
        (void)hv_stores( hv, "facets_added",        newSViv(THIS->stl.stats.facets_added) );
        (void)hv_stores( hv, "facets_reversed",     newSViv(THIS->stl.stats.facets_reversed) );
        (void)hv_stores( hv, "backwards_edges",     newSViv(THIS->stl.stats.backwards_edges) );
        (void)hv_stores( hv, "normals_fixed",       newSViv(THIS->stl.stats.normals_fixed) );
        RETVAL = (SV*)newRV_noinc((SV*)hv);
#line 11025 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_vertices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_vertices)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::vertices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 454 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
        if (!THIS->repaired) CONFESS("vertices() requires repair()");

        if (THIS->stl.v_shared == NULL)
            stl_generate_shared_vertices(&(THIS->stl));

        // vertices
        AV* vertices = newAV();
        av_extend(vertices, THIS->stl.stats.shared_vertices);
        for (int i = 0; i < THIS->stl.stats.shared_vertices; i++) {
            AV* vertex = newAV();
            av_store(vertices, i, newRV_noinc((SV*)vertex));
            av_extend(vertex, 2);
            av_store(vertex, 0, newSVnv(THIS->stl.v_shared[i].x));
            av_store(vertex, 1, newSVnv(THIS->stl.v_shared[i].y));
            av_store(vertex, 2, newSVnv(THIS->stl.v_shared[i].z));
        }

        RETVAL = newRV_noinc((SV*)vertices);
#line 11074 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_facets); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_facets)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::facets() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 478 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
        if (!THIS->repaired) CONFESS("facets() requires repair()");

        if (THIS->stl.v_shared == NULL)
            stl_generate_shared_vertices(&(THIS->stl));

        // facets
        AV* facets = newAV();
        av_extend(facets, THIS->stl.stats.number_of_facets);
        for (int i = 0; i < THIS->stl.stats.number_of_facets; i++) {
            AV* facet = newAV();
            av_store(facets, i, newRV_noinc((SV*)facet));
            av_extend(facet, 2);
            av_store(facet, 0, newSVnv(THIS->stl.v_indices[i].vertex[0]));
            av_store(facet, 1, newSVnv(THIS->stl.v_indices[i].vertex[1]));
            av_store(facet, 2, newSVnv(THIS->stl.v_indices[i].vertex[2]));
        }

        RETVAL = newRV_noinc((SV*)facets);
#line 11123 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_normals); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_normals)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::normals() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 502 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
        if (!THIS->repaired) CONFESS("normals() requires repair()");

        // normals
        AV* normals = newAV();
        av_extend(normals, THIS->stl.stats.number_of_facets);
        for (int i = 0; i < THIS->stl.stats.number_of_facets; i++) {
            AV* facet = newAV();
            av_store(normals, i, newRV_noinc((SV*)facet));
            av_extend(facet, 2);
            av_store(facet, 0, newSVnv(THIS->stl.facet_start[i].normal.x));
            av_store(facet, 1, newSVnv(THIS->stl.facet_start[i].normal.y));
            av_store(facet, 2, newSVnv(THIS->stl.facet_start[i].normal.z));
        }

        RETVAL = newRV_noinc((SV*)normals);
#line 11169 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::size() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 523 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
        AV* size = newAV();
        av_extend(size, 2);
        av_store(size, 0, newSVnv(THIS->stl.stats.size.x));
        av_store(size, 1, newSVnv(THIS->stl.stats.size.y));
        av_store(size, 2, newSVnv(THIS->stl.stats.size.z));
        RETVAL = newRV_noinc((SV*)size);
#line 11206 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_slice); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_slice)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, z");
    {
	std::vector<double>	z;
	TriangleMesh *	THIS;
	SV *	RETVAL;

	if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(1));
	  const unsigned int len = av_len(av)+1;
	  z = std::vector<double>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      z[i] = SvNV(*elem);
	    else
	      z[i] = 0.;
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::TriangleMesh::slice",
	             "z")
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::slice() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 536 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
        // convert doubles to floats
        std::vector<float> z_f(z.begin(), z.end());

        std::vector<ExPolygons> layers;
        TriangleMeshSlicer<Z> mslicer(THIS);
        mslicer.slice(z_f, &layers);

        AV* layers_av = newAV();
        size_t len = layers.size();
        if (len > 0) av_extend(layers_av, len-1);
        for (unsigned int i = 0; i < layers.size(); i++) {
            AV* expolygons_av = newAV();
            len = layers[i].size();
            if (len > 0) av_extend(expolygons_av, len-1);
            unsigned int j = 0;
            for (ExPolygons::iterator it = layers[i].begin(); it != layers[i].end(); ++it) {
                av_store(expolygons_av, j++, perl_to_SV_clone_ref(*it));
            }
            av_store(layers_av, i, newRV_noinc((SV*)expolygons_av));
        }
        RETVAL = (SV*)newRV_noinc((SV*)layers_av);
#line 11278 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_slice_at); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_slice_at)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, axis, z");
    {
	Axis	axis = (Axis)SvUV(ST(1))
;
	double	z = (double)SvNV(ST(2))
;
	TriangleMesh *	THIS;
	ExPolygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::slice_at() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 565 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
        if (axis == X) {
            TriangleMeshSlicer<X>(THIS).slice(z, &RETVAL);
        } else if (axis == Y) {
            TriangleMeshSlicer<Y>(THIS).slice(z, &RETVAL);
        } else if (axis == Z) {
            TriangleMeshSlicer<Z>(THIS).slice(z, &RETVAL);
        }
#line 11320 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExPolygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_cut); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_cut)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "THIS, axis, z, upper, lower");
    {
	Axis	axis = (Axis)SvUV(ST(1))
;
	float	z = (float)SvNV(ST(2))
;
	TriangleMesh*	upper;
	TriangleMesh*	lower;
	TriangleMesh *	THIS;

    if( sv_isobject(ST(3)) && (SvTYPE(SvRV(ST(3))) == SVt_PVMG) ) {
        if ( sv_isa(ST(3), Slic3r::perl_class_name(upper) ) ||  sv_isa(ST(3), Slic3r::perl_class_name_ref(upper) )) {
              upper = (TriangleMesh *)SvIV((SV*)SvRV( ST(3) ));
        } else {
              croak("upper is not of type %s (got %s)", Slic3r::perl_class_name(upper), HvNAME(SvSTASH(SvRV(ST(3)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::cut() -- upper is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(4)) && (SvTYPE(SvRV(ST(4))) == SVt_PVMG) ) {
        if ( sv_isa(ST(4), Slic3r::perl_class_name(lower) ) ||  sv_isa(ST(4), Slic3r::perl_class_name_ref(lower) )) {
              lower = (TriangleMesh *)SvIV((SV*)SvRV( ST(4) ));
        } else {
              croak("lower is not of type %s (got %s)", Slic3r::perl_class_name(lower), HvNAME(SvSTASH(SvRV(ST(4)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::cut() -- lower is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::cut() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 582 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
        if (axis == X) {
            TriangleMeshSlicer<X>(THIS).cut(z, upper, lower);
        } else if (axis == Y) {
            TriangleMeshSlicer<Y>(THIS).cut(z, upper, lower);
        } else {
            TriangleMeshSlicer<Z>(THIS).cut(z, upper, lower);
        }
#line 11401 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__TriangleMesh_bb3); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_bb3)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	TriangleMesh *	THIS;
	std::vector<double>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (TriangleMesh *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::TriangleMesh::bb3() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 593 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
        RETVAL.push_back(THIS->stl.stats.min.x);
        RETVAL.push_back(THIS->stl.stats.min.y);
        RETVAL.push_back(THIS->stl.stats.max.x);
        RETVAL.push_back(THIS->stl.stats.max.y);
        RETVAL.push_back(THIS->stl.stats.min.z);
        RETVAL.push_back(THIS->stl.stats.max.z);
#line 11436 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSVnv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_make_cube); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_make_cube)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "x, y, z");
    {
	Clone<TriangleMesh>	RETVAL;
	double	x = (double)SvNV(ST(0))
;
	double	y = (double)SvNV(ST(1))
;
	double	z = (double)SvNV(ST(2))
;
#line 610 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
     RETVAL = TriangleMesh::make_cube(x, y, z); 
#line 11472 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<TriangleMesh>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_make_cylinder); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_make_cylinder)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "r, h");
    {
	Clone<TriangleMesh>	RETVAL;
	double	r = (double)SvNV(ST(0))
;
	double	h = (double)SvNV(ST(1))
;
#line 616 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
     RETVAL = TriangleMesh::make_cylinder(r, h); 
#line 11500 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<TriangleMesh>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_make_sphere); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_make_sphere)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "rho");
    {
	Clone<TriangleMesh>	RETVAL;
	double	rho = (double)SvNV(ST(0))
;
#line 622 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
     RETVAL = TriangleMesh::make_sphere(rho); 
#line 11526 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<TriangleMesh>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__TriangleMesh_hello_world); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__TriangleMesh_hello_world)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	std::string	RETVAL;
#line 631 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp\""
    RETVAL = "Hello world!";
#line 11550 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/TriangleMesh.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/BoundingBox.hpp"
#include "libslic3r/Point.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	BoundingBox *	RETVAL;
#line 22 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      RETVAL = new BoundingBox();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 11597 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 39 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 11644 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	Clone<BoundingBox>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 52 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS; 
#line 11674 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBox>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_merge); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_merge)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, bb");
    {
	BoundingBox *	THIS;
	BoundingBox*	bb;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::merge() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(bb) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(bb) )) {
              bb = (BoundingBox *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("bb is not of type %s (got %s)", Slic3r::perl_class_name(bb), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::merge() -- bb is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 58 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     THIS->merge(*bb); 
#line 11725 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_merge_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_merge_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	BoundingBox *	THIS;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::merge_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::merge_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 63 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     THIS->merge(*point); 
#line 11768 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	BoundingBox *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 68 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 11807 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_translate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, x, y");
    {
	BoundingBox *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 81 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      THIS->translate( x, y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 11848 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_offset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_offset)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, delta");
    {
	BoundingBox *	THIS;
	double	delta = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::offset() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 94 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      THIS->offset( delta );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 11887 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_contains_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_contains_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	BoundingBox *	THIS;
	bool	RETVAL;
	dXSTARG;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::contains_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::contains_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 107 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->contains(*point); 
#line 11932 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_polygon); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_polygon)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	Clone<Polygon>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::polygon() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 113 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      RETVAL = THIS->polygon();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 11971 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polygon>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::size() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 127 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      RETVAL = THIS->size();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 12017 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_center); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_center)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::center() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 141 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      RETVAL = THIS->center();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 12063 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_min_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_min_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::min_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 155 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->min; 
#line 12101 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_max_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_max_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::max_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 161 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->max; 
#line 12139 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_x_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_x_min)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::x_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 167 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->min.x; 
#line 12178 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_x_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_x_max)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::x_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 173 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->max.x; 
#line 12210 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_y_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_y_min)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::y_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 179 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->min.y; 
#line 12242 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_y_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_y_max)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	long	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::y_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 185 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->max.y; 
#line 12274 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_defined); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_defined)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBox *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBox *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBox::defined() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 191 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->defined; 
#line 12306 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_new_from_points); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBox_new_from_points)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, points");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	Points	points;
	BoundingBox *	RETVAL;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        points.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &points[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::BoundingBox::new_from_points",
	             "points")
;
#line 201 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
        RETVAL = new BoundingBox(points);
#line 12340 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	BoundingBoxf *	RETVAL;
#line 216 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      RETVAL = new BoundingBoxf();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 12376 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 233 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 12423 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	Clone<BoundingBoxf>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 246 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS; 
#line 12453 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBoxf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_merge); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_merge)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, bb");
    {
	BoundingBoxf *	THIS;
	BoundingBoxf*	bb;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::merge() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(bb) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(bb) )) {
              bb = (BoundingBoxf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("bb is not of type %s (got %s)", Slic3r::perl_class_name(bb), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::merge() -- bb is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 252 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     THIS->merge(*bb); 
#line 12504 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_merge_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_merge_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	BoundingBoxf *	THIS;
	Pointf*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::merge_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::merge_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 257 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     THIS->merge(*point); 
#line 12547 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	BoundingBoxf *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 262 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 12586 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_translate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, x, y");
    {
	BoundingBoxf *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 275 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      THIS->translate( x, y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 12627 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_contains_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_contains_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	BoundingBoxf *	THIS;
	bool	RETVAL;
	dXSTARG;
	Pointf*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::contains_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::contains_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 288 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->contains(*point); 
#line 12672 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	Clone<Pointf>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::size() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 294 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      RETVAL = THIS->size();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 12711 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_center); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_center)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	Clone<Pointf>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::center() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 308 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      RETVAL = THIS->center();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 12757 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_min_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_min_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	Clone<Pointf>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::min_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 322 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->min; 
#line 12795 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_max_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_max_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	Clone<Pointf>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::max_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 328 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->max; 
#line 12833 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_x_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_x_min)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::x_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 334 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->min.x; 
#line 12872 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_x_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_x_max)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::x_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 340 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->max.x; 
#line 12904 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_y_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_y_min)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::y_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 346 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->min.y; 
#line 12936 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_y_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_y_max)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::y_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 352 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->max.y; 
#line 12968 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_set_x_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_set_x_min)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	BoundingBoxf *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::set_x_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 358 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     THIS->min.x = val; 
#line 13000 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_set_x_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_set_x_max)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	BoundingBoxf *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::set_x_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 363 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     THIS->max.x = val; 
#line 13031 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_set_y_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_set_y_min)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	BoundingBoxf *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::set_y_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 368 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     THIS->min.y = val; 
#line 13062 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_set_y_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_set_y_max)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	BoundingBoxf *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::set_y_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 373 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     THIS->max.y = val; 
#line 13093 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_defined); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_defined)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf::defined() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 378 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->defined; 
#line 13124 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_new_from_points); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf_new_from_points)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, points");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	Pointfs	points;
	BoundingBoxf *	RETVAL;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        points.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &points[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Geometry::BoundingBoxf::new_from_points",
	             "points")
;
#line 388 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
        RETVAL = new BoundingBoxf(points);
#line 13158 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	BoundingBoxf3 *	RETVAL;
#line 403 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      RETVAL = new BoundingBoxf3();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 13194 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 420 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 13241 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	Clone<BoundingBoxf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 433 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS; 
#line 13271 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBoxf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_merge); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_merge)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, bb");
    {
	BoundingBoxf3 *	THIS;
	BoundingBoxf3*	bb;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::merge() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(bb) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(bb) )) {
              bb = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("bb is not of type %s (got %s)", Slic3r::perl_class_name(bb), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::merge() -- bb is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 439 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     THIS->merge(*bb); 
#line 13322 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_merge_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_merge_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	BoundingBoxf3 *	THIS;
	Pointf3*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::merge_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::merge_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 444 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     THIS->merge(*point); 
#line 13365 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	BoundingBoxf3 *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 449 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 13404 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_translate)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, x, y, z");
    {
	BoundingBoxf3 *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;
	double	z = (double)SvNV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 462 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      THIS->translate( x, y, z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 13447 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	Clone<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::size() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 475 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      RETVAL = THIS->size();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 13485 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_center); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_center)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	Clone<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::center() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 489 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
    try {
      RETVAL = THIS->center();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 13531 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_min_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_min_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	Clone<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::min_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 503 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->min; 
#line 13569 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_max_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_max_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	Clone<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::max_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 509 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->max; 
#line 13607 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_x_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_x_min)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::x_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 515 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->min.x; 
#line 13646 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_x_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_x_max)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::x_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 521 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->max.x; 
#line 13678 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_y_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_y_min)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::y_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 527 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->min.y; 
#line 13710 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_y_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_y_max)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::y_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 533 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->max.y; 
#line 13742 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_z_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_z_min)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::z_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 539 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->min.z; 
#line 13774 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_z_max); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_z_max)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::z_max() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 545 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->max.z; 
#line 13806 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_defined); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Geometry__BoundingBoxf3_defined)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BoundingBoxf3 *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Geometry::BoundingBoxf3::defined() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 551 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp\""
     RETVAL = THIS->defined; 
#line 13838 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/BoundingBox.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/GCodeTimeEstimator.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/GCodeTimeEstimator.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__GCode__TimeEstimator_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__TimeEstimator_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	GCodeTimeEstimator *	RETVAL;
#line 21 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeTimeEstimator.xsp\""
    try {
      RETVAL = new GCodeTimeEstimator();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 13879 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__GCode__TimeEstimator_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__TimeEstimator_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeTimeEstimator *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeTimeEstimator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::TimeEstimator::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeTimeEstimator.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 13926 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__TimeEstimator_time); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__TimeEstimator_time)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeTimeEstimator *	THIS;
	float	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeTimeEstimator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::TimeEstimator::time() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeTimeEstimator.xsp\""
    RETVAL = THIS->time;
#line 13957 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__TimeEstimator_parse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__TimeEstimator_parse)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, gcode");
    {
	GCodeTimeEstimator *	THIS;
	std::string	gcode;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeTimeEstimator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::TimeEstimator::parse() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      gcode = std::string(c, len);
    }
;
#line 57 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeTimeEstimator.xsp\""
    try {
      THIS->parse( gcode );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14003 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__TimeEstimator_parse_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__TimeEstimator_parse_file)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, file");
    {
	GCodeTimeEstimator *	THIS;
	std::string	file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeTimeEstimator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::TimeEstimator::parse_file() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      file = std::string(c, len);
    }
;
#line 70 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeTimeEstimator.xsp\""
    try {
      THIS->parse_file( file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14048 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/GCodeTimeEstimator.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Model.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/IO.hpp"
#include "libslic3r/Model.hpp"
#include "libslic3r/PrintConfig.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Model_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Model *	RETVAL;
#line 23 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = new Model();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14090 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Model_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 40 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14137 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Model_read_from_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_read_from_file)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, input_file");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Model *	RETVAL;
	std::string	input_file;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      input_file = std::string(c, len);
    }
;
#line 56 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
            try {
                RETVAL = new Model(Model::read_from_file(input_file));
            } catch (std::exception& e) {
                croak("Error while opening %s: %s\n", input_file.c_str(), e.what());
            }
#line 14169 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Model_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	Clone<Model>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 69 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS; 
#line 14209 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Model>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_read_stl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_read_stl)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, input_file");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;
	std::string	input_file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::read_stl() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      input_file = std::string(c, len);
    }
;
#line 75 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = Slic3r::IO::STL::read(input_file, THIS); 
#line 14256 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_read_obj); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_read_obj)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, input_file");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;
	std::string	input_file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::read_obj() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      input_file = std::string(c, len);
    }
;
#line 81 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = Slic3r::IO::OBJ::read(input_file, THIS); 
#line 14296 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_read_amf); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_read_amf)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, input_file");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;
	std::string	input_file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::read_amf() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      input_file = std::string(c, len);
    }
;
#line 87 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = Slic3r::IO::AMF::read(input_file, THIS); 
#line 14336 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_read_tmf); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_read_tmf)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, input_file");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;
	std::string	input_file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::read_tmf() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      input_file = std::string(c, len);
    }
;
#line 93 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = Slic3r::IO::TMF::read(input_file, THIS); 
#line 14376 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_write_stl); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_write_stl)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, output_file, binary= false");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;
	std::string	output_file;
	bool	binary;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::write_stl() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      output_file = std::string(c, len);
    }
;

	if (items < 3)
	    binary = false;
	else {
	    binary = (bool)SvUV(ST(2))
;
	}
#line 99 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = Slic3r::IO::STL::write(*THIS, output_file, binary); 
#line 14424 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_write_obj); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_write_obj)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, output_file");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;
	std::string	output_file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::write_obj() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      output_file = std::string(c, len);
    }
;
#line 105 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = Slic3r::IO::OBJ::write(*THIS, output_file); 
#line 14464 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_write_amf); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_write_amf)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, output_file");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;
	std::string	output_file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::write_amf() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      output_file = std::string(c, len);
    }
;
#line 111 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = Slic3r::IO::AMF::write(*THIS, output_file); 
#line 14504 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_write_tmf); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_write_tmf)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, output_file");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;
	std::string	output_file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::write_tmf() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      output_file = std::string(c, len);
    }
;
#line 117 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = Slic3r::IO::TMF::write(*THIS, output_file); 
#line 14544 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__add_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__add_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	Ref<ModelObject>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::_add_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 123 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->add_object();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14583 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelObject>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__add_object_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__add_object_clone)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, other, copy_volumes= true");
    {
	Model *	THIS;
	Ref<ModelObject>	RETVAL;
	ModelObject*	other;
	bool	copy_volumes;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::_add_object_clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (ModelObject *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::_add_object_clone() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    copy_volumes = true;
	else {
	    copy_volumes = (bool)SvUV(ST(2))
;
	}
#line 137 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->add_object(*other, copy_volumes); 
#line 14643 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelObject>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_delete_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_delete_object)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	Model *	THIS;
	size_t	idx = (size_t)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::delete_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 143 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->delete_object( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14690 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_clear_objects); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_clear_objects)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::clear_objects() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 156 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->clear_objects();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14727 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_objects_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_objects_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::objects_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 169 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->objects.size(); 
#line 14758 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_get_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_get_object)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	Model *	THIS;
	Ref<ModelObject>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::get_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 175 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->objects.at(idx); 
#line 14791 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelObject>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_get_material); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_get_material)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, material_id");
    {
	Model *	THIS;
	Ref<ModelMaterial>	RETVAL;
	t_model_material_id	material_id;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::get_material() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      material_id = std::string(c, len);
    }
;
#line 181 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
            RETVAL = THIS->get_material(material_id);
            if (RETVAL == NULL) {
                XSRETURN_UNDEF;
            }
#line 14840 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelMaterial>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_add_material); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_add_material)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, material_id");
    {
	Model *	THIS;
	Ref<ModelMaterial>	RETVAL;
	t_model_material_id	material_id;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::add_material() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      material_id = std::string(c, len);
    }
;
#line 190 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->add_material( material_id );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 14894 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelMaterial>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_add_material_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_add_material_clone)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, material_id, other");
    {
	Model *	THIS;
	Ref<ModelMaterial>	RETVAL;
	t_model_material_id	material_id;
	ModelMaterial*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::add_material_clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      material_id = std::string(c, len);
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(other) )) {
              other = (ModelMaterial *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::add_material_clone() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 204 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->add_material(material_id, *other); 
#line 14954 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelMaterial>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_has_material); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_has_material)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, material_id");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;
	t_model_material_id	material_id;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::has_material() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      material_id = std::string(c, len);
    }
;
#line 210 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
            RETVAL = (THIS->get_material(material_id) != NULL);
#line 15001 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_delete_material); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_delete_material)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, material_id");
    {
	Model *	THIS;
	t_model_material_id	material_id;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::delete_material() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      material_id = std::string(c, len);
    }
;
#line 216 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->delete_material( material_id );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15047 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_clear_materials); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_clear_materials)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::clear_materials() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 229 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->clear_materials();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15084 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_material_names); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_material_names)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	std::vector<std::string>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::material_names() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 242 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
            for (ModelMaterialMap::iterator i = THIS->materials.begin();
                i != THIS->materials.end(); ++i)
            {
                RETVAL.push_back(i->first);
            }
#line 15118 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      const std::string& str = RETVAL[i];
	      STRLEN len = str.length();
	      av_store(av, i, newSVpvn_utf8(str.c_str(), len, true));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_material_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_material_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::material_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 252 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->materials.size(); 
#line 15165 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_metadata_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_metadata_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::metadata_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 258 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->metadata.size(); 
#line 15197 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_has_objects_with_no_instances); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_has_objects_with_no_instances)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::has_objects_with_no_instances() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 264 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->has_objects_with_no_instances();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15237 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_add_default_instances); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_add_default_instances)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::add_default_instances() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 278 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->add_default_instances();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15277 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	Clone<BoundingBoxf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 292 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15316 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBoxf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_center_instances_around_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_center_instances_around_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Model *	THIS;
	Pointf*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::center_instances_around_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::center_instances_around_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 306 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->center_instances_around_point(*point); 
#line 15367 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_align_instances_to_origin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_align_instances_to_origin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::align_instances_to_origin() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 311 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->align_instances_to_origin();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15404 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_translate)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, x, y, z");
    {
	Model *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;
	double	z = (double)SvNV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 324 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->translate( x, y, z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15447 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_mesh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_mesh)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	Clone<TriangleMesh>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::mesh() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 337 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->mesh();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15485 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<TriangleMesh>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_raw_mesh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_raw_mesh)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	Clone<TriangleMesh>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::raw_mesh() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 351 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->raw_mesh();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15531 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<TriangleMesh>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_objects); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_objects)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	ModelObjectPtrs *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::objects() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 365 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = &THIS->objects; 
#line 15569 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
    RETVALSV = newRV_noinc((SV*)av);
    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL->size();
	    if (len > 0) av_extend(av, len-1);
    int i = 0;
    for (ModelObjectPtrs ::iterator it = RETVAL->begin(); it != RETVAL->end(); ++it) {
	    av_store(av, i++, perl_to_SV_ref(**it));
    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_arrange_objects); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_arrange_objects)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, dist, bb= NULL");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;
	double	dist = (double)SvNV(ST(1))
;
	BoundingBoxf*	bb;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::arrange_objects() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    bb = NULL;
	else {
    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
	if ( sv_isa(ST(2), Slic3r::perl_class_name(bb) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(bb) )) {
	      bb = (BoundingBoxf *)SvIV((SV*)SvRV( ST(2) ));
	} else {
	      croak("bb is not of type %s (got %s)", Slic3r::perl_class_name(bb), HvNAME(SvSTASH(SvRV(ST(2)))));
	      XSRETURN_UNDEF;
	}
    } else {
	warn( "Slic3r::Model::arrange_objects() -- bb is not a blessed SV reference" );
	XSRETURN_UNDEF;
    }
;
	}
#line 371 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->arrange_objects( dist, bb );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15642 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_duplicate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_duplicate)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "THIS, copies_num, dist, bb= NULL");
    {
	Model *	THIS;
	unsigned int	copies_num = (unsigned int)SvUV(ST(1))
;
	double	dist = (double)SvNV(ST(2))
;
	BoundingBoxf*	bb;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::duplicate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 4)
	    bb = NULL;
	else {
    if( sv_isobject(ST(3)) && (SvTYPE(SvRV(ST(3))) == SVt_PVMG) ) {
	if ( sv_isa(ST(3), Slic3r::perl_class_name(bb) ) ||  sv_isa(ST(3), Slic3r::perl_class_name_ref(bb) )) {
	      bb = (BoundingBoxf *)SvIV((SV*)SvRV( ST(3) ));
	} else {
	      croak("bb is not of type %s (got %s)", Slic3r::perl_class_name(bb), HvNAME(SvSTASH(SvRV(ST(3)))));
	      XSRETURN_UNDEF;
	}
    } else {
	warn( "Slic3r::Model::duplicate() -- bb is not a blessed SV reference" );
	XSRETURN_UNDEF;
    }
;
	}
#line 385 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->duplicate( copies_num, dist, bb );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15702 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_duplicate_objects); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_duplicate_objects)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "THIS, copies_num, dist, bb= NULL");
    {
	Model *	THIS;
	unsigned int	copies_num = (unsigned int)SvUV(ST(1))
;
	double	dist = (double)SvNV(ST(2))
;
	BoundingBoxf*	bb;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::duplicate_objects() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 4)
	    bb = NULL;
	else {
    if( sv_isobject(ST(3)) && (SvTYPE(SvRV(ST(3))) == SVt_PVMG) ) {
	if ( sv_isa(ST(3), Slic3r::perl_class_name(bb) ) ||  sv_isa(ST(3), Slic3r::perl_class_name_ref(bb) )) {
	      bb = (BoundingBoxf *)SvIV((SV*)SvRV( ST(3) ));
	} else {
	      croak("bb is not of type %s (got %s)", Slic3r::perl_class_name(bb), HvNAME(SvSTASH(SvRV(ST(3)))));
	      XSRETURN_UNDEF;
	}
    } else {
	warn( "Slic3r::Model::duplicate_objects() -- bb is not a blessed SV reference" );
	XSRETURN_UNDEF;
    }
;
	}
#line 398 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->duplicate_objects( copies_num, dist, bb );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15761 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_duplicate_objects_grid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_duplicate_objects_grid)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, x, y, dist");
    {
	Model *	THIS;
	unsigned int	x = (unsigned int)SvUV(ST(1))
;
	unsigned int	y = (unsigned int)SvUV(ST(2))
;
	double	dist = (double)SvNV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::duplicate_objects_grid() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 411 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->duplicate_objects_grid( x, y, dist );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15804 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_print_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_print_info)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::print_info() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 424 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->print_info();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15841 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_looks_like_multipart_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_looks_like_multipart_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::looks_like_multipart_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 437 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->looks_like_multipart_object();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15880 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model_convert_multipart_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_convert_multipart_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::convert_multipart_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 451 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->convert_multipart_object();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15918 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model_repair); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model_repair)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Model *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Model *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::repair() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 464 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->repair();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 15955 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Material_model); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Material_model)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelMaterial *	THIS;
	Ref<Model>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelMaterial *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Material::model() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 480 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->get_model(); 
#line 15985 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Model>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Material_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Material_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelMaterial *	THIS;
	Ref<DynamicPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelMaterial *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Material::config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 486 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = &THIS->config; 
#line 16023 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<DynamicPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Material_get_attribute); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Material_get_attribute)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, name");
    {
	ModelMaterial *	THIS;
	std::string	RETVAL;
	std::string	name;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelMaterial *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Material::get_attribute() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      name = std::string(c, len);
    }
;
#line 492 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     if (THIS->attributes.find(name) != THIS->attributes.end()) RETVAL = THIS->attributes[name]; 
#line 16069 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Material_set_attribute); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Material_set_attribute)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, name, value");
    {
	ModelMaterial *	THIS;
	std::string	name;
	std::string	value;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelMaterial *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Material::set_attribute() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      name = std::string(c, len);
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(2), len);
      value = std::string(c, len);
    }
;
#line 498 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->attributes[name] = value; 
#line 16120 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Material_attributes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Material_attributes)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelMaterial *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelMaterial *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Material::attributes() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 505 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
        HV* hv = newHV();
        for (t_model_material_attributes::const_iterator attr = THIS->attributes.begin(); attr != THIS->attributes.end(); ++attr) {
            (void)hv_store( hv, attr->first.c_str(), attr->first.length(), newSVpv(attr->second.c_str(), attr->second.length()), 0 );
        }
        RETVAL = (SV*)newRV_noinc((SV*)hv);
#line 16154 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_volumes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_volumes)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	ModelVolumePtrs *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::volumes() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 520 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = &THIS->volumes; 
#line 16186 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
    RETVALSV = newRV_noinc((SV*)av);
    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL->size();
	    if (len > 0) av_extend(av, len-1);
    int i = 0;
    for (ModelVolumePtrs ::iterator it = RETVAL->begin(); it != RETVAL->end(); ++it) {
	    av_store(av, i++, perl_to_SV_ref(**it));
    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_instances); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_instances)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	ModelInstancePtrs *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::instances() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 526 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = &THIS->instances; 
#line 16230 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
    RETVALSV = newRV_noinc((SV*)av);
    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL->size();
	    if (len > 0) av_extend(av, len-1);
    int i = 0;
    for (ModelInstancePtrs ::iterator it = RETVAL->begin(); it != RETVAL->end(); ++it) {
	    av_store(av, i++, perl_to_SV_ref(**it));
    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_invalidate_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_invalidate_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::invalidate_bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 532 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->invalidate_bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16281 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_update_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_update_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::update_bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 545 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->update_bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16318 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_mesh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_mesh)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	Clone<TriangleMesh>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::mesh() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 558 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->mesh();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16356 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<TriangleMesh>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_raw_mesh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_raw_mesh)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	Clone<TriangleMesh>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::raw_mesh() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 572 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->raw_mesh();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16402 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<TriangleMesh>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_raw_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_raw_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	Clone<BoundingBoxf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::raw_bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 586 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->raw_bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16448 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBoxf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_instance_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_instance_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	ModelObject *	THIS;
	Clone<BoundingBoxf3>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::instance_bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 600 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->instance_bounding_box( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16496 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBoxf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object__bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object__bounding_box)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "THIS, new_bbox= NULL");
    {
	ModelObject *	THIS;
	Ref<BoundingBoxf3>	RETVAL;
	BoundingBoxf3*	new_bbox;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::_bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 2)
	    new_bbox = NULL;
	else {
    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
	if ( sv_isa(ST(1), Slic3r::perl_class_name(new_bbox) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(new_bbox) )) {
	      new_bbox = (BoundingBoxf3 *)SvIV((SV*)SvRV( ST(1) ));
	} else {
	      croak("new_bbox is not of type %s (got %s)", Slic3r::perl_class_name(new_bbox), HvNAME(SvSTASH(SvRV(ST(1)))));
	      XSRETURN_UNDEF;
	}
    } else {
	warn( "Slic3r::Model::Object::_bounding_box() -- new_bbox is not a blessed SV reference" );
	XSRETURN_UNDEF;
    }
;
	}
#line 614 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
            if (NULL != new_bbox) {
                THIS->_bounding_box = *new_bbox;
                THIS->_bounding_box_valid = true;
            }
            if (!THIS->_bounding_box_valid) {
                XSRETURN_UNDEF;
            }
            RETVAL = &THIS->_bounding_box;
#line 16559 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<BoundingBoxf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	Clone<BoundingBoxf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 627 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16605 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBoxf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object__add_volume); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object__add_volume)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, mesh");
    {
	ModelObject *	THIS;
	Ref<ModelVolume>	RETVAL;
	TriangleMesh*	mesh;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::_add_volume() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(mesh) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(mesh) )) {
              mesh = (TriangleMesh *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("mesh is not of type %s (got %s)", Slic3r::perl_class_name(mesh), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::_add_volume() -- mesh is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 641 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->add_volume(*mesh); 
#line 16657 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelVolume>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object__add_volume_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object__add_volume_clone)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	ModelObject *	THIS;
	Ref<ModelVolume>	RETVAL;
	ModelVolume*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::_add_volume_clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (ModelVolume *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::_add_volume_clone() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 647 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->add_volume(*other); 
#line 16709 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelVolume>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_delete_volume); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_delete_volume)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	ModelObject *	THIS;
	size_t	idx = (size_t)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::delete_volume() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 653 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->delete_volume( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16756 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_clear_volumes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_clear_volumes)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::clear_volumes() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 666 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->clear_volumes();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16793 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_volumes_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_volumes_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::volumes_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 679 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->volumes.size(); 
#line 16824 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_get_volume); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_get_volume)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	ModelObject *	THIS;
	Ref<ModelVolume>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::get_volume() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 685 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->volumes.at(idx); 
#line 16857 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelVolume>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object__add_instance); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object__add_instance)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	Ref<ModelInstance>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::_add_instance() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 691 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->add_instance();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 16903 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelInstance>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object__add_instance_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object__add_instance_clone)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	ModelObject *	THIS;
	Ref<ModelInstance>	RETVAL;
	ModelInstance*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::_add_instance_clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (ModelInstance *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::_add_instance_clone() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 705 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->add_instance(*other); 
#line 16955 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelInstance>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_delete_last_instance); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_delete_last_instance)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::delete_last_instance() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 711 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->delete_last_instance();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 17000 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_clear_instances); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_clear_instances)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::clear_instances() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 724 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->clear_instances();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 17037 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_instances_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_instances_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::instances_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 737 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->instances.size(); 
#line 17068 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_get_instance); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_get_instance)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	ModelObject *	THIS;
	Ref<ModelInstance>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::get_instance() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 743 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->instances.at(idx); 
#line 17101 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelInstance>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::name() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 749 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->name; 
#line 17139 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_set_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_set_name)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	ModelObject *	THIS;
	std::string	value;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::set_name() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      value = std::string(c, len);
    }
;
#line 755 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->name = value; 
#line 17182 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_input_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_input_file)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::input_file() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 760 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->input_file; 
#line 17212 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_set_input_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_set_input_file)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	ModelObject *	THIS;
	std::string	value;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::set_input_file() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      value = std::string(c, len);
    }
;
#line 766 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->input_file = value; 
#line 17255 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	Ref<DynamicPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 771 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = &THIS->config; 
#line 17285 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<DynamicPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_part_number); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_part_number)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::part_number() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 777 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->part_number; 
#line 17324 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_model); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_model)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	Ref<Model>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::model() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 783 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->get_model(); 
#line 17355 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Model>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_layer_height_ranges); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_layer_height_ranges)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	t_layer_height_ranges	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::layer_height_ranges() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 789 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->layer_height_ranges; 
#line 17393 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
    RETVALSV = newRV_noinc((SV*)av);
    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
    // map is sorted, so we can just copy it in order
    int i = 0;
    for (t_layer_height_ranges::iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    const coordf_t range_values[] = {
		    it->first.first,    // key's first = minz
		    it->first.second,   // key's second = maxz
		    it->second,	 // value = height
		};
	    AV *rangeAV = newAV();
	    av_extend(rangeAV, 2);
	    for (int j = 0; j < 3; ++j) {
		av_store(rangeAV, j, newSVnv(range_values[j]));
	    }
	    av_store(av, i++, (SV*)newRV_noinc((SV*)rangeAV));
    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_set_layer_height_ranges); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_set_layer_height_ranges)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, ranges");
    {
	ModelObject *	THIS;
	t_layer_height_ranges	ranges;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::set_layer_height_ranges() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
        if (!SvROK(ST(1)) || SvTYPE(SvRV(ST(1))) != SVt_PVAV) {
            Perl_croak(aTHX_ "%s: %s is not an array reference",
                     "Slic3r::Model::Object::set_layer_height_ranges",
                     "ranges");
        }
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        t_layer_height_ranges tmp_ranges;
        for (unsigned int i = 0; i < len; i++) {
            SV* elem = *av_fetch(av, i, 0);
            if (!SvROK(elem) || SvTYPE(SvRV(elem)) != SVt_PVAV) {
                Perl_croak(
                    aTHX_ "%s: %s contains something that is not an array reference",
                        "Slic3r::Model::Object::set_layer_height_ranges",
                        "ranges");
            }
            AV* elemAV = (AV*)SvRV(elem);
            if (av_len(elemAV) + 1 != 3) {
                Perl_croak(
                    aTHX_ "%s: %s contains an array that isn't 3 elements long",
                        "Slic3r::Model::Object::set_layer_height_ranges",
                        "ranges");
            }
            coordf_t vals[3];
            for (unsigned int j = 0; j < 3; ++j) {
                SV *elem_elem = *av_fetch(elemAV, j, 0);
                if (!looks_like_number(elem_elem)) {
                    Perl_croak(
                        aTHX_ "%s: layer ranges and heights must be numbers",
                            "Slic3r::Model::Object::set_layer_height_ranges");
                }
                vals[j] = SvNV(elem_elem);
            }
            tmp_ranges[t_layer_height_range(vals[0], vals[1])] = vals[2];
        }
        ranges = tmp_ranges;
    }
;
#line 795 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->layer_height_ranges = ranges; 
#line 17488 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_layer_height_spline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_layer_height_spline)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	Ref<LayerHeightSpline>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::layer_height_spline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 800 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = &THIS->layer_height_spline; 
#line 17518 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<LayerHeightSpline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_set_layer_height_spline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_set_layer_height_spline)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, spline");
    {
	ModelObject *	THIS;
	LayerHeightSpline*	spline;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::set_layer_height_spline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(spline) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(spline) )) {
              spline = (LayerHeightSpline *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("spline is not of type %s (got %s)", Slic3r::perl_class_name(spline), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::set_layer_height_spline() -- spline is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 806 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->layer_height_spline = *spline; 
#line 17569 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_origin_translation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_origin_translation)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	Ref<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::origin_translation() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 811 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = &THIS->origin_translation; 
#line 17599 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_set_origin_translation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_set_origin_translation)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	ModelObject *	THIS;
	Pointf3*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::set_origin_translation() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::set_origin_translation() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 817 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->origin_translation = *point; 
#line 17650 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_needed_repair); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_needed_repair)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::needed_repair() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 822 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->needed_repair();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 17689 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_materials_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_materials_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::materials_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 836 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->materials_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 17729 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_facets_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_facets_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::facets_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 850 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->facets_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 17769 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_align_to_ground); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_align_to_ground)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::align_to_ground() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 864 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->align_to_ground();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 17807 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_center_around_origin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_center_around_origin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::center_around_origin() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 877 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->center_around_origin();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 17844 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_translate)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, x, y, z");
    {
	ModelObject *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;
	double	z = (double)SvNV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 890 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->translate( x, y, z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 17887 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_scale_xyz); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_scale_xyz)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, versor");
    {
	ModelObject *	THIS;
	Pointf3*	versor;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::scale_xyz() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(versor) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(versor) )) {
              versor = (Pointf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("versor is not of type %s (got %s)", Slic3r::perl_class_name(versor), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::scale_xyz() -- versor is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 903 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->scale(*versor); 
#line 17930 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_rotate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, angle, axis");
    {
	ModelObject *	THIS;
	float	angle = (float)SvNV(ST(1))
;
	Axis	axis = (Axis)SvUV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::rotate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 908 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
    axis = (Axis)SvUV(ST(2));
  ;
      THIS->rotate( angle, axis );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 17973 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_mirror); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_mirror)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, axis");
    {
	ModelObject *	THIS;
	Axis	axis = (Axis)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::mirror() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 923 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
    axis = (Axis)SvUV(ST(1));
  ;
      THIS->mirror( axis );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 18014 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_transform_by_instance); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_transform_by_instance)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, instance, dont_translate= false");
    {
	ModelObject *	THIS;
	ModelInstance*	instance;
	bool	dont_translate;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::transform_by_instance() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(instance) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(instance) )) {
              instance = (ModelInstance *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("instance is not of type %s (got %s)", Slic3r::perl_class_name(instance), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::transform_by_instance() -- instance is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    dont_translate = false;
	else {
	    dont_translate = (bool)SvUV(ST(2))
;
	}
#line 938 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->transform_by_instance(*instance, dont_translate); 
#line 18065 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_cut); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_cut)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, axis, z");
    {
	ModelObject *	THIS;
	Model *	RETVAL;
	Axis	axis = (Axis)SvUV(ST(1))
;
	double	z = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::cut() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 943 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
            RETVAL = new Model();
            THIS->cut(axis, z, RETVAL);
#line 18100 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_split_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_split_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;
	ModelObjectPtrs *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::split_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 950 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
            RETVAL = new ModelObjectPtrs();  // leak?
            THIS->split(RETVAL);
#line 18139 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
    RETVALSV = newRV_noinc((SV*)av);
    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL->size();
	    if (len > 0) av_extend(av, len-1);
    int i = 0;
    for (ModelObjectPtrs ::iterator it = RETVAL->begin(); it != RETVAL->end(); ++it) {
	    av_store(av, i++, perl_to_SV_ref(**it));
    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Object_print_info); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_print_info)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::print_info() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 957 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->print_info();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 18190 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Object_repair); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Object_repair)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Object::repair() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 970 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->repair();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 18227 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Volume_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	Ref<ModelObject>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 986 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->get_object(); 
#line 18257 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelObject>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::name() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 992 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->name; 
#line 18295 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_set_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_set_name)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	ModelVolume *	THIS;
	std::string	value;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::set_name() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      value = std::string(c, len);
    }
;
#line 998 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->name = value; 
#line 18338 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Volume_input_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_input_file)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::input_file() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1003 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->input_file; 
#line 18368 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_set_input_file); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_set_input_file)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	ModelVolume *	THIS;
	std::string	value;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::set_input_file() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      value = std::string(c, len);
    }
;
#line 1009 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->input_file = value; 
#line 18411 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Volume_input_file_obj_idx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_input_file_obj_idx)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::input_file_obj_idx() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1014 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->input_file_obj_idx; 
#line 18442 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_set_input_file_obj_idx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_set_input_file_obj_idx)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, obj_idx");
    {
	ModelVolume *	THIS;
	int	obj_idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::set_input_file_obj_idx() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1020 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->input_file_obj_idx = obj_idx; 
#line 18474 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Volume_input_file_vol_idx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_input_file_vol_idx)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::input_file_vol_idx() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1025 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->input_file_vol_idx; 
#line 18505 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_set_input_file_vol_idx); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_set_input_file_vol_idx)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, vol_idx");
    {
	ModelVolume *	THIS;
	int	vol_idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::set_input_file_vol_idx() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1031 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->input_file_vol_idx = vol_idx; 
#line 18537 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Volume_material_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_material_id)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	t_model_material_id	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::material_id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1036 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->material_id();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 18575 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_set_material_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_set_material_id)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, material_id");
    {
	ModelVolume *	THIS;
	t_model_material_id	material_id;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::set_material_id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      material_id = std::string(c, len);
    }
;
#line 1050 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->material_id(material_id); 
#line 18618 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Volume_material); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_material)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	Ref<ModelMaterial>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::material() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1055 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->material();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 18656 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelMaterial>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	Clone<BoundingBoxf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1069 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
            try {
                RETVAL = THIS->mesh.bounding_box();
            } catch (std::exception& e) {
                croak("%s", e.what());
            }
#line 18698 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBoxf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	Ref<DynamicPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1079 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = &THIS->config; 
#line 18736 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<DynamicPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_mesh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_mesh)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	Ref<TriangleMesh>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::mesh() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1085 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = &THIS->mesh; 
#line 18774 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<TriangleMesh>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_modifier); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_modifier)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::modifier() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1091 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->modifier; 
#line 18813 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_set_modifier); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_set_modifier)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, modifier");
    {
	ModelVolume *	THIS;
	bool	modifier = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::set_modifier() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1097 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->modifier = modifier; 
#line 18845 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Volume_assign_unique_material); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_assign_unique_material)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelVolume *	THIS;
	ModelMaterial *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::assign_unique_material() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1102 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      RETVAL = THIS->assign_unique_material();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 18883 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Volume_extrude_tin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Volume_extrude_tin)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, offset");
    {
	ModelVolume *	THIS;
	float	offset = (float)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelVolume *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Volume::extrude_tin() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1116 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
            try {
                THIS->mesh.extrude_tin(offset);
            } catch (std::exception& e) {
                croak("%s", e.what());
            }
#line 18926 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Instance_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelInstance *	THIS;
	Ref<ModelObject>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1128 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->get_object(); 
#line 18956 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelObject>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Instance_rotation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_rotation)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelInstance *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::rotation() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1134 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->rotation; 
#line 18995 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Instance_x_rotation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_x_rotation)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelInstance *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::x_rotation() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1140 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->x_rotation; 
#line 19027 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Instance_y_rotation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_y_rotation)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelInstance *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::y_rotation() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1146 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->y_rotation; 
#line 19059 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Instance_scaling_factor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_scaling_factor)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelInstance *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::scaling_factor() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1152 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->scaling_factor; 
#line 19091 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Instance_scaling_vector); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_scaling_vector)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelInstance *	THIS;
	Ref<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::scaling_vector() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1158 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = &THIS->scaling_vector; 
#line 19122 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Instance_offset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_offset)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelInstance *	THIS;
	Ref<Pointf>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::offset() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1164 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = &THIS->offset; 
#line 19160 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Instance_z_translation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_z_translation)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ModelInstance *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::z_translation() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1170 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     RETVAL = THIS->z_translation; 
#line 19199 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Model__Instance_set_rotation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_set_rotation)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	ModelInstance *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::set_rotation() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1176 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->rotation = val; 
#line 19231 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Instance_set_x_rotation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_set_x_rotation)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	ModelInstance *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::set_x_rotation() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1181 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->x_rotation = val; 
#line 19262 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Instance_set_y_rotation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_set_y_rotation)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	ModelInstance *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::set_y_rotation() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1186 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->y_rotation = val; 
#line 19293 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Instance_set_scaling_factor); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_set_scaling_factor)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	ModelInstance *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::set_scaling_factor() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1191 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->scaling_factor = val; 
#line 19324 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Instance_set_scaling_vector); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_set_scaling_vector)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, vec");
    {
	ModelInstance *	THIS;
	Pointf3*	vec;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::set_scaling_vector() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(vec) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(vec) )) {
              vec = (Pointf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("vec is not of type %s (got %s)", Slic3r::perl_class_name(vec), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::set_scaling_vector() -- vec is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1196 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->scaling_vector = *vec; 
#line 19367 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Instance_set_offset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_set_offset)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, offset");
    {
	ModelInstance *	THIS;
	Pointf*	offset;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::set_offset() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(offset) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(offset) )) {
              offset = (Pointf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("offset is not of type %s (got %s)", Slic3r::perl_class_name(offset), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::set_offset() -- offset is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1201 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->offset = *offset; 
#line 19410 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Instance_set_z_translation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_set_z_translation)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	ModelInstance *	THIS;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::set_z_translation() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1206 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
     THIS->z_translation = val; 
#line 19441 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Instance_transform_mesh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_transform_mesh)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, mesh, dont_translate= false");
    {
	ModelInstance *	THIS;
	TriangleMesh*	mesh;
	bool	dont_translate;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::transform_mesh() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(mesh) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(mesh) )) {
              mesh = (TriangleMesh *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("mesh is not of type %s (got %s)", Slic3r::perl_class_name(mesh), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::transform_mesh() -- mesh is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    dont_translate = false;
	else {
	    dont_translate = (bool)SvUV(ST(2))
;
	}
#line 1211 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->transform_mesh( mesh, dont_translate );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19500 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Model__Instance_transform_polygon); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Model__Instance_transform_polygon)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, polygon");
    {
	ModelInstance *	THIS;
	Polygon*	polygon;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ModelInstance *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::transform_polygon() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(polygon) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(polygon) )) {
              polygon = (Polygon *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("polygon is not of type %s (got %s)", Slic3r::perl_class_name(polygon), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Model::Instance::transform_polygon() -- polygon is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1224 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Model.xsp\""
    try {
      THIS->transform_polygon( polygon );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19551 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Model.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Config.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/PrintConfig.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Config_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	DynamicPrintConfig *	RETVAL;
#line 21 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      RETVAL = new DynamicPrintConfig();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19591 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Config_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	DynamicPrintConfig *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19638 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config_has); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_has)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, opt_key");
    {
	DynamicPrintConfig *	THIS;
	bool	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::has() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 51 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      RETVAL = THIS->has( opt_key );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19685 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_as_hash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_as_hash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	DynamicPrintConfig *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::as_hash() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 65 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = ConfigBase__as_hash(THIS); 
#line 19716 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_get)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, opt_key");
    {
	DynamicPrintConfig *	THIS;
	SV *	RETVAL;
	t_config_option_key	opt_key;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::get() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 71 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = ConfigBase__get(THIS, opt_key); 
#line 19756 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_get_at); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_get_at)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, opt_key, i");
    {
	DynamicPrintConfig *	THIS;
	SV *	RETVAL;
	t_config_option_key	opt_key;
	int	i = (int)SvIV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::get_at() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 77 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = ConfigBase__get_at(THIS, opt_key, i); 
#line 19798 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_set)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, opt_key, value");
    {
	DynamicPrintConfig *	THIS;
	bool	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;
	SV*	value = ST(2)
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::set() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 83 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = ConfigBase__set(THIS, opt_key, value); 
#line 19841 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_set_deserialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_set_deserialize)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, opt_key, str");
    {
	DynamicPrintConfig *	THIS;
	bool	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;
	SV*	str = ST(2)
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::set_deserialize() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 89 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = ConfigBase__set_deserialize(THIS, opt_key, str); 
#line 19883 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_set_ifndef); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_set_ifndef)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "THIS, opt_key, value, deserialize= false");
    {
	DynamicPrintConfig *	THIS;
	t_config_option_key	opt_key;
	SV*	value = ST(2)
;
	bool	deserialize;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::set_ifndef() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;

	if (items < 4)
	    deserialize = false;
	else {
	    deserialize = (bool)SvUV(ST(3))
;
	}
#line 95 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     ConfigBase__set_ifndef(THIS, opt_key, value, deserialize); 
#line 19931 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config_serialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_serialize)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, opt_key");
    {
	DynamicPrintConfig *	THIS;
	std::string	RETVAL;
	t_config_option_key	opt_key;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::serialize() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 100 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      RETVAL = THIS->serialize( opt_key );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 19977 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_get_abs_value); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_get_abs_value)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, opt_key");
    {
	DynamicPrintConfig *	THIS;
	double	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::get_abs_value() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 114 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      RETVAL = THIS->get_abs_value( opt_key );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20030 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_get_abs_value_over); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_get_abs_value_over)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, opt_key, ratio_over");
    {
	DynamicPrintConfig *	THIS;
	double	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;
	double	ratio_over = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::get_abs_value_over() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 128 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      RETVAL = THIS->get_abs_value( opt_key, ratio_over );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20080 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_apply); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_apply)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	DynamicPrintConfig *	THIS;
	DynamicPrintConfig*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::apply() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::apply() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 142 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     THIS->apply(*other, true); 
#line 20124 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config_apply_only); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_apply_only)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, other, opt_keys");
    {
	DynamicPrintConfig *	THIS;
	DynamicPrintConfig*	other;
	std::vector< std::string >	opt_keys;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::apply_only() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::apply_only() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (SvROK(ST(2)) && SvTYPE(SvRV(ST(2)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(2));
	  const unsigned int alen = av_len(av)+1;
	  opt_keys = std::vector<std::string>(alen);
	  STRLEN len;
	  char* tmp;
	  SV** elem;
	  for (unsigned int i = 0; i < alen; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL) {
	    tmp = SvPVutf8(*elem, len);
	      opt_keys[i] = std::string(tmp, len);
	    }
	    else
	      opt_keys[i] = std::string("");
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Config::apply_only",
	             "opt_keys")
;
#line 147 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     THIS->apply_only(*other, opt_keys, true, false); 
#line 20191 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config_diff); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_diff)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	DynamicPrintConfig *	THIS;
	std::vector<std::string>	RETVAL;
	DynamicPrintConfig*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::diff() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::diff() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 152 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = THIS->diff(*other); 
#line 20235 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      const std::string& str = RETVAL[i];
	      STRLEN len = str.length();
	      av_store(av, i, newSVpvn_utf8(str.c_str(), len, true));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_diff_static); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_diff_static)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	DynamicPrintConfig *	THIS;
	std::vector<std::string>	RETVAL;
	StaticPrintConfig*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::diff_static() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::diff_static() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 158 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = THIS->diff(*other); 
#line 20295 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      const std::string& str = RETVAL[i];
	      STRLEN len = str.length();
	      av_store(av, i, newSVpvn_utf8(str.c_str(), len, true));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_equals); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_equals)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	DynamicPrintConfig *	THIS;
	bool	RETVAL;
	dXSTARG;
	DynamicPrintConfig*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::equals() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::equals() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 164 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = THIS->equals(*other); 
#line 20356 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_apply_static); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_apply_static)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	DynamicPrintConfig *	THIS;
	StaticPrintConfig*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::apply_static() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::apply_static() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 170 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     THIS->apply(*other, true); 
#line 20400 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config_get_keys); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_get_keys)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	DynamicPrintConfig *	THIS;
	std::vector<std::string>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::get_keys() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 175 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      RETVAL = THIS->keys();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20438 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      const std::string& str = RETVAL[i];
	      STRLEN len = str.length();
	      av_store(av, i, newSVpvn_utf8(str.c_str(), len, true));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_erase); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_erase)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, opt_key");
    {
	DynamicPrintConfig *	THIS;
	t_config_option_key	opt_key;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::erase() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 189 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      THIS->erase( opt_key );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20499 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config_clear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_clear)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	DynamicPrintConfig *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::clear() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 202 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      THIS->clear();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20536 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config_empty); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_empty)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	DynamicPrintConfig *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::empty() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 215 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      RETVAL = THIS->empty();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20575 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_normalize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_normalize)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	DynamicPrintConfig *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::normalize() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 229 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      THIS->normalize();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20613 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config_setenv); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_setenv)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	DynamicPrintConfig *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::setenv() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 242 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      THIS->setenv_();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20650 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config_min_object_distance); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_min_object_distance)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	DynamicPrintConfig *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::min_object_distance() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 255 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      RETVAL = THIS->min_object_distance();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20689 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__load); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__load)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, file");
    {
	DynamicPrintConfig *	THIS;
	std::string	file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::_load() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      file = std::string(c, len);
    }
;
#line 269 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      THIS->load( file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20735 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config__save); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__save)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, file");
    {
	DynamicPrintConfig *	THIS;
	std::string	file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::_save() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      file = std::string(c, len);
    }
;
#line 282 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      THIS->save( file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 20780 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config_read_cli); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_read_cli)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, _argv");
    {
	DynamicPrintConfig *	THIS;
	std::vector<std::string>	RETVAL;
	std::vector< std::string >	_argv;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::read_cli() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(1));
	  const unsigned int alen = av_len(av)+1;
	  _argv = std::vector<std::string>(alen);
	  STRLEN len;
	  char* tmp;
	  SV** elem;
	  for (unsigned int i = 0; i < alen; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL) {
	    tmp = SvPVutf8(*elem, len);
	      _argv[i] = std::string(tmp, len);
	    }
	    else
	      _argv[i] = std::string("");
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Config::read_cli",
	             "_argv")
;
#line 295 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     THIS->read_cli(_argv, &RETVAL); 
#line 20834 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      const std::string& str = RETVAL[i];
	      STRLEN len = str.length();
	      av_store(av, i, newSVpvn_utf8(str.c_str(), len, true));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_new_GCodeConfig); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_new_GCodeConfig)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	StaticPrintConfig *	RETVAL;
#line 304 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = new GCodeConfig (); 
#line 20866 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_new_PrintConfig); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_new_PrintConfig)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	StaticPrintConfig *	RETVAL;
#line 310 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = new PrintConfig (); 
#line 20890 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_new_PrintObjectConfig); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_new_PrintObjectConfig)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	StaticPrintConfig *	RETVAL;
#line 316 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = new PrintObjectConfig (); 
#line 20914 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_new_PrintRegionConfig); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_new_PrintRegionConfig)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	StaticPrintConfig *	RETVAL;
#line 322 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = new PrintRegionConfig (); 
#line 20938 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_new_FullPrintConfig); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_new_FullPrintConfig)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	StaticPrintConfig *	RETVAL;
#line 328 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = new FullPrintConfig (); 
#line 20962 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_new_SLAPrintConfig); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_new_SLAPrintConfig)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	StaticPrintConfig *	RETVAL;
#line 334 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = new SLAPrintConfig (); 
#line 20986 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	StaticPrintConfig *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 340 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21031 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config__Static_has); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_has)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, opt_key");
    {
	StaticPrintConfig *	THIS;
	bool	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::has() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 353 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      RETVAL = THIS->has( opt_key );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21078 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_as_hash); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_as_hash)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	StaticPrintConfig *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::as_hash() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 367 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = ConfigBase__as_hash(THIS); 
#line 21109 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_get); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_get)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, opt_key");
    {
	StaticPrintConfig *	THIS;
	SV *	RETVAL;
	t_config_option_key	opt_key;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::get() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 373 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = ConfigBase__get(THIS, opt_key); 
#line 21149 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_get_at); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_get_at)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, opt_key, i");
    {
	StaticPrintConfig *	THIS;
	SV *	RETVAL;
	t_config_option_key	opt_key;
	int	i = (int)SvIV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::get_at() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 379 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = ConfigBase__get_at(THIS, opt_key, i); 
#line 21191 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_set)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, opt_key, value");
    {
	StaticPrintConfig *	THIS;
	bool	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;
	SV*	value = ST(2)
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::set() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 385 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = StaticConfig__set(THIS, opt_key, value); 
#line 21234 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_set_deserialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_set_deserialize)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, opt_key, str");
    {
	StaticPrintConfig *	THIS;
	bool	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;
	SV*	str = ST(2)
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::set_deserialize() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 391 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = ConfigBase__set_deserialize(THIS, opt_key, str); 
#line 21276 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_set_ifndef); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_set_ifndef)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "THIS, opt_key, value, deserialize= false");
    {
	StaticPrintConfig *	THIS;
	t_config_option_key	opt_key;
	SV*	value = ST(2)
;
	bool	deserialize;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::set_ifndef() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;

	if (items < 4)
	    deserialize = false;
	else {
	    deserialize = (bool)SvUV(ST(3))
;
	}
#line 397 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     ConfigBase__set_ifndef(THIS, opt_key, value, deserialize); 
#line 21324 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config__Static_serialize); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_serialize)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, opt_key");
    {
	StaticPrintConfig *	THIS;
	std::string	RETVAL;
	t_config_option_key	opt_key;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::serialize() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 402 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      RETVAL = THIS->serialize( opt_key );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21370 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_get_abs_value); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_get_abs_value)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, opt_key");
    {
	StaticPrintConfig *	THIS;
	double	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::get_abs_value() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 416 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      RETVAL = THIS->get_abs_value( opt_key );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21423 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_get_abs_value_over); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_get_abs_value_over)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, opt_key, ratio_over");
    {
	StaticPrintConfig *	THIS;
	double	RETVAL;
	dXSTARG;
	t_config_option_key	opt_key;
	double	ratio_over = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::get_abs_value_over() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      opt_key = std::string(c, len);
    }
;
#line 430 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      RETVAL = THIS->get_abs_value( opt_key, ratio_over );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21473 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_apply_static); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_apply_static)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	StaticPrintConfig *	THIS;
	StaticPrintConfig*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::apply_static() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::apply_static() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 444 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     THIS->apply(*other, true); 
#line 21517 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config__Static_apply_dynamic); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_apply_dynamic)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	StaticPrintConfig *	THIS;
	DynamicPrintConfig*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::apply_dynamic() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::apply_dynamic() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 449 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     THIS->apply(*other, true); 
#line 21560 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config__Static_get_keys); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_get_keys)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	StaticPrintConfig *	THIS;
	std::vector<std::string>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::get_keys() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 454 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      RETVAL = THIS->keys();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21598 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      const std::string& str = RETVAL[i];
	      STRLEN len = str.length();
	      av_store(av, i, newSVpvn_utf8(str.c_str(), len, true));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_get_extrusion_axis); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_get_extrusion_axis)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	StaticPrintConfig *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::get_extrusion_axis() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 468 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
            if (GCodeConfig* config = dynamic_cast<GCodeConfig*>(THIS)) {
                RETVAL = config->get_extrusion_axis();
            } else {
                CONFESS("This StaticConfig object does not provide get_extrusion_axis()");
            }
#line 21648 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static_setenv); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_setenv)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	StaticPrintConfig *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::setenv() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 478 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      THIS->setenv_();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21691 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config__Static_min_object_distance); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_min_object_distance)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	StaticPrintConfig *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::min_object_distance() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 491 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      RETVAL = THIS->min_object_distance();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21730 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config__Static__load); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static__load)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, file");
    {
	StaticPrintConfig *	THIS;
	std::string	file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::_load() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      file = std::string(c, len);
    }
;
#line 505 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      THIS->load( file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21776 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config__Static__save); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static__save)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, file");
    {
	StaticPrintConfig *	THIS;
	std::string	file;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::_save() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      file = std::string(c, len);
    }
;
#line 518 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
    try {
      THIS->save( file );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 21821 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Config__Static_dynamic); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config__Static_dynamic)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	StaticPrintConfig *	THIS;
	DynamicPrintConfig *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Config::Static::dynamic() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 531 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
     RETVAL = new DynamicPrintConfig (); RETVAL->apply(*THIS, true); 
#line 21851 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Config_print_config_def); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Config_print_config_def)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;
#line 543 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Config.xsp\""
        HV* options_hv = newHV();
        for (const auto &oit : Slic3r::print_config_def.options) {
            HV* hv = newHV();

            const t_config_option_key &opt_key = oit.first;
            const ConfigOptionDef &optdef      = oit.second;

            const char* opt_type;
            if (optdef.type == coFloat || optdef.type == coFloats || optdef.type == coFloatOrPercent) {
                opt_type = "f";
            } else if (optdef.type == coPercent) {
                opt_type = "percent";
            } else if (optdef.type == coInt || optdef.type == coInts) {
                opt_type = "i";
            } else if (optdef.type == coString) {
                opt_type = "s";
            } else if (optdef.type == coStrings) {
                opt_type = "s@";
            } else if (optdef.type == coPoint || optdef.type == coPoints) {
                opt_type = "point";
            } else if (optdef.type == coPoint3 ){
                opt_type = "point3";
            } else if (optdef.type == coBool || optdef.type == coBools) {
                opt_type = "bool";
            } else if (optdef.type == coEnum) {
                opt_type = "select";
            } else {
                throw "Unknown option type";
            }
            (void)hv_stores( hv, "type",        newSVpv(opt_type, 0) );
            (void)hv_stores( hv, "gui_type",    newSVpvn(optdef.gui_type.c_str(), optdef.gui_type.length()) );
            (void)hv_stores( hv, "gui_flags",   newSVpvn(optdef.gui_flags.c_str(), optdef.gui_flags.length()) );
            (void)hv_stores( hv, "label",       newSVpvn_utf8(optdef.label.c_str(), optdef.label.length(), true) );
            if (!optdef.full_label.empty())
                (void)hv_stores( hv, "full_label",  newSVpvn_utf8(optdef.full_label.c_str(), optdef.full_label.length(), true) );
            (void)hv_stores( hv, "category",    newSVpvn_utf8(optdef.category.c_str(), optdef.category.length(), true) );
            (void)hv_stores( hv, "tooltip",     newSVpvn_utf8(optdef.tooltip.c_str(), optdef.tooltip.length(), true) );
            (void)hv_stores( hv, "sidetext",    newSVpvn_utf8(optdef.sidetext.c_str(), optdef.sidetext.length(), true) );
            (void)hv_stores( hv, "cli",         newSVpvn(optdef.cli.c_str(), optdef.cli.length()) );
            (void)hv_stores( hv, "ratio_over",  newSVpvn(optdef.ratio_over.c_str(), optdef.ratio_over.length()) );
            (void)hv_stores( hv, "multiline",   newSViv(optdef.multiline ? 1 : 0) );
            (void)hv_stores( hv, "full_width",  newSViv(optdef.full_width ? 1 : 0) );
            (void)hv_stores( hv, "readonly",    newSViv(optdef.readonly ? 1 : 0) );
            (void)hv_stores( hv, "height",      newSViv(optdef.height) );
            (void)hv_stores( hv, "width",       newSViv(optdef.width) );
            (void)hv_stores( hv, "min",         newSViv(optdef.min) );
            (void)hv_stores( hv, "max",         newSViv(optdef.max) );

            // aliases
            if (!optdef.aliases.empty()) {
                AV* av = newAV();
                av_fill(av, optdef.aliases.size()-1);
                for (std::vector<t_config_option_key>::const_iterator it = optdef.aliases.begin(); it != optdef.aliases.end(); ++it)
                    av_store(av, it - optdef.aliases.begin(), newSVpvn(it->c_str(), it->length()));
                (void)hv_stores( hv, "aliases", newRV_noinc((SV*)av) );
            }

            // shortcut
            if (!optdef.shortcut.empty()) {
                AV* av = newAV();
                av_fill(av, optdef.shortcut.size()-1);
                for (std::vector<t_config_option_key>::const_iterator it = optdef.shortcut.begin(); it != optdef.shortcut.end(); ++it)
                    av_store(av, it - optdef.shortcut.begin(), newSVpvn(it->c_str(), it->length()));
                (void)hv_stores( hv, "shortcut", newRV_noinc((SV*)av) );
            }

            // enum_values
            if (!optdef.enum_values.empty()) {
                AV* av = newAV();
                av_fill(av, optdef.enum_values.size()-1);
                for (std::vector<std::string>::const_iterator it = optdef.enum_values.begin(); it != optdef.enum_values.end(); ++it)
                    av_store(av, it - optdef.enum_values.begin(), newSVpvn(it->c_str(), it->length()));
                (void)hv_stores( hv, "values", newRV_noinc((SV*)av) );
            }

            // enum_labels
            if (!optdef.enum_labels.empty()) {
                AV* av = newAV();
                av_fill(av, optdef.enum_labels.size()-1);
                for (std::vector<std::string>::const_iterator it = optdef.enum_labels.begin(); it != optdef.enum_labels.end(); ++it)
                    av_store(av, it - optdef.enum_labels.begin(), newSVpvn_utf8(it->c_str(), it->length(), true));
                (void)hv_stores( hv, "labels", newRV_noinc((SV*)av) );
            }

            if (optdef.default_value != NULL)
                (void)hv_stores( hv, "default", ConfigOption_to_SV(*optdef.default_value, optdef) );
            (void)hv_store( options_hv, opt_key.c_str(), opt_key.length(), newRV_noinc((SV*)hv), 0 );
        }

        RETVAL = newRV_noinc((SV*)options_hv);
#line 21964 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Config.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/LayerHeightSpline.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/LayerHeightSpline.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__LayerHeightSpline_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__LayerHeightSpline_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	LayerHeightSpline *	RETVAL;
#line 21 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/LayerHeightSpline.xsp\""
    try {
      RETVAL = new LayerHeightSpline();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22006 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__LayerHeightSpline_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__LayerHeightSpline_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerHeightSpline *	THIS;
	Clone<LayerHeightSpline>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerHeightSpline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::LayerHeightSpline::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/LayerHeightSpline.xsp\""
     RETVAL = THIS; 
#line 22046 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<LayerHeightSpline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__LayerHeightSpline_setObjectHeight); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__LayerHeightSpline_setObjectHeight)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, object_height");
    {
	LayerHeightSpline *	THIS;
	coordf_t	object_height = (coordf_t)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerHeightSpline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::LayerHeightSpline::setObjectHeight() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 44 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/LayerHeightSpline.xsp\""
    try {
      THIS->setObjectHeight( object_height );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22093 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__LayerHeightSpline_hasData); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__LayerHeightSpline_hasData)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerHeightSpline *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerHeightSpline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::LayerHeightSpline::hasData() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 57 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/LayerHeightSpline.xsp\""
    try {
      RETVAL = THIS->hasData();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22132 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__LayerHeightSpline_setLayers); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__LayerHeightSpline_setLayers)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, layers");
    {
	LayerHeightSpline *	THIS;
	bool	RETVAL;
	dXSTARG;
	std::vector< double >	layers;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerHeightSpline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::LayerHeightSpline::setLayers() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(1));
	  const unsigned int len = av_len(av)+1;
	  layers = std::vector<double>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      layers[i] = SvNV(*elem);
	    else
	      layers[i] = 0.;
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::LayerHeightSpline::setLayers",
	             "layers")
;
#line 71 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/LayerHeightSpline.xsp\""
     RETVAL = THIS->setLayers(layers); 
#line 22184 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__LayerHeightSpline_updateLayerHeights); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__LayerHeightSpline_updateLayerHeights)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, heights");
    {
	LayerHeightSpline *	THIS;
	bool	RETVAL;
	dXSTARG;
	std::vector< double >	heights;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerHeightSpline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::LayerHeightSpline::updateLayerHeights() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(1));
	  const unsigned int len = av_len(av)+1;
	  heights = std::vector<double>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      heights[i] = SvNV(*elem);
	    else
	      heights[i] = 0.;
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::LayerHeightSpline::updateLayerHeights",
	             "heights")
;
#line 77 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/LayerHeightSpline.xsp\""
     RETVAL = THIS->updateLayerHeights(heights); 
#line 22236 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__LayerHeightSpline_layersUpdated); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__LayerHeightSpline_layersUpdated)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerHeightSpline *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerHeightSpline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::LayerHeightSpline::layersUpdated() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 83 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/LayerHeightSpline.xsp\""
    try {
      RETVAL = THIS->layersUpdated();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22276 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__LayerHeightSpline_layerHeightsUpdated); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__LayerHeightSpline_layerHeightsUpdated)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerHeightSpline *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerHeightSpline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::LayerHeightSpline::layerHeightsUpdated() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 97 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/LayerHeightSpline.xsp\""
    try {
      RETVAL = THIS->layerHeightsUpdated();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22316 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__LayerHeightSpline_clear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__LayerHeightSpline_clear)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerHeightSpline *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerHeightSpline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::LayerHeightSpline::clear() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 111 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/LayerHeightSpline.xsp\""
    try {
      THIS->clear();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22354 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__LayerHeightSpline_getOriginalLayers); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__LayerHeightSpline_getOriginalLayers)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerHeightSpline *	THIS;
	std::vector<double>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerHeightSpline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::LayerHeightSpline::getOriginalLayers() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 124 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/LayerHeightSpline.xsp\""
    try {
      RETVAL = THIS->getOriginalLayers();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22392 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSVnv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__LayerHeightSpline_getInterpolatedLayers); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__LayerHeightSpline_getInterpolatedLayers)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	LayerHeightSpline *	THIS;
	std::vector<double>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerHeightSpline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::LayerHeightSpline::getInterpolatedLayers() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 138 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/LayerHeightSpline.xsp\""
    try {
      RETVAL = THIS->getInterpolatedLayers();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22444 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSVnv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__LayerHeightSpline_getLayerHeightAt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__LayerHeightSpline_getLayerHeightAt)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, height");
    {
	LayerHeightSpline *	THIS;
	coordf_t	RETVAL;
	dXSTARG;
	coordf_t	height = (coordf_t)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (LayerHeightSpline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::LayerHeightSpline::getLayerHeightAt() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 152 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/LayerHeightSpline.xsp\""
    try {
      RETVAL = THIS->getLayerHeightAt( height );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22499 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/LayerHeightSpline.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/GUI_3DScene.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "slic3r/GUI/3DScene.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVertexArray_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVertexArray_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	GLVertexArray *	RETVAL;
#line 22 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GUI_3DScene.xsp\""
    try {
      RETVAL = new GLVertexArray();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22540 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVertexArray_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVertexArray_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVertexArray *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVertexArray *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVertexArray::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 39 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GUI_3DScene.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22587 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVertexArray_load_mesh); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVertexArray_load_mesh)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, mesh");
    {
	GLVertexArray *	THIS;
	TriangleMesh*	mesh;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVertexArray *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVertexArray::load_mesh() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(mesh) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(mesh) )) {
              mesh = (TriangleMesh *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("mesh is not of type %s (got %s)", Slic3r::perl_class_name(mesh), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVertexArray::load_mesh() -- mesh is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 52 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GUI_3DScene.xsp\""
     THIS->load_mesh(*mesh); 
#line 22630 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVertexArray_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVertexArray_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVertexArray *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVertexArray *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVertexArray::size() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 57 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GUI_3DScene.xsp\""
     RETVAL = THIS->verts.size(); 
#line 22661 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVertexArray_verts_ptr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVertexArray_verts_ptr)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVertexArray *	THIS;
	void *	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVertexArray *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVertexArray::verts_ptr() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 63 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GUI_3DScene.xsp\""
     RETVAL = THIS->verts.empty() ? 0 : &THIS->verts.front(); 
#line 22693 "buildtmp/XS.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVertexArray_norms_ptr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVertexArray_norms_ptr)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GLVertexArray *	THIS;
	void *	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVertexArray *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVertexArray::norms_ptr() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 69 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GUI_3DScene.xsp\""
     RETVAL = THIS->verts.empty() ? 0 : &THIS->norms.front(); 
#line 22725 "buildtmp/XS.c"
	XSprePUSH; PUSHi(PTR2IV(RETVAL));
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVertexArray_get_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__GLVertexArray_get_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, i");
    {
	GLVertexArray *	THIS;
	Clone<Pointf3>	RETVAL;
	int	i = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GLVertexArray *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::GLVertexArray::get_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 75 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GUI_3DScene.xsp\""
    try {
      RETVAL = THIS->get_point( i );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22766 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GUI___3DScene__extrusionentity_to_verts_do); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GUI___3DScene__extrusionentity_to_verts_do)
{
    dVAR; dXSARGS;
    if (items != 8)
       croak_xs_usage(cv,  "lines, widths, heights, closed, top_z, copy, qverts, tverts");
    {
	Lines	lines;
	std::vector<double>	widths;
	std::vector<double>	heights;
	bool	closed = (bool)SvUV(ST(3))
;
	double	top_z = (double)SvNV(ST(4))
;
	Point*	copy;
	GLVertexArray*	qverts;
	GLVertexArray*	tverts;

    if (SvROK(ST(0)) && SvTYPE(SvRV(ST(0))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(0));
        const unsigned int len = av_len(av)+1;
        lines.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &lines[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::GUI::_3DScene::_extrusionentity_to_verts_do",
	             "lines")
;

	if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(1));
	  const unsigned int len = av_len(av)+1;
	  widths = std::vector<double>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      widths[i] = SvNV(*elem);
	    else
	      widths[i] = 0.;
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::GUI::_3DScene::_extrusionentity_to_verts_do",
	             "widths")
;

	if (SvROK(ST(2)) && SvTYPE(SvRV(ST(2)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(2));
	  const unsigned int len = av_len(av)+1;
	  heights = std::vector<double>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      heights[i] = SvNV(*elem);
	    else
	      heights[i] = 0.;
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::GUI::_3DScene::_extrusionentity_to_verts_do",
	             "heights")
;

    if( sv_isobject(ST(5)) && (SvTYPE(SvRV(ST(5))) == SVt_PVMG) ) {
        if ( sv_isa(ST(5), Slic3r::perl_class_name(copy) ) ||  sv_isa(ST(5), Slic3r::perl_class_name_ref(copy) )) {
              copy = (Point *)SvIV((SV*)SvRV( ST(5) ));
        } else {
              croak("copy is not of type %s (got %s)", Slic3r::perl_class_name(copy), HvNAME(SvSTASH(SvRV(ST(5)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::_extrusionentity_to_verts_do() -- copy is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(6)) && (SvTYPE(SvRV(ST(6))) == SVt_PVMG) ) {
        if ( sv_isa(ST(6), Slic3r::perl_class_name(qverts) ) ||  sv_isa(ST(6), Slic3r::perl_class_name_ref(qverts) )) {
              qverts = (GLVertexArray *)SvIV((SV*)SvRV( ST(6) ));
        } else {
              croak("qverts is not of type %s (got %s)", Slic3r::perl_class_name(qverts), HvNAME(SvSTASH(SvRV(ST(6)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::_extrusionentity_to_verts_do() -- qverts is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(7)) && (SvTYPE(SvRV(ST(7))) == SVt_PVMG) ) {
        if ( sv_isa(ST(7), Slic3r::perl_class_name(tverts) ) ||  sv_isa(ST(7), Slic3r::perl_class_name_ref(tverts) )) {
              tverts = (GLVertexArray *)SvIV((SV*)SvRV( ST(7) ));
        } else {
              croak("tverts is not of type %s (got %s)", Slic3r::perl_class_name(tverts), HvNAME(SvSTASH(SvRV(ST(7)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GUI::_3DScene::_extrusionentity_to_verts_do() -- tverts is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 94 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GUI_3DScene.xsp\""
        _3DScene::_extrusionentity_to_verts_do(lines, widths, heights, closed,
            top_z, *copy, qverts, tverts);
#line 22891 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/GUI_3DScene.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/SupportMaterial.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/SupportMaterial.hpp"

XS_EUPXS(XS_Slic3r__Print__SupportMaterial_MARGIN); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__SupportMaterial_MARGIN)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	SV *	RETVAL;
#line 22 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/SupportMaterial.xsp\""
        RETVAL = newSVnv(SUPPORT_MATERIAL_MARGIN);
#line 22919 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/SupportMaterial.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/GCodeWriter.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__GCode__Writer_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	GCodeWriter *	RETVAL;
#line 21 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = new GCodeWriter();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 22961 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__GCode__Writer_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeWriter *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23008 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__Writer_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeWriter *	THIS;
	Ref<StaticPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
     RETVAL = &THIS->config; 
#line 23038 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<StaticPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_multiple_extruders); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_multiple_extruders)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeWriter *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::multiple_extruders() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 57 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
     RETVAL = THIS->multiple_extruders; 
#line 23077 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_extruder); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_extruder)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeWriter *	THIS;
	Ref<Extruder>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::extruder() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 63 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->extruder();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23116 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Extruder>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_extrusion_axis); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_extrusion_axis)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::extrusion_axis() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 77 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->extrusion_axis();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23162 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_apply_print_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_apply_print_config)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, print_config");
    {
	GCodeWriter *	THIS;
	PrintConfig*	print_config;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::apply_print_config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(print_config) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(print_config) )) {
              print_config = (PrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("print_config is not of type %s (got %s)", Slic3r::perl_class_name(print_config), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::apply_print_config() -- print_config is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 91 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
     THIS->apply_print_config(*print_config); 
#line 23211 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__Writer_set_extruders); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_set_extruders)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, extruder_ids");
    {
	GCodeWriter *	THIS;
	std::vector< unsigned int >	extruder_ids;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::set_extruders() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(1));
	  const unsigned int len = av_len(av)+1;
	  extruder_ids = std::vector<unsigned int>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      extruder_ids[i] = SvUV(*elem);
	    else
	      extruder_ids[i] = 0;
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::GCode::Writer::set_extruders",
	             "extruder_ids")
;
#line 96 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      THIS->set_extruders( extruder_ids );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23268 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__Writer_notes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_notes)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::notes() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 109 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->notes();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23306 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_preamble); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_preamble)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::preamble() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 123 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->preamble();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23350 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_postamble); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_postamble)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::postamble() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 137 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->postamble();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23394 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_set_temperature); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_set_temperature)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "THIS, temperature, wait= false, tool= -1");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;
	unsigned int	temperature = (unsigned int)SvUV(ST(1))
;
	bool	wait;
	int	tool;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::set_temperature() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    wait = false;
	else {
	    wait = (bool)SvUV(ST(2))
;
	}

	if (items < 4)
	    tool = -1;
	else {
	    tool = (int)SvIV(ST(3))
;
	}
#line 151 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->set_temperature( temperature, wait, tool );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23456 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_set_bed_temperature); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_set_bed_temperature)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, temperature, wait= false");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;
	unsigned int	temperature = (unsigned int)SvUV(ST(1))
;
	bool	wait;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::set_bed_temperature() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    wait = false;
	else {
	    wait = (bool)SvUV(ST(2))
;
	}
#line 165 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->set_bed_temperature( temperature, wait );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23510 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_set_fan); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_set_fan)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, speed, dont_save= false");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;
	unsigned int	speed = (unsigned int)SvUV(ST(1))
;
	bool	dont_save;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::set_fan() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    dont_save = false;
	else {
	    dont_save = (bool)SvUV(ST(2))
;
	}
#line 179 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->set_fan( speed, dont_save );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23564 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_set_acceleration); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_set_acceleration)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, acceleration");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;
	unsigned int	acceleration = (unsigned int)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::set_acceleration() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 193 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->set_acceleration( acceleration );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23610 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_reset_e); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_reset_e)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "THIS, force= false");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;
	bool	force;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::reset_e() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 2)
	    force = false;
	else {
	    force = (bool)SvUV(ST(1))
;
	}
#line 207 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->reset_e( force );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23662 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_update_progress); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_update_progress)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "THIS, num, tot, allow_100= false");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;
	unsigned int	num = (unsigned int)SvUV(ST(1))
;
	unsigned int	tot = (unsigned int)SvUV(ST(2))
;
	bool	allow_100;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::update_progress() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 4)
	    allow_100 = false;
	else {
	    allow_100 = (bool)SvUV(ST(3))
;
	}
#line 221 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->update_progress( num, tot, allow_100 );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23718 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_need_toolchange); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_need_toolchange)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, extruder_id");
    {
	GCodeWriter *	THIS;
	bool	RETVAL;
	dXSTARG;
	unsigned int	extruder_id = (unsigned int)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::need_toolchange() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 235 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->need_toolchange( extruder_id );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23765 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_set_extruder); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_set_extruder)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, extruder_id");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;
	unsigned int	extruder_id = (unsigned int)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::set_extruder() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 249 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->set_extruder( extruder_id );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23806 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_toolchange); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_toolchange)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, extruder_id");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;
	unsigned int	extruder_id = (unsigned int)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::toolchange() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 263 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->toolchange( extruder_id );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23852 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_set_speed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_set_speed)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, F, comment= std::string()");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;
	double	F = (double)SvNV(ST(1))
;
	std::string	comment;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::set_speed() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    comment = std::string();
	else {
    {
      size_t len;
      const char * c = SvPVutf8(ST(2), len);
      comment = std::string(c, len);
    }
;
	}
#line 277 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->set_speed( F, comment );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 23910 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_travel_to_xy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_travel_to_xy)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, point, comment= std::string()");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;
	Pointf*	point;
	std::string	comment;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::travel_to_xy() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::travel_to_xy() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    comment = std::string();
	else {
    {
      size_t len;
      const char * c = SvPVutf8(ST(2), len);
      comment = std::string(c, len);
    }
;
	}
#line 291 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
     RETVAL = THIS->travel_to_xy(*point, comment); 
#line 23972 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_travel_to_xyz); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_travel_to_xyz)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, point, comment= std::string()");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;
	Pointf3*	point;
	std::string	comment;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::travel_to_xyz() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::travel_to_xyz() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    comment = std::string();
	else {
    {
      size_t len;
      const char * c = SvPVutf8(ST(2), len);
      comment = std::string(c, len);
    }
;
	}
#line 297 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
     RETVAL = THIS->travel_to_xyz(*point, comment); 
#line 24034 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_travel_to_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_travel_to_z)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, z, comment= std::string()");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;
	double	z = (double)SvNV(ST(1))
;
	std::string	comment;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::travel_to_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    comment = std::string();
	else {
    {
      size_t len;
      const char * c = SvPVutf8(ST(2), len);
      comment = std::string(c, len);
    }
;
	}
#line 303 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->travel_to_z( z, comment );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24092 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_will_move_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_will_move_z)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, z");
    {
	GCodeWriter *	THIS;
	bool	RETVAL;
	dXSTARG;
	double	z = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::will_move_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 317 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->will_move_z( z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24139 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_extrude_to_xy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_extrude_to_xy)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "THIS, point, dE, comment= std::string()");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;
	Pointf*	point;
	double	dE = (double)SvNV(ST(2))
;
	std::string	comment;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::extrude_to_xy() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::extrude_to_xy() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 4)
	    comment = std::string();
	else {
    {
      size_t len;
      const char * c = SvPVutf8(ST(3), len);
      comment = std::string(c, len);
    }
;
	}
#line 331 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
     RETVAL = THIS->extrude_to_xy(*point, dE, comment); 
#line 24198 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_extrude_to_xyz); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_extrude_to_xyz)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "THIS, point, dE, comment= std::string()");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;
	Pointf3*	point;
	double	dE = (double)SvNV(ST(2))
;
	std::string	comment;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::extrude_to_xyz() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::extrude_to_xyz() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 4)
	    comment = std::string();
	else {
    {
      size_t len;
      const char * c = SvPVutf8(ST(3), len);
      comment = std::string(c, len);
    }
;
	}
#line 337 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
     RETVAL = THIS->extrude_to_xyz(*point, dE, comment); 
#line 24262 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_retract); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_retract)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::retract() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 343 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->retract();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24306 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_retract_for_toolchange); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_retract_for_toolchange)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::retract_for_toolchange() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 357 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->retract_for_toolchange();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24350 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_unretract); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_unretract)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::unretract() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 371 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->unretract();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24394 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_lift); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_lift)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::lift() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 385 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->lift();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24438 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_unlift); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_unlift)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeWriter *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::unlift() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 399 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->unlift();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24482 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_get_position); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_get_position)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeWriter *	THIS;
	Clone<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::get_position() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 413 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
    try {
      RETVAL = THIS->get_position();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24526 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Writer_extruders); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Writer_extruders)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCodeWriter *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCodeWriter *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Writer::extruders() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 429 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp\""
        AV* av = newAV();
        av_fill(av, THIS->extruders.size()-1);
        int i = 0;
        for (std::map<unsigned int,Extruder>::iterator it = THIS->extruders.begin(); it != THIS->extruders.end(); ++it) {
            av_store(av, i++, perl_to_SV_ref(it->second));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 24570 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/GCodeWriter.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Surface.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/Surface.hpp"
#include "libslic3r/ClipperUtils.hpp"

XS_EUPXS(XS_Slic3r__Surface_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 19 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Surface.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24622 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Surface_expolygon); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_expolygon)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	Ref<ExPolygon>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::expolygon() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 32 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Surface.xsp\""
     RETVAL = &(THIS->expolygon); 
#line 24652 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExPolygon>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_thickness); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_thickness)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::thickness() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Surface.xsp\""
     RETVAL = THIS->thickness; 
#line 24691 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_thickness_layers); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_thickness_layers)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	unsigned short	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::thickness_layers() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 44 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Surface.xsp\""
     RETVAL = THIS->thickness_layers; 
#line 24723 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_area); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_area)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::area() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 50 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Surface.xsp\""
    try {
      RETVAL = THIS->area();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24763 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_is_solid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_is_solid)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::is_solid() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 64 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Surface.xsp\""
    try {
      RETVAL = THIS->is_solid();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24803 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_is_external); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_is_external)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::is_external() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 78 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Surface.xsp\""
    try {
      RETVAL = THIS->is_external();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24843 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_is_internal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_is_internal)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::is_internal() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 92 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Surface.xsp\""
    try {
      RETVAL = THIS->is_internal();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24883 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_is_bottom); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_is_bottom)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::is_bottom() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 106 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Surface.xsp\""
    try {
      RETVAL = THIS->is_bottom();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24923 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_is_top); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_is_top)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::is_top() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 120 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Surface.xsp\""
    try {
      RETVAL = THIS->is_top();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 24963 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_is_bridge); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_is_bridge)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::is_bridge() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 134 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Surface.xsp\""
    try {
      RETVAL = THIS->is_bridge();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 25003 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface__new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__new)
{
    dVAR; dXSARGS;
    if (items != 7)
       croak_xs_usage(cv,  "CLASS, expolygon, surface_type, thickness, thickness_layers, bridge_angle, extra_perimeters");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	ExPolygon*	expolygon;
	SurfaceType	surface_type = (SurfaceType)SvUV(ST(2))
;
	double	thickness = (double)SvNV(ST(3))
;
	unsigned short	thickness_layers = (unsigned short)SvUV(ST(4))
;
	double	bridge_angle = (double)SvNV(ST(5))
;
	unsigned short	extra_perimeters = (unsigned short)SvUV(ST(6))
;
	Surface *	RETVAL;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(expolygon) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(expolygon) )) {
              expolygon = (ExPolygon *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("expolygon is not of type %s (got %s)", Slic3r::perl_class_name(expolygon), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::_new() -- expolygon is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 157 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Surface.xsp\""
        RETVAL = new Surface (surface_type, *expolygon);
        RETVAL->thickness           = thickness;
        RETVAL->thickness_layers    = thickness_layers;
        RETVAL->bridge_angle        = bridge_angle;
        RETVAL->extra_perimeters    = extra_perimeters;
        // we don't delete expolygon here because it's referenced by a Perl SV
        // whose DESTROY will take care of destruction
#line 25052 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_surface_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_surface_type)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	Surface *	THIS;
	SurfaceType	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::surface_type() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 170 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Surface.xsp\""
        if (items > 1) {
            THIS->surface_type = (SurfaceType)SvUV(ST(1));
        }
        RETVAL = THIS->surface_type;
#line 25094 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_bridge_angle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_bridge_angle)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	Surface *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::bridge_angle() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 180 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Surface.xsp\""
        if (items > 1) {
            THIS->bridge_angle = (double)SvNV(ST(1));
        }
        RETVAL = THIS->bridge_angle;
#line 25129 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_extra_perimeters); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_extra_perimeters)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	Surface *	THIS;
	unsigned short	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::extra_perimeters() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 190 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Surface.xsp\""
        if (items > 1) {
            THIS->extra_perimeters = (double)SvUV(ST(1));
        }
        RETVAL = THIS->extra_perimeters;
#line 25164 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_polygons); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_polygons)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Surface *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::polygons() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 200 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Surface.xsp\""
        RETVAL.push_back(THIS->expolygon.contour);
        for (Polygons::iterator it = THIS->expolygon.holes.begin(); it != THIS->expolygon.holes.end(); ++it) {
            RETVAL.push_back((*it));
        }
#line 25198 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface_offset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface_offset)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 5)
       croak_xs_usage(cv,  "THIS, delta, scale = CLIPPER_OFFSET_SCALE, joinType = ClipperLib::jtMiter, miterLimit = 3");
    {
	const float	delta = (const float)SvNV(ST(1))
;
	double	scale;
	ClipperLib::JoinType	joinType;
	double	miterLimit;
	Surface *	THIS;
	Surfaces	RETVAL;

	if (items < 3)
	    scale = CLIPPER_OFFSET_SCALE;
	else {
	    scale = (double)SvNV(ST(2))
;
	}

	if (items < 4)
	    joinType = ClipperLib::jtMiter;
	else {
	    joinType = (ClipperLib::JoinType)SvUV(ST(3))
;
	}

	if (items < 5)
	    miterLimit = 3;
	else {
	    miterLimit = (double)SvNV(ST(4))
;
	}

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Surface *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Surface::offset() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 214 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Surface.xsp\""
        RETVAL = offset(*THIS, delta, scale, joinType, miterLimit);
#line 25268 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Surfaces::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Surface__constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Surface__constant)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;
#line 236 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Surface.xsp\""
    RETVAL = ix;
#line 25300 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Surface.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/GCode.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/GCode.hpp"
#include "libslic3r/GCode/CoolingBuffer.hpp"
#include "libslic3r/GCode/SpiralVase.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	AvoidCrossingPerimeters *	RETVAL;
#line 23 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      RETVAL = new AvoidCrossingPerimeters();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 25343 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	AvoidCrossingPerimeters *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (AvoidCrossingPerimeters *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::AvoidCrossingPerimeters::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 40 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 25390 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_init_external_mp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_init_external_mp)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, islands");
    {
	AvoidCrossingPerimeters *	THIS;
	ExPolygons	islands;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (AvoidCrossingPerimeters *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::AvoidCrossingPerimeters::init_external_mp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        islands.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &islands[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::GCode::AvoidCrossingPerimeters::init_external_mp",
	             "islands")
;
#line 53 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      THIS->init_external_mp( islands );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 25442 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_init_layer_mp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_init_layer_mp)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, islands");
    {
	AvoidCrossingPerimeters *	THIS;
	ExPolygons	islands;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (AvoidCrossingPerimeters *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::AvoidCrossingPerimeters::init_layer_mp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        islands.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &islands[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::GCode::AvoidCrossingPerimeters::init_layer_mp",
	             "islands")
;
#line 66 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      THIS->init_layer_mp( islands );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 25494 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_travel_to); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_travel_to)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, gcode, point");
    {
	AvoidCrossingPerimeters *	THIS;
	Clone<Polyline>	RETVAL;
	GCode*	gcode;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (AvoidCrossingPerimeters *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::AvoidCrossingPerimeters::travel_to() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(gcode) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(gcode) )) {
              gcode = (GCode *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("gcode is not of type %s (got %s)", Slic3r::perl_class_name(gcode), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::AvoidCrossingPerimeters::travel_to() -- gcode is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::AvoidCrossingPerimeters::travel_to() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 79 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->travel_to(*gcode, *point); 
#line 25552 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_use_external_mp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_use_external_mp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	AvoidCrossingPerimeters *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (AvoidCrossingPerimeters *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::AvoidCrossingPerimeters::use_external_mp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 85 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->use_external_mp; 
#line 25591 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_set_use_external_mp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_set_use_external_mp)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	AvoidCrossingPerimeters *	THIS;
	bool	value = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (AvoidCrossingPerimeters *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::AvoidCrossingPerimeters::set_use_external_mp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 91 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->use_external_mp = value; 
#line 25623 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_use_external_mp_once); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_use_external_mp_once)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	AvoidCrossingPerimeters *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (AvoidCrossingPerimeters *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::AvoidCrossingPerimeters::use_external_mp_once() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 96 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->use_external_mp_once; 
#line 25654 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_set_use_external_mp_once); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_set_use_external_mp_once)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	AvoidCrossingPerimeters *	THIS;
	bool	value = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (AvoidCrossingPerimeters *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::AvoidCrossingPerimeters::set_use_external_mp_once() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 102 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->use_external_mp_once = value; 
#line 25686 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_disable_once); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_disable_once)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	AvoidCrossingPerimeters *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (AvoidCrossingPerimeters *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::AvoidCrossingPerimeters::disable_once() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 107 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->disable_once; 
#line 25717 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_set_disable_once); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__AvoidCrossingPerimeters_set_disable_once)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	AvoidCrossingPerimeters *	THIS;
	bool	value = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (AvoidCrossingPerimeters *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::AvoidCrossingPerimeters::set_disable_once() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 113 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->disable_once = value; 
#line 25749 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__GCode__OozePrevention_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__OozePrevention_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	OozePrevention *	RETVAL;
#line 124 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      RETVAL = new OozePrevention();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 25777 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__GCode__OozePrevention_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__OozePrevention_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	OozePrevention *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (OozePrevention *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::OozePrevention::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 141 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 25824 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__OozePrevention_enable); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__OozePrevention_enable)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	OozePrevention *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (OozePrevention *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::OozePrevention::enable() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 154 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->enable; 
#line 25855 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__OozePrevention_set_enable); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__OozePrevention_set_enable)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	OozePrevention *	THIS;
	bool	value = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (OozePrevention *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::OozePrevention::set_enable() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 160 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->enable = value; 
#line 25887 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__OozePrevention_standby_points); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__OozePrevention_standby_points)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	OozePrevention *	THIS;
	Points	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (OozePrevention *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::OozePrevention::standby_points() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 165 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->standby_points; 
#line 25917 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Points::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__OozePrevention_set_standby_points); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__OozePrevention_set_standby_points)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, points");
    {
	OozePrevention *	THIS;
	Points	points;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (OozePrevention *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::OozePrevention::set_standby_points() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        points.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &points[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::GCode::OozePrevention::set_standby_points",
	             "points")
;
#line 171 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->standby_points = points; 
#line 25975 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__OozePrevention_pre_toolchange); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__OozePrevention_pre_toolchange)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, gcodegen");
    {
	OozePrevention *	THIS;
	std::string	RETVAL;
	GCode*	gcodegen;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (OozePrevention *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::OozePrevention::pre_toolchange() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(gcodegen) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(gcodegen) )) {
              gcodegen = (GCode *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("gcodegen is not of type %s (got %s)", Slic3r::perl_class_name(gcodegen), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::OozePrevention::pre_toolchange() -- gcodegen is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 176 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->pre_toolchange(*gcodegen); 
#line 26019 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__OozePrevention_post_toolchange); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__OozePrevention_post_toolchange)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, gcodegen");
    {
	OozePrevention *	THIS;
	std::string	RETVAL;
	GCode*	gcodegen;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (OozePrevention *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::OozePrevention::post_toolchange() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(gcodegen) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(gcodegen) )) {
              gcodegen = (GCode *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("gcodegen is not of type %s (got %s)", Slic3r::perl_class_name(gcodegen), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::OozePrevention::post_toolchange() -- gcodegen is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 182 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->post_toolchange(*gcodegen); 
#line 26069 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__GCode__Wipe_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Wipe_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Wipe *	RETVAL;
#line 194 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      RETVAL = new Wipe();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26103 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__GCode__Wipe_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Wipe_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Wipe *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Wipe *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Wipe::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 211 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26150 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__Wipe_has_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Wipe_has_path)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Wipe *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Wipe *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Wipe::has_path() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 224 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      RETVAL = THIS->has_path();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26189 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Wipe_reset_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Wipe_reset_path)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Wipe *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Wipe *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Wipe::reset_path() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 238 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      THIS->reset_path();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26227 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__Wipe_wipe); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Wipe_wipe)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, gcodegen, toolchange= false");
    {
	Wipe *	THIS;
	std::string	RETVAL;
	GCode*	gcodegen;
	bool	toolchange;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Wipe *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Wipe::wipe() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(gcodegen) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(gcodegen) )) {
              gcodegen = (GCode *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("gcodegen is not of type %s (got %s)", Slic3r::perl_class_name(gcodegen), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Wipe::wipe() -- gcodegen is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    toolchange = false;
	else {
	    toolchange = (bool)SvUV(ST(2))
;
	}
#line 251 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->wipe(*gcodegen, toolchange); 
#line 26279 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Wipe_enable); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Wipe_enable)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Wipe *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Wipe *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Wipe::enable() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 257 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->enable; 
#line 26316 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Wipe_set_enable); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Wipe_set_enable)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	Wipe *	THIS;
	bool	value = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Wipe *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Wipe::set_enable() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 263 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->enable = value; 
#line 26348 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__Wipe_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Wipe_path)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Wipe *	THIS;
	Ref<Polyline>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Wipe *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Wipe::path() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 268 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = &(THIS->path); 
#line 26378 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__Wipe_set_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__Wipe_set_path)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	Wipe *	THIS;
	Polyline*	value;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Wipe *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Wipe::set_path() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(value) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(value) )) {
              value = (Polyline *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("value is not of type %s (got %s)", Slic3r::perl_class_name(value), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::Wipe::set_path() -- value is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 274 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->path = *value; 
#line 26429 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__GCode__CoolingBuffer_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__CoolingBuffer_new)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, gcode");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	CoolingBuffer *	RETVAL;
	GCode*	gcode;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(gcode) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(gcode) )) {
              gcode = (GCode *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("gcode is not of type %s (got %s)", Slic3r::perl_class_name(gcode), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::CoolingBuffer::new() -- gcode is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 285 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = new CoolingBuffer(*gcode); 
#line 26463 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__GCode__CoolingBuffer_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__CoolingBuffer_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	CoolingBuffer *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (CoolingBuffer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::CoolingBuffer::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 294 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26510 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__CoolingBuffer_gcodegen); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__CoolingBuffer_gcodegen)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	CoolingBuffer *	THIS;
	Ref<GCode>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (CoolingBuffer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::CoolingBuffer::gcodegen() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 307 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      RETVAL = THIS->gcodegen();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26548 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<GCode>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__CoolingBuffer_append); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__CoolingBuffer_append)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "THIS, gcode, obj_id, layer_id, print_z");
    {
	CoolingBuffer *	THIS;
	std::string	RETVAL;
	std::string	gcode;
	std::string	obj_id;
	size_t	layer_id = (size_t)SvUV(ST(3))
;
	float	print_z = (float)SvNV(ST(4))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (CoolingBuffer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::CoolingBuffer::append() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      gcode = std::string(c, len);
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(2), len);
      obj_id = std::string(c, len);
    }
;
#line 321 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      RETVAL = THIS->append( gcode, obj_id, layer_id, print_z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26614 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__CoolingBuffer_flush); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__CoolingBuffer_flush)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	CoolingBuffer *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (CoolingBuffer *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::CoolingBuffer::flush() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 335 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      RETVAL = THIS->flush();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26658 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__GCode__SpiralVase_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__SpiralVase_new)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, config");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	SpiralVase *	RETVAL;
	StaticPrintConfig*	config;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(config) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(config) )) {
              config = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("config is not of type %s (got %s)", Slic3r::perl_class_name(config), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::SpiralVase::new() -- config is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 355 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = new SpiralVase(*dynamic_cast<PrintConfig*>(config)); 
#line 26698 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__GCode__SpiralVase_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__SpiralVase_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SpiralVase *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SpiralVase *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::SpiralVase::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 364 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26745 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__SpiralVase_enable); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__SpiralVase_enable)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	SpiralVase *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SpiralVase *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::SpiralVase::enable() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 377 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->enable; 
#line 26776 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__SpiralVase_set_enable); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__SpiralVase_set_enable)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, enable");
    {
	SpiralVase *	THIS;
	bool	enable = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SpiralVase *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::SpiralVase::set_enable() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 383 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->enable = enable; 
#line 26808 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__SpiralVase_process_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__SpiralVase_process_layer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, gcode");
    {
	SpiralVase *	THIS;
	std::string	RETVAL;
	std::string	gcode;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (SpiralVase *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::SpiralVase::process_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      gcode = std::string(c, len);
    }
;
#line 388 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      RETVAL = THIS->process_layer( gcode );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26854 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__GCode_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	GCode *	RETVAL;
#line 408 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      RETVAL = new GCode();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26888 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__GCode_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 425 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 26935 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_origin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_origin)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	Ref<Pointf>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::origin() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 438 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = &(THIS->origin); 
#line 26965 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	Ref<StaticPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 444 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = &(THIS->config); 
#line 27003 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<StaticPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_writer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_writer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	Ref<GCodeWriter>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::writer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 450 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = &(THIS->writer); 
#line 27041 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<GCodeWriter>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_placeholder_parser); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_placeholder_parser)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	Ref<PlaceholderParser>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::placeholder_parser() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 456 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->placeholder_parser; 
#line 27079 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<PlaceholderParser>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_set_placeholder_parser); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_set_placeholder_parser)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, ptr");
    {
	GCode *	THIS;
	PlaceholderParser*	ptr;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_placeholder_parser() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(ptr) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(ptr) )) {
              ptr = (PlaceholderParser *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("ptr is not of type %s (got %s)", Slic3r::perl_class_name(ptr), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_placeholder_parser() -- ptr is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 462 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->placeholder_parser = ptr; 
#line 27130 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_ooze_prevention); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_ooze_prevention)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	Ref<OozePrevention>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::ooze_prevention() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 467 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = &(THIS->ooze_prevention); 
#line 27160 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<OozePrevention>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_wipe); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_wipe)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	Ref<Wipe>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::wipe() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 473 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = &(THIS->wipe); 
#line 27198 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Wipe>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_avoid_crossing_perimeters); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_avoid_crossing_perimeters)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	Ref<AvoidCrossingPerimeters>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::avoid_crossing_perimeters() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 479 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = &(THIS->avoid_crossing_perimeters); 
#line 27236 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<AvoidCrossingPerimeters>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_enable_loop_clipping); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_enable_loop_clipping)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::enable_loop_clipping() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 485 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->enable_loop_clipping; 
#line 27275 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_set_enable_loop_clipping); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_set_enable_loop_clipping)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	GCode *	THIS;
	bool	value = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_enable_loop_clipping() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 491 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->enable_loop_clipping = value; 
#line 27307 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_enable_cooling_markers); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_enable_cooling_markers)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::enable_cooling_markers() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 496 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->enable_cooling_markers; 
#line 27338 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_set_enable_cooling_markers); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_set_enable_cooling_markers)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	GCode *	THIS;
	bool	value = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_enable_cooling_markers() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 502 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->enable_cooling_markers = value; 
#line 27370 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_layer_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_layer_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::layer_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 507 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->layer_count; 
#line 27401 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_set_layer_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_set_layer_count)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	GCode *	THIS;
	int	value = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_layer_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 513 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->layer_count = value; 
#line 27433 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_layer_index); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_layer_index)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::layer_index() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 518 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->layer_index; 
#line 27464 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_set_layer_index); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_set_layer_index)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	GCode *	THIS;
	int	value = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_layer_index() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 524 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->layer_index = value; 
#line 27496 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_has_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_has_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::has_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 529 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->layer != NULL; 
#line 27527 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	Ref<Layer>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 535 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->layer; 
#line 27558 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Layer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_set_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_set_layer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, ptr");
    {
	GCode *	THIS;
	Layer*	ptr;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(ptr) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(ptr) )) {
              ptr = (Layer *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("ptr is not of type %s (got %s)", Slic3r::perl_class_name(ptr), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_layer() -- ptr is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 541 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->layer = ptr; 
#line 27609 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_first_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_first_layer)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::first_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 546 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->first_layer; 
#line 27640 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_set_first_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_set_first_layer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	GCode *	THIS;
	bool	value = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_first_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 552 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->first_layer = value; 
#line 27672 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_elapsed_time); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_elapsed_time)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	float	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::elapsed_time() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 557 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->elapsed_time; 
#line 27703 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_set_elapsed_time); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_set_elapsed_time)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	GCode *	THIS;
	float	value = (float)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_elapsed_time() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 563 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->elapsed_time = value; 
#line 27735 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_last_pos_defined); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_last_pos_defined)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::last_pos_defined() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 568 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      RETVAL = THIS->last_pos_defined();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 27774 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_last_pos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_last_pos)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	Ref<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::last_pos() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 582 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = &(THIS->last_pos()); 
#line 27805 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_set_last_pos); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_set_last_pos)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, pos");
    {
	GCode *	THIS;
	Point*	pos;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_last_pos() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(pos) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(pos) )) {
              pos = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("pos is not of type %s (got %s)", Slic3r::perl_class_name(pos), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_last_pos() -- pos is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 588 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->set_last_pos(*pos); 
#line 27856 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_volumetric_speed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_volumetric_speed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::volumetric_speed() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 593 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->volumetric_speed; 
#line 27887 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_set_volumetric_speed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_set_volumetric_speed)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	GCode *	THIS;
	double	value = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_volumetric_speed() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 599 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->volumetric_speed = value; 
#line 27919 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_apply_print_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_apply_print_config)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, print_config");
    {
	GCode *	THIS;
	StaticPrintConfig*	print_config;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::apply_print_config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(print_config) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(print_config) )) {
              print_config = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("print_config is not of type %s (got %s)", Slic3r::perl_class_name(print_config), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::apply_print_config() -- print_config is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 604 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
            if (const PrintConfig* config = dynamic_cast<PrintConfig*>(print_config)) {
                THIS->apply_print_config(*config);
            } else {
                CONFESS("A PrintConfig object was not supplied to apply_print_config()");
            }
#line 27966 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_set_extruders); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_set_extruders)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, extruder_ids");
    {
	GCode *	THIS;
	std::vector< unsigned int >	extruder_ids;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_extruders() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(1));
	  const unsigned int len = av_len(av)+1;
	  extruder_ids = std::vector<unsigned int>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      extruder_ids[i] = SvUV(*elem);
	    else
	      extruder_ids[i] = 0;
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::GCode::set_extruders",
	             "extruder_ids")
;
#line 613 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      THIS->set_extruders( extruder_ids );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28023 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_set_origin); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_set_origin)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, pointf");
    {
	GCode *	THIS;
	Pointf*	pointf;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_origin() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(pointf) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(pointf) )) {
              pointf = (Pointf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("pointf is not of type %s (got %s)", Slic3r::perl_class_name(pointf), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_origin() -- pointf is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 626 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     THIS->set_origin(*pointf); 
#line 28066 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode_preamble); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_preamble)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::preamble() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 631 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      RETVAL = THIS->preamble();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28104 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_notes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_notes)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::notes() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 645 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      RETVAL = THIS->notes();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28148 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_change_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_change_layer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, layer");
    {
	GCode *	THIS;
	std::string	RETVAL;
	Layer*	layer;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::change_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(layer) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(layer) )) {
              layer = (Layer *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("layer is not of type %s (got %s)", Slic3r::perl_class_name(layer), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::change_layer() -- layer is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 659 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->change_layer(*layer); 
#line 28198 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_extrude_loop); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_extrude_loop)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "THIS, loop, description= \"\", speed= -1");
    {
	GCode *	THIS;
	std::string	RETVAL;
	ExtrusionLoop*	loop;
	std::string	description;
	double	speed;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::extrude_loop() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(loop) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(loop) )) {
              loop = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("loop is not of type %s (got %s)", Slic3r::perl_class_name(loop), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::extrude_loop() -- loop is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    description = "";
	else {
    {
      size_t len;
      const char * c = SvPVutf8(ST(2), len);
      description = std::string(c, len);
    }
;
	}

	if (items < 4)
	    speed = -1;
	else {
	    speed = (double)SvNV(ST(3))
;
	}
#line 665 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->extrude(*loop, description, speed); 
#line 28268 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_extrude_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_extrude_path)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 4)
       croak_xs_usage(cv,  "THIS, path, description= \"\", speed= -1");
    {
	GCode *	THIS;
	std::string	RETVAL;
	ExtrusionPath*	path;
	std::string	description;
	double	speed;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::extrude_path() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(path) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(path) )) {
              path = (ExtrusionPath *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("path is not of type %s (got %s)", Slic3r::perl_class_name(path), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::extrude_path() -- path is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    description = "";
	else {
    {
      size_t len;
      const char * c = SvPVutf8(ST(2), len);
      description = std::string(c, len);
    }
;
	}

	if (items < 4)
	    speed = -1;
	else {
	    speed = (double)SvNV(ST(3))
;
	}
#line 671 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->extrude(*path, description, speed); 
#line 28338 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_travel_to); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_travel_to)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, point, role, comment");
    {
	GCode *	THIS;
	std::string	RETVAL;
	Point*	point;
	ExtrusionRole	role = (ExtrusionRole)SvUV(ST(2))
;
	std::string	comment;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::travel_to() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::travel_to() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(3), len);
      comment = std::string(c, len);
    }
;
#line 677 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->travel_to(*point, role, comment); 
#line 28398 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_needs_retraction); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_needs_retraction)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, travel, role= erNone");
    {
	GCode *	THIS;
	bool	RETVAL;
	dXSTARG;
	Polyline*	travel;
	ExtrusionRole	role;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::needs_retraction() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(travel) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(travel) )) {
              travel = (Polyline *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("travel is not of type %s (got %s)", Slic3r::perl_class_name(travel), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::needs_retraction() -- travel is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    role = erNone;
	else {
	    role = (ExtrusionRole)SvUV(ST(2))
;
	}
#line 683 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->needs_retraction(*travel, role); 
#line 28457 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_retract); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_retract)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "THIS, toolchange= false");
    {
	GCode *	THIS;
	std::string	RETVAL;
	bool	toolchange;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::retract() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 2)
	    toolchange = false;
	else {
	    toolchange = (bool)SvUV(ST(1))
;
	}
#line 689 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      RETVAL = THIS->retract( toolchange );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28504 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_unretract); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_unretract)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	GCode *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::unretract() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 703 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      RETVAL = THIS->unretract();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28548 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_set_extruder); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_set_extruder)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, extruder_id");
    {
	GCode *	THIS;
	std::string	RETVAL;
	unsigned int	extruder_id = (unsigned int)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::set_extruder() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 717 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
    try {
      RETVAL = THIS->set_extruder( extruder_id );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28594 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_point_to_gcode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_point_to_gcode)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	GCode *	THIS;
	Clone<Pointf>	RETVAL;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::point_to_gcode() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::point_to_gcode() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 731 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
     RETVAL = THIS->point_to_gcode(*point); 
#line 28644 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode_extrude); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode_extrude)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, entity, description, speed");
    {
	SV*	entity = ST(1)
;
	std::string	description;
	double	speed = (double)SvNV(ST(3))
;
	GCode *	THIS;
	std::string	RETVAL;

    {
      size_t len;
      const char * c = SvPVutf8(ST(2), len);
      description = std::string(c, len);
    }
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (GCode *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::extrude() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 741 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/GCode.xsp\""
        ExtrusionEntity* e = (ExtrusionEntity *)SvIV((SV*)SvRV( entity ));
        RETVAL = THIS->extrude(*e, description, speed);
#line 28695 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/GCode.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Line.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/Line.hpp"
#include "libslic3r/Polyline.hpp"

XS_EUPXS(XS_Slic3r__Line_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 19 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28751 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Line_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	Clone<Line>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 32 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
     RETVAL = THIS; 
#line 28781 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Line>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
     RETVAL = to_AV(THIS); 
#line 28819 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 44 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
     RETVAL = to_SV_pureperl(THIS); 
#line 28851 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_a); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_a)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	Ref<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::a() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 50 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
     RETVAL=&THIS->a; 
#line 28883 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_b); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_b)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	Ref<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::b() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 56 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
     RETVAL=&THIS->b; 
#line 28921 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_reverse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_reverse)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::reverse() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 62 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
    try {
      THIS->reverse();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 28966 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Line_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	Line *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 75 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29005 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Line_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_translate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, x, y");
    {
	Line *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 88 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
    try {
      THIS->translate( x, y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29046 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Line_length); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_length)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::length() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 101 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
    try {
      RETVAL = THIS->length();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29085 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_atan2_); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_atan2_)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::atan2_() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 115 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
    try {
      RETVAL = THIS->atan2_();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29125 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_orientation); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_orientation)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::orientation() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 129 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
    try {
      RETVAL = THIS->orientation();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29165 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_direction); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_direction)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::direction() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 143 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
    try {
      RETVAL = THIS->direction();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29205 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_parallel_to); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_parallel_to)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	Line *	THIS;
	bool	RETVAL;
	dXSTARG;
	double	angle = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::parallel_to() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 157 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
    try {
      RETVAL = THIS->parallel_to( angle );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29247 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_parallel_to_line); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_parallel_to_line)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, line");
    {
	Line *	THIS;
	bool	RETVAL;
	dXSTARG;
	Line*	line;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::parallel_to_line() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(line) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(line) )) {
              line = (Line *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("line is not of type %s (got %s)", Slic3r::perl_class_name(line), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::parallel_to_line() -- line is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 171 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
     RETVAL = THIS->parallel_to(*line); 
#line 29293 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_midpoint); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_midpoint)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::midpoint() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 177 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
    try {
      RETVAL = THIS->midpoint();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29332 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_point_at); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_point_at)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	Line *	THIS;
	Clone<Point>	RETVAL;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::point_at() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 191 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
    try {
      RETVAL = THIS->point_at( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29380 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_intersection_infinite); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_intersection_infinite)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, other");
    {
	Line *	THIS;
	Clone<Point>	RETVAL;
	Line*	other;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::intersection_infinite() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(other) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(other) )) {
              other = (Line *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("other is not of type %s (got %s)", Slic3r::perl_class_name(other), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::intersection_infinite() -- other is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 205 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
            Point p;
            bool res = THIS->intersection_infinite(*other, &p);
            if (!res) CONFESS("Intersection failed");
            RETVAL = p;
#line 29435 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_as_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_as_polyline)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	Clone<Polyline>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::as_polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 214 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
     RETVAL = Polyline(*THIS); 
#line 29473 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_normal); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_normal)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::normal() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 220 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
    try {
      RETVAL = THIS->normal();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29519 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_vector); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_vector)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Line *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::vector() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 234 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
    try {
      RETVAL = THIS->vector();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29565 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_ccw); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_ccw)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Line *	THIS;
	double	RETVAL;
	dXSTARG;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::ccw() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::ccw() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 248 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
     RETVAL = THIS->ccw(*point); 
#line 29618 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_new)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "CLASS, ...");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Line *	RETVAL;
#line 256 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
        RETVAL = new Line ();
        // ST(0) is class name, ST(1) and ST(2) are endpoints
        from_SV_check(ST(1), &RETVAL->a);
        from_SV_check(ST(2), &RETVAL->b);
#line 29640 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Line_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_rotate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, angle, center_sv");
    {
	double	angle = (double)SvNV(ST(1))
;
	SV*	center_sv = ST(2)
;
	Line *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::rotate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 268 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
        Point center;
        from_SV_check(center_sv, &center);
        THIS->rotate(angle, center);
#line 29683 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Line_coincides_with); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Line_coincides_with)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, line_sv");
    {
	SV*	line_sv = ST(1)
;
	Line *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Line *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Line::coincides_with() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 276 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
        Line line;
        from_SV_check(line_sv, &line);
        RETVAL = THIS->coincides_with(line);
#line 29718 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Linef3_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Linef3_new)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "CLASS, a, b");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Linef3 *	RETVAL;
	Pointf3*	a;
	Pointf3*	b;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(a) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(a) )) {
              a = (Pointf3 *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("a is not of type %s (got %s)", Slic3r::perl_class_name(a), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Linef3::new() -- a is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(b) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(b) )) {
              b = (Pointf3 *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("b is not of type %s (got %s)", Slic3r::perl_class_name(b), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Linef3::new() -- b is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 293 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
     RETVAL = new Linef3(*a, *b); 
#line 29767 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Linef3_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Linef3_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Linef3 *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Linef3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Linef3::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 302 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29814 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Linef3_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Linef3_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Linef3 *	THIS;
	Clone<Linef3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Linef3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Linef3::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 315 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
     RETVAL = THIS; 
#line 29844 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Linef3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Linef3_a); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Linef3_a)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Linef3 *	THIS;
	Ref<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Linef3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Linef3::a() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 321 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
     RETVAL = &THIS->a; 
#line 29882 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Linef3_b); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Linef3_b)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Linef3 *	THIS;
	Ref<Pointf3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Linef3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Linef3::b() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 327 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
     RETVAL = &THIS->b; 
#line 29920 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Linef3_intersect_plane); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Linef3_intersect_plane)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, z");
    {
	Linef3 *	THIS;
	Clone<Pointf3>	RETVAL;
	double	z = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Linef3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Linef3::intersect_plane() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 333 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
    try {
      RETVAL = THIS->intersect_plane( z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 29968 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Pointf3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Linef3_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Linef3_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	Linef3 *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Linef3 *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Linef3::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 347 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Line.xsp\""
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30015 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Line.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/BoundingBox.hpp"
#include "libslic3r/Polygon.hpp"
#include "libslic3r/BoundingBox.hpp"

XS_EUPXS(XS_Slic3r__Polygon_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 20 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30066 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polygon_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	Clone<Polygon>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 33 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
     RETVAL = THIS; 
#line 30096 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polygon>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 39 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
     RETVAL = to_AV(THIS); 
#line 30134 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 45 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
     RETVAL = to_SV_pureperl(THIS); 
#line 30166 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	Polygon *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30207 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polygon_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_translate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, x, y");
    {
	Polygon *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 64 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      THIS->translate( x, y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30248 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polygon_reverse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_reverse)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::reverse() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 77 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      THIS->reverse();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30285 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polygon_lines); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_lines)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	Lines	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::lines() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 90 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      RETVAL = THIS->lines();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30323 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Lines::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_split_at_vertex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_split_at_vertex)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Polygon *	THIS;
	Clone<Polyline>	RETVAL;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::split_at_vertex() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::split_at_vertex() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 104 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
     RETVAL = THIS->split_at_vertex(*point); 
#line 30381 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_split_at_index); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_split_at_index)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, index");
    {
	Polygon *	THIS;
	Clone<Polyline>	RETVAL;
	int	index = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::split_at_index() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 110 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      RETVAL = THIS->split_at_index( index );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30429 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_split_at_first_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_split_at_first_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	Clone<Polyline>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::split_at_first_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 124 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      RETVAL = THIS->split_at_first_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30475 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_equally_spaced_points); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_equally_spaced_points)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	Polygon *	THIS;
	Points	RETVAL;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::equally_spaced_points() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 138 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      RETVAL = THIS->equally_spaced_points( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30523 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Points::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_length); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_length)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::length() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 152 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      RETVAL = THIS->length();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30576 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_area); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_area)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::area() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 166 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      RETVAL = THIS->area();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30616 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_is_counter_clockwise); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_is_counter_clockwise)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::is_counter_clockwise() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 180 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      RETVAL = THIS->is_counter_clockwise();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30656 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_is_clockwise); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_is_clockwise)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::is_clockwise() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 194 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      RETVAL = THIS->is_clockwise();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30696 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_make_counter_clockwise); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_make_counter_clockwise)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::make_counter_clockwise() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 208 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      RETVAL = THIS->make_counter_clockwise();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30736 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_make_clockwise); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_make_clockwise)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::make_clockwise() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 222 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      RETVAL = THIS->make_clockwise();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30776 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_is_valid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_is_valid)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::is_valid() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 236 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      RETVAL = THIS->is_valid();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30816 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_first_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_first_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::first_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 250 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      RETVAL = THIS->first_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30855 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_contains_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_contains_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	Polygon *	THIS;
	bool	RETVAL;
	dXSTARG;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::contains_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::contains_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 264 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
     RETVAL = THIS->contains(*point); 
#line 30908 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_simplify); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_simplify)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, tolerance");
    {
	Polygon *	THIS;
	Polygons	RETVAL;
	double	tolerance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::simplify() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 270 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      RETVAL = THIS->simplify( tolerance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 30949 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_triangulate_convex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_triangulate_convex)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::triangulate_convex() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 284 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
     THIS->triangulate_convex(&RETVAL); 
#line 30993 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_centroid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_centroid)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::centroid() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 290 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      RETVAL = THIS->centroid();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31045 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	Clone<BoundingBox>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 304 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      RETVAL = THIS->bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31091 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBox>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_wkt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_wkt)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polygon *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::wkt() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 318 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      RETVAL = THIS->wkt();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31137 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_concave_points); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_concave_points)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	Polygon *	THIS;
	Points	RETVAL;
	double	angle = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::concave_points() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 332 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      RETVAL = THIS->concave_points( angle );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31183 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Points::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_convex_points); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_convex_points)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	Polygon *	THIS;
	Points	RETVAL;
	double	angle = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::convex_points() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 346 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
    try {
      RETVAL = THIS->convex_points( angle );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31237 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Points::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_intersection); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_intersection)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, line");
    {
	Polygon *	THIS;
	Clone<Point>	RETVAL;
	Line*	line;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::intersection() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(line) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(line) )) {
              line = (Line *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("line is not of type %s (got %s)", Slic3r::perl_class_name(line), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::intersection() -- line is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 360 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
            Point p;
            (void)THIS->intersection(*line, &p);
            RETVAL = p;
#line 31297 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_new)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "CLASS, ...");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Polygon *	RETVAL;
#line 370 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
        RETVAL = new Polygon ();
        // ST(0) is class name, ST(1) is first point
        RETVAL->points.resize(items-1);
        for (unsigned int i = 1; i < items; i++) {
            from_SV_check(ST(i), &RETVAL->points[i-1]);
        }
#line 31328 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polygon_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polygon_rotate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, angle, center_sv");
    {
	double	angle = (double)SvNV(ST(1))
;
	SV*	center_sv = ST(2)
;
	Polygon *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polygon::rotate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 384 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp\""
        Point center;
        from_SV_check(center_sv, &center);
        THIS->rotate(angle, center);
#line 31371 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Polygon.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/PerimeterGenerator.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/PerimeterGenerator.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_new)
{
    dVAR; dXSARGS;
    if (items != 10)
       croak_xs_usage(cv,  "CLASS, slices, layer_height, flow, region_config, object_config, print_config, loops, gap_fill, fill_surfaces");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	PerimeterGenerator *	RETVAL;
	SurfaceCollection*	slices;
	double	layer_height = (double)SvNV(ST(2))
;
	Flow*	flow;
	StaticPrintConfig*	region_config;
	StaticPrintConfig*	object_config;
	StaticPrintConfig*	print_config;
	ExtrusionEntityCollection*	loops;
	ExtrusionEntityCollection*	gap_fill;
	SurfaceCollection*	fill_surfaces;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(slices) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(slices) )) {
              slices = (SurfaceCollection *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("slices is not of type %s (got %s)", Slic3r::perl_class_name(slices), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::new() -- slices is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(3)) && (SvTYPE(SvRV(ST(3))) == SVt_PVMG) ) {
        if ( sv_isa(ST(3), Slic3r::perl_class_name(flow) ) ||  sv_isa(ST(3), Slic3r::perl_class_name_ref(flow) )) {
              flow = (Flow *)SvIV((SV*)SvRV( ST(3) ));
        } else {
              croak("flow is not of type %s (got %s)", Slic3r::perl_class_name(flow), HvNAME(SvSTASH(SvRV(ST(3)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::new() -- flow is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(4)) && (SvTYPE(SvRV(ST(4))) == SVt_PVMG) ) {
        if ( sv_isa(ST(4), Slic3r::perl_class_name(region_config) ) ||  sv_isa(ST(4), Slic3r::perl_class_name_ref(region_config) )) {
              region_config = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(4) ));
        } else {
              croak("region_config is not of type %s (got %s)", Slic3r::perl_class_name(region_config), HvNAME(SvSTASH(SvRV(ST(4)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::new() -- region_config is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(5)) && (SvTYPE(SvRV(ST(5))) == SVt_PVMG) ) {
        if ( sv_isa(ST(5), Slic3r::perl_class_name(object_config) ) ||  sv_isa(ST(5), Slic3r::perl_class_name_ref(object_config) )) {
              object_config = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(5) ));
        } else {
              croak("object_config is not of type %s (got %s)", Slic3r::perl_class_name(object_config), HvNAME(SvSTASH(SvRV(ST(5)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::new() -- object_config is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(6)) && (SvTYPE(SvRV(ST(6))) == SVt_PVMG) ) {
        if ( sv_isa(ST(6), Slic3r::perl_class_name(print_config) ) ||  sv_isa(ST(6), Slic3r::perl_class_name_ref(print_config) )) {
              print_config = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(6) ));
        } else {
              croak("print_config is not of type %s (got %s)", Slic3r::perl_class_name(print_config), HvNAME(SvSTASH(SvRV(ST(6)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::new() -- print_config is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(7)) && (SvTYPE(SvRV(ST(7))) == SVt_PVMG) ) {
        if ( sv_isa(ST(7), Slic3r::perl_class_name(loops) ) ||  sv_isa(ST(7), Slic3r::perl_class_name_ref(loops) )) {
              loops = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(7) ));
        } else {
              croak("loops is not of type %s (got %s)", Slic3r::perl_class_name(loops), HvNAME(SvSTASH(SvRV(ST(7)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::new() -- loops is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(8)) && (SvTYPE(SvRV(ST(8))) == SVt_PVMG) ) {
        if ( sv_isa(ST(8), Slic3r::perl_class_name(gap_fill) ) ||  sv_isa(ST(8), Slic3r::perl_class_name_ref(gap_fill) )) {
              gap_fill = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(8) ));
        } else {
              croak("gap_fill is not of type %s (got %s)", Slic3r::perl_class_name(gap_fill), HvNAME(SvSTASH(SvRV(ST(8)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::new() -- gap_fill is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(9)) && (SvTYPE(SvRV(ST(9))) == SVt_PVMG) ) {
        if ( sv_isa(ST(9), Slic3r::perl_class_name(fill_surfaces) ) ||  sv_isa(ST(9), Slic3r::perl_class_name_ref(fill_surfaces) )) {
              fill_surfaces = (SurfaceCollection *)SvIV((SV*)SvRV( ST(9) ));
        } else {
              croak("fill_surfaces is not of type %s (got %s)", Slic3r::perl_class_name(fill_surfaces), HvNAME(SvSTASH(SvRV(ST(9)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::new() -- fill_surfaces is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 21 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PerimeterGenerator.xsp\""
     RETVAL = new PerimeterGenerator(slices, layer_height, *flow,
            dynamic_cast<PrintRegionConfig*>(region_config),
            dynamic_cast<PrintObjectConfig*>(object_config),
            dynamic_cast<PrintConfig*>(print_config),
            loops, gap_fill, fill_surfaces); 
#line 31521 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PerimeterGenerator *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PerimeterGenerator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 34 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PerimeterGenerator.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31568 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_lower_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_lower_slices)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, lower_slices");
    {
	PerimeterGenerator *	THIS;
	ExPolygonCollection*	lower_slices;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PerimeterGenerator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_lower_slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(lower_slices) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(lower_slices) )) {
              lower_slices = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("lower_slices is not of type %s (got %s)", Slic3r::perl_class_name(lower_slices), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_lower_slices() -- lower_slices is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 47 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PerimeterGenerator.xsp\""
     THIS->lower_slices = lower_slices; 
#line 31611 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_layer_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_layer_id)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, layer_id");
    {
	PerimeterGenerator *	THIS;
	int	layer_id = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PerimeterGenerator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_layer_id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 52 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PerimeterGenerator.xsp\""
     THIS->layer_id = layer_id; 
#line 31642 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_perimeter_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_perimeter_flow)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, flow");
    {
	PerimeterGenerator *	THIS;
	Flow*	flow;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PerimeterGenerator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_perimeter_flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(flow) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(flow) )) {
              flow = (Flow *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("flow is not of type %s (got %s)", Slic3r::perl_class_name(flow), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_perimeter_flow() -- flow is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 57 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PerimeterGenerator.xsp\""
     THIS->perimeter_flow = *flow; 
#line 31685 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_ext_perimeter_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_ext_perimeter_flow)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, flow");
    {
	PerimeterGenerator *	THIS;
	Flow*	flow;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PerimeterGenerator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_ext_perimeter_flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(flow) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(flow) )) {
              flow = (Flow *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("flow is not of type %s (got %s)", Slic3r::perl_class_name(flow), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_ext_perimeter_flow() -- flow is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 62 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PerimeterGenerator.xsp\""
     THIS->ext_perimeter_flow = *flow; 
#line 31728 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_overhang_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_overhang_flow)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, flow");
    {
	PerimeterGenerator *	THIS;
	Flow*	flow;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PerimeterGenerator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_overhang_flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(flow) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(flow) )) {
              flow = (Flow *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("flow is not of type %s (got %s)", Slic3r::perl_class_name(flow), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_overhang_flow() -- flow is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 67 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PerimeterGenerator.xsp\""
     THIS->overhang_flow = *flow; 
#line 31771 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_solid_infill_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_set_solid_infill_flow)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, flow");
    {
	PerimeterGenerator *	THIS;
	Flow*	flow;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PerimeterGenerator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_solid_infill_flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(flow) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(flow) )) {
              flow = (Flow *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("flow is not of type %s (got %s)", Slic3r::perl_class_name(flow), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::set_solid_infill_flow() -- flow is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 72 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PerimeterGenerator.xsp\""
     THIS->solid_infill_flow = *flow; 
#line 31814 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PerimeterGenerator *	THIS;
	Ref<StaticPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PerimeterGenerator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 77 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PerimeterGenerator.xsp\""
     RETVAL = THIS->config; 
#line 31844 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<StaticPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_process); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Layer__PerimeterGenerator_process)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PerimeterGenerator *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PerimeterGenerator *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Layer::PerimeterGenerator::process() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 83 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PerimeterGenerator.xsp\""
    try {
      THIS->process();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31889 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/PerimeterGenerator.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/PlaceholderParser.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include <vector>
#include "libslic3r/PlaceholderParser.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	PlaceholderParser *	RETVAL;
#line 22 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PlaceholderParser.xsp\""
    try {
      RETVAL = new PlaceholderParser();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31930 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PlaceholderParser *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PlaceholderParser *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::PlaceholderParser::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 39 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PlaceholderParser.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 31977 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PlaceholderParser *	THIS;
	Clone<PlaceholderParser>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PlaceholderParser *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::PlaceholderParser::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 52 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PlaceholderParser.xsp\""
     RETVAL = THIS; 
#line 32007 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<PlaceholderParser>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_update_timestamp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_update_timestamp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PlaceholderParser *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PlaceholderParser *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::PlaceholderParser::update_timestamp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 58 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PlaceholderParser.xsp\""
    try {
      THIS->update_timestamp();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32052 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_apply_env_variables); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_apply_env_variables)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PlaceholderParser *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PlaceholderParser *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::PlaceholderParser::apply_env_variables() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 71 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PlaceholderParser.xsp\""
    try {
      THIS->apply_env_variables();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32089 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_apply_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_apply_config)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, config");
    {
	PlaceholderParser *	THIS;
	DynamicPrintConfig*	config;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PlaceholderParser *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::PlaceholderParser::apply_config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(config) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(config) )) {
              config = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("config is not of type %s (got %s)", Slic3r::perl_class_name(config), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::PlaceholderParser::apply_config() -- config is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 84 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PlaceholderParser.xsp\""
     THIS->apply_config(*config); 
#line 32132 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_set); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_set)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, key, value");
    {
	PlaceholderParser *	THIS;
	std::string	key;
	std::string	value;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PlaceholderParser *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::PlaceholderParser::set() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      key = std::string(c, len);
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(2), len);
      value = std::string(c, len);
    }
;
#line 89 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PlaceholderParser.xsp\""
    try {
      THIS->set( key, value );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32185 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_set_multiple); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_set_multiple)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, key, values");
    {
	PlaceholderParser *	THIS;
	std::string	key;
	std::vector< std::string >	values;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PlaceholderParser *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::PlaceholderParser::set_multiple() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      key = std::string(c, len);
    }
;

	if (SvROK(ST(2)) && SvTYPE(SvRV(ST(2)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(2));
	  const unsigned int alen = av_len(av)+1;
	  values = std::vector<std::string>(alen);
	  STRLEN len;
	  char* tmp;
	  SV** elem;
	  for (unsigned int i = 0; i < alen; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL) {
	    tmp = SvPVutf8(*elem, len);
	      values[i] = std::string(tmp, len);
	    }
	    else
	      values[i] = std::string("");
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::GCode::PlaceholderParser::set_multiple",
	             "values")
;
#line 102 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PlaceholderParser.xsp\""
    try {
      THIS->set( key, values );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32254 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_process); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__GCode__PlaceholderParser_process)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, str");
    {
	PlaceholderParser *	THIS;
	std::string	RETVAL;
	std::string	str;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PlaceholderParser *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::GCode::PlaceholderParser::process() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      str = std::string(c, len);
    }
;
#line 115 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PlaceholderParser.xsp\""
    try {
      RETVAL = THIS->process( str );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32300 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/PlaceholderParser.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/ExtrusionEntity.hpp"
#include "libslic3r/ExtrusionEntityCollection.hpp"

XS_EUPXS(XS_Slic3r__ExtrusionPath_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 19 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32356 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 32 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
     RETVAL = to_AV(&THIS->polyline); 
#line 32386 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
     RETVAL = to_SV_pureperl(&THIS->polyline); 
#line 32418 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_pop_back); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_pop_back)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::pop_back() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 44 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
     THIS->polyline.points.pop_back(); 
#line 32449 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_reverse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_reverse)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::reverse() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 49 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
    try {
      THIS->reverse();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32486 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_lines); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_lines)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	Lines	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::lines() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 62 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
     RETVAL = THIS->polyline.lines(); 
#line 32516 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Lines::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_first_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_first_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::first_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 68 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
    try {
      RETVAL = THIS->first_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32568 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_last_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_last_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::last_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 82 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
    try {
      RETVAL = THIS->last_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32614 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_clip_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_clip_end)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	ExtrusionPath *	THIS;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::clip_end() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 96 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
    try {
      THIS->clip_end( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32661 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_simplify); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_simplify)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, tolerance");
    {
	ExtrusionPath *	THIS;
	double	tolerance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::simplify() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 109 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
    try {
      THIS->simplify( tolerance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32700 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_length); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_length)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::length() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 122 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
    try {
      RETVAL = THIS->length();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32739 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_is_perimeter); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_is_perimeter)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::is_perimeter() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 136 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
    try {
      RETVAL = THIS->is_perimeter();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32779 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_is_infill); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_is_infill)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::is_infill() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 150 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
    try {
      RETVAL = THIS->is_infill();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32819 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_is_solid_infill); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_is_solid_infill)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::is_solid_infill() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 164 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
    try {
      RETVAL = THIS->is_solid_infill();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32859 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_is_bridge); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_is_bridge)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::is_bridge() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 178 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
    try {
      RETVAL = THIS->is_bridge();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32899 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_grow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_grow)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::grow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 192 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
    try {
      RETVAL = THIS->grow();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32938 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_as_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_as_polyline)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionPath *	THIS;
	Clone<Polyline>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::as_polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 206 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
    try {
      RETVAL = THIS->as_polyline();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 32990 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__new)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "CLASS, polyline_sv, role, mm3_per_mm, width, height");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	SV*	polyline_sv = ST(1)
;
	ExtrusionRole	role = (ExtrusionRole)SvUV(ST(2))
;
	double	mm3_per_mm = (double)SvNV(ST(3))
;
	float	width = (float)SvNV(ST(4))
;
	float	height = (float)SvNV(ST(5))
;
	ExtrusionPath *	RETVAL;
#line 228 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
        RETVAL = new ExtrusionPath (role);
        from_SV_check(polyline_sv, &RETVAL->polyline);
        RETVAL->mm3_per_mm      = mm3_per_mm;
        RETVAL->width           = width;
        RETVAL->height          = height;
#line 33030 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_polyline)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	ExtrusionPath *	THIS;
	Ref<Polyline>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 239 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
        if (items > 1) {
            from_SV_check(ST(1), &THIS->polyline);
        }
        RETVAL = &(THIS->polyline);
#line 33071 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_role); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_role)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	ExtrusionPath *	THIS;
	ExtrusionRole	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::role() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 249 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
        if (items > 1) {
            THIS->role = (ExtrusionRole)SvUV(ST(1));
        }
        RETVAL = THIS->role;
#line 33113 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_mm3_per_mm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_mm3_per_mm)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	ExtrusionPath *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::mm3_per_mm() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 259 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
        if (items > 1) {
            THIS->mm3_per_mm = (double)SvNV(ST(1));
        }
        RETVAL = THIS->mm3_per_mm;
#line 33148 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_width); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_width)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	ExtrusionPath *	THIS;
	float	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::width() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 269 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
        if (items > 1) {
            THIS->width = (float)SvNV(ST(1));
        }
        RETVAL = THIS->width;
#line 33183 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_height)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	ExtrusionPath *	THIS;
	float	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::height() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 279 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
        if (items > 1) {
            THIS->height = (float)SvNV(ST(1));
        }
        RETVAL = THIS->height;
#line 33218 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_append); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_append)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	ExtrusionPath *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::append() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 289 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
        for (unsigned int i = 1; i < items; i++) {
            Point p;
            from_SV_check(ST(i), &p);
            THIS->polyline.points.push_back(p);
        }
#line 33252 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_intersect_expolygons); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_intersect_expolygons)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, collection");
    {
	ExtrusionPath *	THIS;
	ExtrusionEntityCollection *	RETVAL;
	ExPolygonCollection*	collection;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::intersect_expolygons() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(collection) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(collection) )) {
              collection = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("collection is not of type %s (got %s)", Slic3r::perl_class_name(collection), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::intersect_expolygons() -- collection is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 298 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
        RETVAL = new ExtrusionEntityCollection ();
        THIS->intersect_expolygons(*collection, RETVAL);
#line 33297 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath_subtract_expolygons); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath_subtract_expolygons)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, collection");
    {
	ExtrusionPath *	THIS;
	ExtrusionEntityCollection *	RETVAL;
	ExPolygonCollection*	collection;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionPath *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::subtract_expolygons() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(collection) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(collection) )) {
              collection = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("collection is not of type %s (got %s)", Slic3r::perl_class_name(collection), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::subtract_expolygons() -- collection is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 306 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
        RETVAL = new ExtrusionEntityCollection ();
        THIS->subtract_expolygons(*collection, RETVAL);
#line 33350 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__constant)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;
#line 335 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp\""
    RETVAL = ix;
#line 33376 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/ExtrusionPath.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/ExPolygonCollection.hpp"

XS_EUPXS(XS_Slic3r__ExPolygon__Collection_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygonCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 18 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 33426 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygonCollection *	THIS;
	Clone<ExPolygonCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 31 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp\""
     RETVAL = THIS; 
#line 33456 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<ExPolygonCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_clear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_clear)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygonCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::clear() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 37 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp\""
     THIS->expolygons.clear(); 
#line 33493 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	ExPolygonCollection *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 42 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp\""
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 33532 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_translate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, x, y");
    {
	ExPolygonCollection *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 55 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp\""
    try {
      THIS->translate( x, y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 33573 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_rotate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, angle, center");
    {
	ExPolygonCollection *	THIS;
	double	angle = (double)SvNV(ST(1))
;
	Point*	center;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::rotate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(center) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(center) )) {
              center = (Point *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("center is not of type %s (got %s)", Slic3r::perl_class_name(center), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::rotate() -- center is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 68 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp\""
     THIS->rotate(angle, *center); 
#line 33618 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygonCollection *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 73 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp\""
     RETVAL = THIS->expolygons.size(); 
#line 33649 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_contains_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_contains_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	ExPolygonCollection *	THIS;
	bool	RETVAL;
	dXSTARG;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::contains_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::contains_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 79 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp\""
     RETVAL = THIS->contains(*point); 
#line 33695 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_contains_line); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_contains_line)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, line");
    {
	ExPolygonCollection *	THIS;
	bool	RETVAL;
	dXSTARG;
	Line*	line;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::contains_line() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(line) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(line) )) {
              line = (Line *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("line is not of type %s (got %s)", Slic3r::perl_class_name(line), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::contains_line() -- line is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 85 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp\""
     RETVAL = THIS->contains(*line); 
#line 33741 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_contains_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_contains_polyline)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, polyline");
    {
	ExPolygonCollection *	THIS;
	bool	RETVAL;
	dXSTARG;
	Polyline*	polyline;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::contains_polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(polyline) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(polyline) )) {
              polyline = (Polyline *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("polyline is not of type %s (got %s)", Slic3r::perl_class_name(polyline), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::contains_polyline() -- polyline is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 91 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp\""
     RETVAL = THIS->contains(*polyline); 
#line 33787 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_simplify); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_simplify)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, tolerance");
    {
	ExPolygonCollection *	THIS;
	double	tolerance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::simplify() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 97 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp\""
    try {
      THIS->simplify( tolerance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 33827 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_polygons); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_polygons)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygonCollection *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::polygons() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 110 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp\""
     RETVAL = *THIS; 
#line 33857 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_convex_hull); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_convex_hull)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygonCollection *	THIS;
	Clone<Polygon>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::convex_hull() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 116 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp\""
    try {
      RETVAL = THIS->convex_hull();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 33909 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polygon>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_new)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "CLASS, ...");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	ExPolygonCollection *	RETVAL;
#line 132 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp\""
        RETVAL = new ExPolygonCollection ();
        // ST(0) is class name, others are expolygons
        RETVAL->expolygons.resize(items-1);
        for (unsigned int i = 1; i < items; i++) {
            // Note: a COPY of the input is stored
            from_SV_check(ST(i), &RETVAL->expolygons[i-1]);
        }
#line 33941 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygonCollection *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 145 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp\""
        AV* av = newAV();
        av_fill(av, THIS->expolygons.size()-1);
        int i = 0;
        for (ExPolygons::iterator it = THIS->expolygons.begin(); it != THIS->expolygons.end(); ++it) {
            av_store(av, i++, perl_to_SV_ref(*it));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 33985 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygonCollection *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 158 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp\""
        AV* av = newAV();
        av_fill(av, THIS->expolygons.size()-1);
        int i = 0;
        for (ExPolygons::iterator it = THIS->expolygons.begin(); it != THIS->expolygons.end(); ++it) {
            av_store(av, i++, to_SV_pureperl(&*it));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 34023 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon__Collection_append); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon__Collection_append)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	ExPolygonCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::Collection::append() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 171 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp\""
        for (unsigned int i = 1; i < items; i++) {
            ExPolygon expolygon;
            from_SV_check(ST(i), &expolygon);
            THIS->expolygons.push_back(expolygon);
        }
#line 34058 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/ExPolygonCollection.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/PolylineCollection.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/PolylineCollection.hpp"

XS_EUPXS(XS_Slic3r__Polyline__Collection_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PolylineCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 18 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PolylineCollection.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 34107 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PolylineCollection *	THIS;
	Clone<PolylineCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 31 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PolylineCollection.xsp\""
     RETVAL = THIS; 
#line 34137 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<PolylineCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_clear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_clear)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PolylineCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::clear() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 37 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PolylineCollection.xsp\""
     THIS->polylines.clear(); 
#line 34174 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_chained_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_chained_path)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, no_reverse");
    {
	PolylineCollection *	THIS;
	PolylineCollection *	RETVAL;
	bool	no_reverse = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::chained_path() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 42 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PolylineCollection.xsp\""
            RETVAL = new PolylineCollection();
            THIS->chained_path(RETVAL, no_reverse);
#line 34207 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_chained_path_from); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_chained_path_from)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, start_near, no_reverse");
    {
	PolylineCollection *	THIS;
	PolylineCollection *	RETVAL;
	Point*	start_near;
	bool	no_reverse = (bool)SvUV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::chained_path_from() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(start_near) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(start_near) )) {
              start_near = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("start_near is not of type %s (got %s)", Slic3r::perl_class_name(start_near), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::chained_path_from() -- start_near is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 49 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PolylineCollection.xsp\""
            RETVAL = new PolylineCollection();
            THIS->chained_path_from(*start_near, RETVAL, no_reverse);
#line 34262 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PolylineCollection *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 56 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PolylineCollection.xsp\""
     RETVAL = THIS->polylines.size(); 
#line 34301 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_leftmost_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_leftmost_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PolylineCollection *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::leftmost_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 62 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PolylineCollection.xsp\""
    try {
      RETVAL = THIS->leftmost_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 34340 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_new)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "CLASS, ...");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	PolylineCollection *	RETVAL;
#line 78 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PolylineCollection.xsp\""
        RETVAL = new PolylineCollection ();
        // ST(0) is class name, others are Polylines
        RETVAL->polylines.resize(items-1);
        for (unsigned int i = 1; i < items; i++) {
            // Note: a COPY of the input is stored
            from_SV_check(ST(i), &RETVAL->polylines[i-1]);
        }
#line 34372 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PolylineCollection *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 91 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PolylineCollection.xsp\""
        AV* av = newAV();
        av_fill(av, THIS->polylines.size()-1);
        int i = 0;
        for (Polylines::iterator it = THIS->polylines.begin(); it != THIS->polylines.end(); ++it) {
            av_store(av, i++, perl_to_SV_ref(*it));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 34416 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PolylineCollection *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 104 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PolylineCollection.xsp\""
        AV* av = newAV();
        av_fill(av, THIS->polylines.size()-1);
        int i = 0;
        for (Polylines::iterator it = THIS->polylines.begin(); it != THIS->polylines.end(); ++it) {
            av_store(av, i++, to_SV_pureperl(&*it));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 34454 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline__Collection_append); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline__Collection_append)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	PolylineCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PolylineCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::Collection::append() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 117 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/PolylineCollection.xsp\""
        for (unsigned int i = 1; i < items; i++) {
            Polyline polyline;
            from_SV_check(ST(i), &polyline);
            THIS->polylines.push_back(polyline);
        }
#line 34489 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/PolylineCollection.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Print.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/Print.hpp"
#include "libslic3r/PlaceholderParser.hpp"

XS_EUPXS(XS_Slic3r__Print__State__constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__State__constant)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;
#line 32 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    RETVAL = ix;
#line 34520 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Region_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Region_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintRegion *	THIS;
	Ref<StaticPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Region::config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 44 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = &THIS->config; 
#line 34551 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<StaticPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Region_print); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Region_print)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintRegion *	THIS;
	Ref<Print>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Region::print() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 50 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->print();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 34597 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Print>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Region_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Region_flow)
{
    dVAR; dXSARGS;
    if (items != 7)
       croak_xs_usage(cv,  "THIS, role, layer_height, bridge, first_layer, width, object");
    {
	PrintRegion *	THIS;
	Clone<Flow>	RETVAL;
	FlowRole	role = (FlowRole)SvUV(ST(1))
;
	double	layer_height = (double)SvNV(ST(2))
;
	bool	bridge = (bool)SvUV(ST(3))
;
	bool	first_layer = (bool)SvUV(ST(4))
;
	double	width = (double)SvNV(ST(5))
;
	PrintObject*	object;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintRegion *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Region::flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(6)) && (SvTYPE(SvRV(ST(6))) == SVt_PVMG) ) {
        if ( sv_isa(ST(6), Slic3r::perl_class_name(object) ) ||  sv_isa(ST(6), Slic3r::perl_class_name_ref(object) )) {
              object = (PrintObject *)SvIV((SV*)SvRV( ST(6) ));
        } else {
              croak("object is not of type %s (got %s)", Slic3r::perl_class_name(object), HvNAME(SvSTASH(SvRV(ST(6)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Region::flow() -- object is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 64 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = THIS->flow(role, layer_height, bridge, first_layer, width, *object); 
#line 34659 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Flow>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_add_region_volume); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_add_region_volume)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, region_id, volume_id");
    {
	PrintObject *	THIS;
	int	region_id = (int)SvIV(ST(1))
;
	int	volume_id = (int)SvIV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::add_region_volume() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 74 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->add_region_volume( region_id, volume_id );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 34708 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_get_region_volumes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_get_region_volumes)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, region_id");
    {
	PrintObject *	THIS;
	std::vector<int>	RETVAL;
	int	region_id = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::get_region_volumes() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 87 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
            if (0 <= region_id && region_id < THIS->region_volumes.size())
                RETVAL = THIS->region_volumes[region_id];
#line 34741 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSViv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_region_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_region_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::region_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 94 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = THIS->print()->regions.size(); 
#line 34786 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_print); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_print)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	Ref<Print>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::print() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 100 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->print();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 34825 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Print>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_model_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_model_object)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	Ref<ModelObject>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::model_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 114 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->model_object();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 34871 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ModelObject>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	Ref<StaticPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 128 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = &THIS->config; 
#line 34909 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<StaticPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_copies); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_copies)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	Points	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::copies() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 134 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->copies();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 34955 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Points::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_layer_height_ranges); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_layer_height_ranges)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	t_layer_height_ranges	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::layer_height_ranges() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 148 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = THIS->layer_height_ranges; 
#line 34999 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
    RETVALSV = newRV_noinc((SV*)av);
    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
    // map is sorted, so we can just copy it in order
    int i = 0;
    for (t_layer_height_ranges::iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    const coordf_t range_values[] = {
		    it->first.first,    // key's first = minz
		    it->first.second,   // key's second = maxz
		    it->second,	 // value = height
		};
	    AV *rangeAV = newAV();
	    av_extend(rangeAV, 2);
	    for (int j = 0; j < 3; ++j) {
		av_store(rangeAV, j, newSVnv(range_values[j]));
	    }
	    av_store(av, i++, (SV*)newRV_noinc((SV*)rangeAV));
    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_layer_height_spline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_layer_height_spline)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	Ref<LayerHeightSpline>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::layer_height_spline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 154 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = &THIS->layer_height_spline; 
#line 35054 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<LayerHeightSpline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_size); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_size)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	Ref<Point3>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::size() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 160 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = &THIS->size; 
#line 35092 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Point3>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	Clone<BoundingBox>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 166 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 35138 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBox>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object__copies_shift); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object__copies_shift)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	Ref<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::_copies_shift() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 180 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = &THIS->_copies_shift; 
#line 35176 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_support_material_extruders); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_support_material_extruders)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	std::vector<int>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::support_material_extruders() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 186 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
            std::set<size_t> extruders = THIS->support_material_extruders();
            RETVAL.reserve(extruders.size());
            for (std::set<size_t>::const_iterator e = extruders.begin(); e != extruders.end(); ++e) {
                RETVAL.push_back(*e);
            }
#line 35218 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSViv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_extruders); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_extruders)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	std::vector<int>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::extruders() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 196 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
            std::set<size_t> extruders = THIS->extruders();
            RETVAL.reserve(extruders.size());
            for (std::set<size_t>::const_iterator e = extruders.begin(); e != extruders.end(); ++e) {
                RETVAL.push_back(*e);
            }
#line 35266 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSViv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_typed_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_typed_slices)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::typed_slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 206 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = THIS->typed_slices; 
#line 35311 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_set_typed_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_set_typed_slices)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	PrintObject *	THIS;
	bool	value = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::set_typed_slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 212 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     THIS->typed_slices = value; 
#line 35343 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object__shifted_copies); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object__shifted_copies)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	Points	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::_shifted_copies() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 217 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = THIS->_shifted_copies; 
#line 35373 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Points::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_set_shifted_copies); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_set_shifted_copies)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, value");
    {
	PrintObject *	THIS;
	Points	value;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::set_shifted_copies() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        value.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &value[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Print::Object::set_shifted_copies",
	             "value")
;
#line 223 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     THIS->_shifted_copies = value; 
#line 35431 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_add_copy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_add_copy)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	PrintObject *	THIS;
	bool	RETVAL;
	dXSTARG;
	Pointf*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::add_copy() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Pointf *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::add_copy() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 228 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = THIS->add_copy(*point); 
#line 35476 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_delete_last_copy); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_delete_last_copy)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::delete_last_copy() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 234 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->delete_last_copy();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 35516 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_delete_all_copies); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_delete_all_copies)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::delete_all_copies() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 248 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->delete_all_copies();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 35556 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_set_copies); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_set_copies)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, copies");
    {
	PrintObject *	THIS;
	bool	RETVAL;
	dXSTARG;
	Points	copies;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::set_copies() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if (SvROK(ST(1)) && SvTYPE(SvRV(ST(1))) == SVt_PVAV) {
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        copies.resize(len);
        for (unsigned int i = 0; i < len; i++) {
            SV** elem = av_fetch(av, i, 0);
            from_SV_check(*elem, &copies[i]);
        }
    } else
        Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Print::Object::set_copies",
	             "copies")
;
#line 262 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->set_copies( copies );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 35611 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_reload_model_instances); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_reload_model_instances)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::reload_model_instances() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 276 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->reload_model_instances();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 35651 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_set_layer_height_ranges); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_set_layer_height_ranges)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, layer_height_ranges");
    {
	PrintObject *	THIS;
	t_layer_height_ranges	layer_height_ranges;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::set_layer_height_ranges() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    {
        if (!SvROK(ST(1)) || SvTYPE(SvRV(ST(1))) != SVt_PVAV) {
            Perl_croak(aTHX_ "%s: %s is not an array reference",
                     "Slic3r::Print::Object::set_layer_height_ranges",
                     "layer_height_ranges");
        }
        AV* av = (AV*)SvRV(ST(1));
        const unsigned int len = av_len(av)+1;
        t_layer_height_ranges tmp_ranges;
        for (unsigned int i = 0; i < len; i++) {
            SV* elem = *av_fetch(av, i, 0);
            if (!SvROK(elem) || SvTYPE(SvRV(elem)) != SVt_PVAV) {
                Perl_croak(
                    aTHX_ "%s: %s contains something that is not an array reference",
                        "Slic3r::Print::Object::set_layer_height_ranges",
                        "layer_height_ranges");
            }
            AV* elemAV = (AV*)SvRV(elem);
            if (av_len(elemAV) + 1 != 3) {
                Perl_croak(
                    aTHX_ "%s: %s contains an array that isn't 3 elements long",
                        "Slic3r::Print::Object::set_layer_height_ranges",
                        "layer_height_ranges");
            }
            coordf_t vals[3];
            for (unsigned int j = 0; j < 3; ++j) {
                SV *elem_elem = *av_fetch(elemAV, j, 0);
                if (!looks_like_number(elem_elem)) {
                    Perl_croak(
                        aTHX_ "%s: layer ranges and heights must be numbers",
                            "Slic3r::Print::Object::set_layer_height_ranges");
                }
                vals[j] = SvNV(elem_elem);
            }
            tmp_ranges[t_layer_height_range(vals[0], vals[1])] = vals[2];
        }
        layer_height_ranges = tmp_ranges;
    }
;
#line 290 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     THIS->layer_height_ranges = layer_height_ranges; 
#line 35722 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_total_layer_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_total_layer_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::total_layer_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 295 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->total_layer_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 35761 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_layer_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_layer_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::layer_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 309 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->layer_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 35801 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_clear_layers); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_clear_layers)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::clear_layers() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 323 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->clear_layers();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 35839 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_get_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_get_layer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	PrintObject *	THIS;
	Ref<Layer>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::get_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 336 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->get_layer( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 35879 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Layer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_add_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_add_layer)
{
    dVAR; dXSARGS;
    if (items != 5)
       croak_xs_usage(cv,  "THIS, id, height, print_z, slice_z");
    {
	PrintObject *	THIS;
	Ref<Layer>	RETVAL;
	int	id = (int)SvIV(ST(1))
;
	coordf_t	height = (coordf_t)SvNV(ST(2))
;
	coordf_t	print_z = (coordf_t)SvNV(ST(3))
;
	coordf_t	slice_z = (coordf_t)SvNV(ST(4))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::add_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 350 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->add_layer( id, height, print_z, slice_z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 35933 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Layer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_delete_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_delete_layer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	PrintObject *	THIS;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::delete_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 364 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->delete_layer( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 35980 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_support_material_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_support_material_flow)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "THIS, role= frSupportMaterial");
    {
	PrintObject *	THIS;
	Clone<Flow>	RETVAL;
	FlowRole	role;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::support_material_flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 2)
	    role = frSupportMaterial;
	else {
	    role = (FlowRole)SvUV(ST(1))
;
	}
#line 377 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
    role = (FlowRole)SvUV(ST(1));
  ;
      RETVAL = THIS->_support_material_flow( role );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36028 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Flow>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_support_layer_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_support_layer_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::support_layer_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 393 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->support_layer_count();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36075 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_clear_support_layers); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_clear_support_layers)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::clear_support_layers() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 407 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->clear_support_layers();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36113 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_get_support_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_get_support_layer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	PrintObject *	THIS;
	Ref<SupportLayer>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::get_support_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 420 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->get_support_layer( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36153 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<SupportLayer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_add_support_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_add_support_layer)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, id, height, print_z");
    {
	PrintObject *	THIS;
	Ref<SupportLayer>	RETVAL;
	int	id = (int)SvIV(ST(1))
;
	coordf_t	height = (coordf_t)SvNV(ST(2))
;
	coordf_t	print_z = (coordf_t)SvNV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::add_support_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 434 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->add_support_layer( id, height, print_z );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36205 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<SupportLayer>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_delete_support_layer); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_delete_support_layer)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	PrintObject *	THIS;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::delete_support_layer() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 448 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->delete_support_layer( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36252 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_invalidate_step); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_invalidate_step)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, step");
    {
	PrintObject *	THIS;
	bool	RETVAL;
	dXSTARG;
	PrintObjectStep	step = (PrintObjectStep)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::invalidate_step() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 461 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
    step = (PrintObjectStep)SvUV(ST(1));
  ;
      RETVAL = THIS->invalidate_step( step );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36295 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_invalidate_all_steps); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_invalidate_all_steps)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::invalidate_all_steps() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 477 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->invalidate_all_steps();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36335 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_step_done); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_step_done)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, step");
    {
	PrintObject *	THIS;
	bool	RETVAL;
	dXSTARG;
	PrintObjectStep	step = (PrintObjectStep)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::step_done() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 491 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = THIS->state.is_done(step); 
#line 36369 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_set_step_done); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_set_step_done)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, step");
    {
	PrintObject *	THIS;
	PrintObjectStep	step = (PrintObjectStep)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::set_step_done() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 497 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     THIS->state.set_done(step); 
#line 36401 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_set_step_started); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_set_step_started)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, step");
    {
	PrintObject *	THIS;
	PrintObjectStep	step = (PrintObjectStep)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::set_step_started() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 502 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     THIS->state.set_started(step); 
#line 36432 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_detect_surfaces_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_detect_surfaces_type)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::detect_surfaces_type() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 507 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->detect_surfaces_type();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36469 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_process_external_surfaces); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_process_external_surfaces)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::process_external_surfaces() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 520 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->process_external_surfaces();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36506 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_bridge_over_infill); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_bridge_over_infill)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::bridge_over_infill() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 533 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->bridge_over_infill();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36543 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_combine_infill); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_combine_infill)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::combine_infill() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 546 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->combine_infill();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36580 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_discover_horizontal_shells); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_discover_horizontal_shells)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::discover_horizontal_shells() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 559 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->discover_horizontal_shells();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36617 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_clip_fill_surfaces); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_clip_fill_surfaces)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::clip_fill_surfaces() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 572 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->clip_fill_surfaces();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36654 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_slice); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_slice)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::slice() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 585 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->slice();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36691 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object__slice); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object__slice)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::_slice() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 598 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->_slice();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36728 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object__slice_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object__slice_region)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, region_id, z, modifier");
    {
	PrintObject *	THIS;
	SV *	RETVAL;
	size_t	region_id = (size_t)SvUV(ST(1))
;
	std::vector< double >	z;
	bool	modifier = (bool)SvUV(ST(3))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::_slice_region() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (SvROK(ST(2)) && SvTYPE(SvRV(ST(2)))==SVt_PVAV) {
	  AV* av = (AV*)SvRV(ST(2));
	  const unsigned int len = av_len(av)+1;
	  z = std::vector<double>(len);
	  SV** elem;
	  for (unsigned int i = 0; i < len; i++) {
	    elem = av_fetch(av, i, 0);
	    if (elem != NULL)
	      z[i] = SvNV(*elem);
	    else
	      z[i] = 0.;
	  }
	}
	else
	  Perl_croak(aTHX_ "%s: %s is not an array reference",
	             "Slic3r::Print::Object::_slice_region",
	             "z")
;
#line 611 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
            std::vector<float> z_f(z.begin(), z.end());
            std::vector<ExPolygons> layers = THIS->_slice_region(region_id, z_f, modifier);
            AV* layers_av = newAV();
            size_t len = layers.size();
            if (len > 0) av_extend(layers_av, len-1);
            for (unsigned int i = 0; i < layers.size(); i++) {
                AV* expolygons_av = newAV();
                len = layers[i].size();
                if (len > 0) av_extend(expolygons_av, len-1);
                unsigned int j = 0;
                for (ExPolygons::iterator it = layers[i].begin(); it != layers[i].end(); ++it) {
                    av_store(expolygons_av, j++, perl_to_SV_clone_ref(*it));
                }
                av_store(layers_av, i, newRV_noinc((SV*)expolygons_av));
            }
            RETVAL = (SV*)newRV_noinc((SV*)layers_av);
#line 36797 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__Object_make_perimeters); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_make_perimeters)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::make_perimeters() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 632 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->make_perimeters();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36836 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_prepare_infill); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_prepare_infill)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::prepare_infill() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 645 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->prepare_infill();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36873 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_infill); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_infill)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::infill() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 658 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->infill();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36910 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object__simplify_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object__simplify_slices)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	PrintObject *	THIS;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::_simplify_slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 671 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->_simplify_slices( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 36949 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__Object_ptr); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__Object_ptr)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	PrintObject *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (PrintObject *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::Object::ptr() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 684 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = (int)(intptr_t)THIS; 
#line 36980 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Print_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Print *	RETVAL;
#line 696 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = new Print();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37009 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Print_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 713 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37056 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Ref<StaticPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 726 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = &THIS->config; 
#line 37086 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<StaticPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_default_object_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_default_object_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Ref<StaticPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::default_object_config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 732 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = &THIS->default_object_config; 
#line 37124 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<StaticPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_default_region_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_default_region_config)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Ref<StaticPrintConfig>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::default_region_config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 738 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = &THIS->default_region_config; 
#line 37162 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<StaticPrintConfig>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_placeholder_parser); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_placeholder_parser)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Ref<PlaceholderParser>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::placeholder_parser() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 744 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = &THIS->placeholder_parser; 
#line 37200 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<PlaceholderParser>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_skirt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_skirt)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Ref<ExtrusionEntityCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::skirt() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 751 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = &THIS->skirt; 
#line 37238 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExtrusionEntityCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_brim); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_brim)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Ref<ExtrusionEntityCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::brim() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 757 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = &THIS->brim; 
#line 37276 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<ExtrusionEntityCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_objects); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_objects)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	PrintObjectPtrs *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::objects() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 763 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = &THIS->objects; 
#line 37314 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
    RETVALSV = newRV_noinc((SV*)av);
    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL->size();
	    if (len > 0) av_extend(av, len-1);
    int i = 0;
    for (PrintObjectPtrs ::iterator it = RETVAL->begin(); it != RETVAL->end(); ++it) {
	    av_store(av, i++, perl_to_SV_ref(**it));
    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_clear_objects); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_clear_objects)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::clear_objects() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 769 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->clear_objects();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37365 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_get_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_get_object)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	Print *	THIS;
	Ref<PrintObject>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::get_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 782 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->get_object( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37405 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<PrintObject>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_delete_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_delete_object)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	Print *	THIS;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::delete_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 796 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->delete_object( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37452 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_reload_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_reload_object)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	Print *	THIS;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::reload_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 809 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->reload_object( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37491 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_reload_model_instances); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_reload_model_instances)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::reload_model_instances() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 822 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->reload_model_instances();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37530 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_object_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_object_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::object_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 836 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = THIS->objects.size(); 
#line 37562 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_regions); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_regions)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	PrintRegionPtrs *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::regions() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 842 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = &THIS->regions; 
#line 37593 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
    RETVALSV = newRV_noinc((SV*)av);
    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL->size();
	    if (len > 0) av_extend(av, len-1);
    int i = 0;
    for (PrintRegionPtrs ::iterator it = RETVAL->begin(); it != RETVAL->end(); ++it) {
	    av_store(av, i++, perl_to_SV_ref(**it));
    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_get_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_get_region)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, idx");
    {
	Print *	THIS;
	Ref<PrintRegion>	RETVAL;
	int	idx = (int)SvIV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::get_region() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 848 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->get_region( idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37647 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<PrintRegion>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_add_region); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_add_region)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Ref<PrintRegion>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::add_region() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 862 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->add_region();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37693 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<PrintRegion>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_region_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_region_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	size_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::region_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 876 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = THIS->regions.size(); 
#line 37732 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_invalidate_step); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_invalidate_step)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, step");
    {
	Print *	THIS;
	bool	RETVAL;
	dXSTARG;
	PrintStep	step = (PrintStep)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::invalidate_step() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 882 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
    step = (PrintStep)SvUV(ST(1));
  ;
      RETVAL = THIS->invalidate_step( step );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37776 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_invalidate_all_steps); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_invalidate_all_steps)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::invalidate_all_steps() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 898 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->invalidate_all_steps();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 37816 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_step_done); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_step_done)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, step");
    {
	Print *	THIS;
	bool	RETVAL;
	dXSTARG;
	PrintStep	step = (PrintStep)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::step_done() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 912 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = THIS->state.is_done(step); 
#line 37850 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_object_step_done); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_object_step_done)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, step");
    {
	Print *	THIS;
	bool	RETVAL;
	dXSTARG;
	PrintObjectStep	step = (PrintObjectStep)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::object_step_done() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 918 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = THIS->step_done(step); 
#line 37884 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_set_step_done); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_set_step_done)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, step");
    {
	Print *	THIS;
	PrintStep	step = (PrintStep)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::set_step_done() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 924 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     THIS->state.set_done(step); 
#line 37916 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_set_step_started); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_set_step_started)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, step");
    {
	Print *	THIS;
	PrintStep	step = (PrintStep)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::set_step_started() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 929 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     THIS->state.set_started(step); 
#line 37947 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_object_extruders); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_object_extruders)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	std::vector<int>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::object_extruders() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 934 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
            std::set<size_t> extruders = THIS->object_extruders();
            RETVAL.reserve(extruders.size());
            for (std::set<size_t>::const_iterator e = extruders.begin(); e != extruders.end(); ++e) {
                RETVAL.push_back(*e);
            }
#line 37981 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSViv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_support_material_extruders); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_support_material_extruders)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	std::vector<int>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::support_material_extruders() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 944 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
            std::set<size_t> extruders = THIS->support_material_extruders();
            RETVAL.reserve(extruders.size());
            for (std::set<size_t>::const_iterator e = extruders.begin(); e != extruders.end(); ++e) {
                RETVAL.push_back(*e);
            }
#line 38029 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSViv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_extruders); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_extruders)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	std::vector<int>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::extruders() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 954 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
            std::set<size_t> extruders = THIS->extruders();
            RETVAL.reserve(extruders.size());
            for (std::set<size_t>::const_iterator e = extruders.begin(); e != extruders.end(); ++e) {
                RETVAL.push_back(*e);
            }
#line 38077 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSViv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_brim_extruder); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_brim_extruder)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::brim_extruder() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 964 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->brim_extruder();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38130 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_clear_filament_stats); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_clear_filament_stats)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::clear_filament_stats() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 978 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
            THIS->filament_stats.clear();
#line 38160 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_set_filament_stats); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_set_filament_stats)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, extruder_id, length");
    {
	Print *	THIS;
	int	extruder_id = (int)SvIV(ST(1))
;
	float	length = (float)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::set_filament_stats() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 983 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
            THIS->filament_stats.insert(std::pair<size_t,float>(extruder_id, 0));
            THIS->filament_stats[extruder_id] += length;
#line 38194 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_filament_stats); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_filament_stats)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::filament_stats() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 989 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
            HV* hv = newHV();
            for (std::map<size_t,float>::const_iterator it = THIS->filament_stats.begin(); it != THIS->filament_stats.end(); ++it) {
                // stringify extruder_id
                std::ostringstream ss;
                ss << it->first;
                std::string str = ss.str();
                (void)hv_store( hv, str.c_str(), str.length(), newSViv(it->second), 0 );
                RETVAL = newRV_noinc((SV*)hv);
            }
#line 38232 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__simplify_slices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__simplify_slices)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	Print *	THIS;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::_simplify_slices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1003 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->_simplify_slices( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38273 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_max_allowed_layer_height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_max_allowed_layer_height)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::max_allowed_layer_height() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1016 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->max_allowed_layer_height();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38312 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_has_support_material); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_has_support_material)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::has_support_material() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1030 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->has_support_material();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38352 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_auto_assign_extruders); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_auto_assign_extruders)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, model_object");
    {
	Print *	THIS;
	ModelObject*	model_object;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::auto_assign_extruders() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(model_object) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(model_object) )) {
              model_object = (ModelObject *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("model_object is not of type %s (got %s)", Slic3r::perl_class_name(model_object), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::auto_assign_extruders() -- model_object is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1044 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->auto_assign_extruders( model_object );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38404 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_output_filename); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_output_filename)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::output_filename() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1057 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->output_filename();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38442 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_output_filepath); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_output_filepath)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "THIS, path= \"\"");
    {
	Print *	THIS;
	std::string	RETVAL;
	std::string	path;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::output_filepath() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 2)
	    path = "";
	else {
    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      path = std::string(c, len);
    }
;
	}
#line 1071 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->output_filepath( path );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38498 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_add_model_object); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_add_model_object)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, model_object, idx= -1");
    {
	Print *	THIS;
	ModelObject*	model_object;
	int	idx;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::add_model_object() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(model_object) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(model_object) )) {
              model_object = (ModelObject *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("model_object is not of type %s (got %s)", Slic3r::perl_class_name(model_object), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::add_model_object() -- model_object is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    idx = -1;
	else {
	    idx = (int)SvIV(ST(2))
;
	}
#line 1085 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->add_model_object( model_object, idx );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38563 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_apply_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_apply_config)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, config");
    {
	Print *	THIS;
	bool	RETVAL;
	dXSTARG;
	DynamicPrintConfig*	config;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::apply_config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(config) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(config) )) {
              config = (DynamicPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("config is not of type %s (got %s)", Slic3r::perl_class_name(config), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::apply_config() -- config is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1098 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
     RETVAL = THIS->apply_config(*config); 
#line 38608 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_apply_static_config); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_apply_static_config)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, config");
    {
	Print *	THIS;
	bool	RETVAL;
	dXSTARG;
	StaticPrintConfig*	config;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::apply_static_config() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(config) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(config) )) {
              config = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("config is not of type %s (got %s)", Slic3r::perl_class_name(config), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::apply_static_config() -- config is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1104 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
            DynamicPrintConfig dpc;
            dpc.apply(*config);
            RETVAL = THIS->apply_config(dpc);
#line 38656 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_has_infinite_skirt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_has_infinite_skirt)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::has_infinite_skirt() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1112 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->has_infinite_skirt();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38696 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_has_skirt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_has_skirt)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::has_skirt() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1126 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->has_skirt();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38736 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print__validate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__validate)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::_validate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1140 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
            try {
                THIS->validate();
            } catch (std::exception &e) {
                RETVAL = e.what();
            }
#line 38771 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Clone<BoundingBox>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1150 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38815 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBox>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_total_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_total_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Clone<BoundingBox>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::total_bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1164 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->total_bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38861 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBox>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_skirt_first_layer_height); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_skirt_first_layer_height)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::skirt_first_layer_height() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1178 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->skirt_first_layer_height();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38908 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_brim_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_brim_flow)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Clone<Flow>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::brim_flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1192 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->brim_flow();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38947 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Flow>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_skirt_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_skirt_flow)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;
	Clone<Flow>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::skirt_flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1206 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      RETVAL = THIS->skirt_flow();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 38993 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Flow>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_make_skirt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_make_skirt)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::make_skirt() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1220 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->make_skirt();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 39038 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print__make_brim); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print__make_brim)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Print *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::_make_brim() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1233 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
    try {
      THIS->_make_brim();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 39075 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Print_total_used_filament); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_total_used_filament)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	Print *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::total_used_filament() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1248 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
        if (items > 1) {
            THIS->total_used_filament = (double)SvNV(ST(1));
        }
        RETVAL = THIS->total_used_filament;
#line 39109 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_total_extruded_volume); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_total_extruded_volume)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	Print *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::total_extruded_volume() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1258 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
        if (items > 1) {
            THIS->total_extruded_volume = (double)SvNV(ST(1));
        }
        RETVAL = THIS->total_extruded_volume;
#line 39144 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_total_weight); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_total_weight)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	Print *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::total_weight() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1269 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
        if (items > 1) {
            THIS->total_weight = (double)SvNV(ST(1));
        }
        RETVAL = THIS->total_weight;
#line 39179 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Print_total_cost); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Print_total_cost)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	Print *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Print *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Print::total_cost() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 1279 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Print.xsp\""
        if (items > 1) {
            THIS->total_cost = (double)SvNV(ST(1));
        }
        RETVAL = THIS->total_cost;
#line 39214 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Print.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/ExtrusionEntity.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__ExtrusionLoop_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	ExtrusionLoop *	RETVAL;
#line 21 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
    try {
      RETVAL = new ExtrusionLoop();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 39255 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__ExtrusionLoop_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 39302 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	Clone<ExtrusionLoop>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
     RETVAL = THIS; 
#line 39332 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<ExtrusionLoop>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_reverse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_reverse)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::reverse() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 57 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
    try {
      THIS->reverse();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 39377 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_make_clockwise); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_make_clockwise)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::make_clockwise() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 70 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
    try {
      RETVAL = THIS->make_clockwise();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 39416 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_make_counter_clockwise); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_make_counter_clockwise)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::make_counter_clockwise() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 84 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
    try {
      RETVAL = THIS->make_counter_clockwise();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 39456 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_first_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_first_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::first_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 98 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
    try {
      RETVAL = THIS->first_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 39495 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_last_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_last_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::last_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 112 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
    try {
      RETVAL = THIS->last_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 39541 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_polygon); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_polygon)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	Clone<Polygon>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::polygon() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 126 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
    try {
      RETVAL = THIS->polygon();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 39587 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polygon>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_append); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_append)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, path");
    {
	ExtrusionLoop *	THIS;
	ExtrusionPath*	path;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::append() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(path) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(path) )) {
              path = (ExtrusionPath *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("path is not of type %s (got %s)", Slic3r::perl_class_name(path), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::append() -- path is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 140 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
     THIS->paths.push_back(*path); 
#line 39638 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_length); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_length)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::length() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 145 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
    try {
      RETVAL = THIS->length();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 39677 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_split_at_vertex); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_split_at_vertex)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	ExtrusionLoop *	THIS;
	bool	RETVAL;
	dXSTARG;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::split_at_vertex() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::split_at_vertex() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 159 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
     RETVAL = THIS->split_at_vertex(*point); 
#line 39723 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_split_at); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_split_at)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "THIS, point, prefer_non_overhang= 0");
    {
	ExtrusionLoop *	THIS;
	Point*	point;
	int	prefer_non_overhang;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::split_at() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::split_at() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

	if (items < 3)
	    prefer_non_overhang = 0;
	else {
	    prefer_non_overhang = (int)SvIV(ST(2))
;
	}
#line 165 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
     THIS->split_at(*point, prefer_non_overhang != 0); 
#line 39775 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_clip_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_clip_end)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	ExtrusionLoop *	THIS;
	ExtrusionPaths	RETVAL;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::clip_end() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 170 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
     THIS->clip_end(distance, &RETVAL); 
#line 39807 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExtrusionPaths::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_has_overhang_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_has_overhang_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	ExtrusionLoop *	THIS;
	bool	RETVAL;
	dXSTARG;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::has_overhang_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::has_overhang_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 176 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
     RETVAL = THIS->has_overhang_point(*point); 
#line 39866 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_is_perimeter); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_is_perimeter)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::is_perimeter() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 182 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
    try {
      RETVAL = THIS->is_perimeter();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 39906 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_is_infill); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_is_infill)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::is_infill() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 196 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
    try {
      RETVAL = THIS->is_infill();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 39946 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_is_solid_infill); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_is_solid_infill)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::is_solid_infill() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 210 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
    try {
      RETVAL = THIS->is_solid_infill();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 39986 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_grow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_grow)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::grow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 224 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
    try {
      RETVAL = THIS->grow();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 40025 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_as_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_as_polyline)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	Clone<Polyline>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::as_polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 238 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
    try {
      RETVAL = THIS->as_polyline();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 40077 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionLoop *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 254 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
        AV* av = newAV();
        if (!THIS->paths.empty()) av_extend(av, THIS->paths.size()-1);
        for (ExtrusionPaths::iterator it = THIS->paths.begin(); it != THIS->paths.end(); ++it) {
            av_store(av, it - THIS->paths.begin(), perl_to_SV_ref(*it));
        }
        RETVAL = newRV_noinc((SV*)av);
#line 40120 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop_role); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop_role)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	ExtrusionLoop *	THIS;
	ExtrusionLoopRole	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionLoop *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionLoop::role() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 266 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
        if (items > 1) {
            THIS->role = (ExtrusionLoopRole)SvUV(ST(1));
        }
        RETVAL = THIS->role;
#line 40156 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionLoop__constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionLoop__constant)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	IV	RETVAL;
	dXSTARG;
#line 288 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp\""
    RETVAL = ix;
#line 40175 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/ExtrusionLoop.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/BridgeDetector.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/BridgeDetector.hpp"

XS_EUPXS(XS_Slic3r__BridgeDetector_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BridgeDetector *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BridgeDetector *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 18 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BridgeDetector.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 40225 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__BridgeDetector_detect_angle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_detect_angle)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BridgeDetector *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BridgeDetector *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::detect_angle() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 31 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BridgeDetector.xsp\""
    try {
      RETVAL = THIS->detect_angle();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 40264 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__BridgeDetector_coverage); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_coverage)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BridgeDetector *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BridgeDetector *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::coverage() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 45 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BridgeDetector.xsp\""
    try {
      RETVAL = THIS->coverage();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 40303 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__BridgeDetector_coverage_by_angle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_coverage_by_angle)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	BridgeDetector *	THIS;
	Polygons	RETVAL;
	double	angle = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BridgeDetector *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::coverage_by_angle() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 59 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BridgeDetector.xsp\""
    try {
      RETVAL = THIS->coverage( angle );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 40357 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__BridgeDetector_unsupported_edges); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_unsupported_edges)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BridgeDetector *	THIS;
	Polylines	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BridgeDetector *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::unsupported_edges() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 73 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BridgeDetector.xsp\""
    try {
      RETVAL = THIS->unsupported_edges();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 40409 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polylines::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__BridgeDetector_unsupported_edges_by_angle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_unsupported_edges_by_angle)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	BridgeDetector *	THIS;
	Polylines	RETVAL;
	double	angle = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BridgeDetector *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::unsupported_edges_by_angle() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 87 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BridgeDetector.xsp\""
    try {
      RETVAL = THIS->unsupported_edges( angle );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 40463 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polylines::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__BridgeDetector_angle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_angle)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BridgeDetector *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BridgeDetector *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::angle() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 101 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BridgeDetector.xsp\""
     RETVAL = THIS->angle; 
#line 40508 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__BridgeDetector_resolution); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_resolution)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	BridgeDetector *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (BridgeDetector *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::resolution() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 107 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BridgeDetector.xsp\""
     RETVAL = THIS->resolution; 
#line 40540 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__BridgeDetector_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__BridgeDetector_new)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "CLASS, expolygon, lower_slices, extrusion_width");
    {
	ExPolygon*	expolygon;
	ExPolygonCollection*	lower_slices;
	long	extrusion_width = (long)SvIV(ST(3))
;
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	BridgeDetector *	RETVAL;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(expolygon) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(expolygon) )) {
              expolygon = (ExPolygon *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("expolygon is not of type %s (got %s)", Slic3r::perl_class_name(expolygon), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::new() -- expolygon is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(lower_slices) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(lower_slices) )) {
              lower_slices = (ExPolygonCollection *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("lower_slices is not of type %s (got %s)", Slic3r::perl_class_name(lower_slices), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::BridgeDetector::new() -- lower_slices is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 118 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/BridgeDetector.xsp\""
        RETVAL = new BridgeDetector(*expolygon, *lower_slices, extrusion_width);
#line 40589 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/BridgeDetector.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/ExtrusionEntityCollection.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection__new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection__new)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "CLASS");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	ExtrusionEntityCollection *	RETVAL;
#line 21 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
    try {
      RETVAL = new ExtrusionEntityCollection();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 40637 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 38 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 40684 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	Clone<ExtrusionEntityCollection>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
     RETVAL = THIS->clone(); 
#line 40714 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<ExtrusionEntityCollection>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_reverse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_reverse)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::reverse() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 57 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
    try {
      THIS->reverse();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 40759 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_clear); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_clear)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::clear() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 70 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
     THIS->entities.clear(); 
#line 40788 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_chained_path); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_chained_path)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, no_reverse");
    {
	ExtrusionEntityCollection *	THIS;
	ExtrusionEntityCollection *	RETVAL;
	bool	no_reverse = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::chained_path() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 75 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
            RETVAL = new ExtrusionEntityCollection();
            THIS->chained_path(RETVAL, no_reverse);
#line 40821 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_chained_path_from); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_chained_path_from)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, start_near, no_reverse");
    {
	ExtrusionEntityCollection *	THIS;
	ExtrusionEntityCollection *	RETVAL;
	Point*	start_near;
	bool	no_reverse = (bool)SvUV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::chained_path_from() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(start_near) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(start_near) )) {
              start_near = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("start_near is not of type %s (got %s)", Slic3r::perl_class_name(start_near), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::chained_path_from() -- start_near is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 82 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
            RETVAL = new ExtrusionEntityCollection();
            THIS->chained_path_from(*start_near, RETVAL, no_reverse);
#line 40876 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_first_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_first_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::first_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 89 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
    try {
      RETVAL = THIS->first_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 40922 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_last_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_last_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::last_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 103 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
    try {
      RETVAL = THIS->last_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 40968 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 117 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
     RETVAL = THIS->entities.size(); 
#line 41007 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_items_count); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_items_count)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::items_count() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 123 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
     RETVAL = THIS->items_count(); 
#line 41039 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_flatten); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_flatten)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	ExtrusionEntityCollection *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::flatten() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 129 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
            RETVAL = new ExtrusionEntityCollection();
            THIS->flatten(RETVAL);
#line 41071 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_min_mm3_per_mm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_min_mm3_per_mm)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::min_mm3_per_mm() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 136 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
    try {
      RETVAL = THIS->min_mm3_per_mm();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 41118 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_empty); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_empty)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::empty() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 150 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
     RETVAL = THIS->entities.empty(); 
#line 41150 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_orig_indices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_orig_indices)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	std::vector<size_t>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::orig_indices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 156 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
     RETVAL = THIS->orig_indices; 
#line 41181 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len)
	      av_extend(av, len-1);
	    for (unsigned int i = 0; i < len; i++) {
	      av_store(av, i, newSViv(RETVAL[i]));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_grow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_grow)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::grow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 162 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
    try {
      RETVAL = THIS->grow();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 41233 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExtrusionEntityCollection *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 178 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
        AV* av = newAV();
        av_fill(av, THIS->entities.size()-1);
        int i = 0;
        for (ExtrusionEntitiesPtr::iterator it = THIS->entities.begin(); it != THIS->entities.end(); ++it) {
            SV* sv = newSV(0);
            // return our item by reference
            if (ExtrusionPath* path = dynamic_cast<ExtrusionPath*>(*it)) {
                sv_setref_pv( sv, perl_class_name_ref(path), path );
            } else if (ExtrusionLoop* loop = dynamic_cast<ExtrusionLoop*>(*it)) {
                sv_setref_pv( sv, perl_class_name_ref(loop), loop );
            } else if (ExtrusionEntityCollection* collection = dynamic_cast<ExtrusionEntityCollection*>(*it)) {
                sv_setref_pv( sv, perl_class_name_ref(collection), collection );
            } else {
                croak("Unexpected type in ExtrusionEntityCollection");
            }
            av_store(av, i++, sv);
        }
        RETVAL = newRV_noinc((SV*)av);
#line 41294 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_append); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_append)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	ExtrusionEntityCollection *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::append() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 202 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
        for (unsigned int i = 1; i < items; i++) {
            if(!sv_isobject( ST(i) ) || (SvTYPE(SvRV( ST(i) )) != SVt_PVMG)) {
                croak("Argument %d is not object", i);
            }
            ExtrusionEntity* entity = (ExtrusionEntity *)SvIV((SV*)SvRV( ST(i) ));
            // append COPIES
            if (ExtrusionPath* path = dynamic_cast<ExtrusionPath*>(entity)) {
                THIS->entities.push_back( new ExtrusionPath(*path) );
            } else if (ExtrusionLoop* loop = dynamic_cast<ExtrusionLoop*>(entity)) {
                THIS->entities.push_back( new ExtrusionLoop(*loop) );
            } else if(ExtrusionEntityCollection* collection = dynamic_cast<ExtrusionEntityCollection*>(entity)) {
                THIS->entities.push_back( collection->clone() );
            } else {
                croak("Argument %d is of unknown type", i);
            }
        }
#line 41340 "buildtmp/XS.c"
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_no_sort); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_no_sort)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	ExtrusionEntityCollection *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::no_sort() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 222 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
        if (items > 1) {
            THIS->no_sort = SvTRUE(ST(1));
        }
        RETVAL = THIS->no_sort;
#line 41374 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_chained_path_indices); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExtrusionPath__Collection_chained_path_indices)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, no_reverse");
    {
	ExtrusionEntityCollection *	THIS;
	ExtrusionEntityCollection *	RETVAL;
	bool	no_reverse = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExtrusionEntityCollection *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExtrusionPath::Collection::chained_path_indices() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 232 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp\""
        RETVAL = new ExtrusionEntityCollection();
        THIS->chained_path(RETVAL, no_reverse, &RETVAL->orig_indices);
#line 41408 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/ExtrusionEntityCollection.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/BoundingBox.hpp"
#include "libslic3r/ClipperUtils.hpp"
#include "libslic3r/Polyline.hpp"

XS_EUPXS(XS_Slic3r__Polyline_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 20 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 41467 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	Clone<Polyline>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 33 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
     RETVAL = THIS; 
#line 41497 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Polyline>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 39 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
     RETVAL = to_AV(THIS); 
#line 41535 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 45 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
     RETVAL = to_SV_pureperl(THIS); 
#line 41567 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	Polyline *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 51 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 41608 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_translate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, x, y");
    {
	Polyline *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 64 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      THIS->translate( x, y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 41649 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_pop_back); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_pop_back)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::pop_back() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 77 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
     THIS->points.pop_back(); 
#line 41678 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_reverse); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_reverse)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::reverse() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 82 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      THIS->reverse();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 41715 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_lines); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_lines)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	Lines	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::lines() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 95 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      RETVAL = THIS->lines();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 41753 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Lines::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_first_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_first_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::first_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 109 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      RETVAL = THIS->first_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 41805 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_last_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_last_point)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	Clone<Point>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::last_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 123 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      RETVAL = THIS->last_point();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 41851 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<Point>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_equally_spaced_points); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_equally_spaced_points)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	Polyline *	THIS;
	Points	RETVAL;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::equally_spaced_points() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 137 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      RETVAL = THIS->equally_spaced_points( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 41899 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Points::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_length); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_length)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::length() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 151 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      RETVAL = THIS->length();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 41952 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_is_valid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_is_valid)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::is_valid() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 165 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      RETVAL = THIS->is_valid();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 41992 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_clip_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_clip_end)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	Polyline *	THIS;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::clip_end() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 179 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      THIS->clip_end( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 42032 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_clip_start); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_clip_start)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	Polyline *	THIS;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::clip_start() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 192 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      THIS->clip_start( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 42071 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_extend_end); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_extend_end)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	Polyline *	THIS;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::extend_end() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 205 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      THIS->extend_end( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 42110 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_extend_start); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_extend_start)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, distance");
    {
	Polyline *	THIS;
	double	distance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::extend_start() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 218 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      THIS->extend_start( distance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 42149 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_simplify); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_simplify)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, tolerance");
    {
	Polyline *	THIS;
	double	tolerance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::simplify() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 231 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      THIS->simplify( tolerance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 42188 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_simplify_by_visibility); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_simplify_by_visibility)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, expolygon");
    {
	Polyline *	THIS;
	ExPolygon*	expolygon;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::simplify_by_visibility() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(expolygon) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(expolygon) )) {
              expolygon = (ExPolygon *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("expolygon is not of type %s (got %s)", Slic3r::perl_class_name(expolygon), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::simplify_by_visibility() -- expolygon is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 244 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
     THIS->simplify_by_visibility(*expolygon); 
#line 42231 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_split_at); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_split_at)
{
    dVAR; dXSARGS;
    if (items != 4)
       croak_xs_usage(cv,  "THIS, point, p1, p2");
    {
	Polyline *	THIS;
	Point*	point;
	Polyline*	p1;
	Polyline*	p2;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::split_at() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::split_at() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(p1) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(p1) )) {
              p1 = (Polyline *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("p1 is not of type %s (got %s)", Slic3r::perl_class_name(p1), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::split_at() -- p1 is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(3)) && (SvTYPE(SvRV(ST(3))) == SVt_PVMG) ) {
        if ( sv_isa(ST(3), Slic3r::perl_class_name(p2) ) ||  sv_isa(ST(3), Slic3r::perl_class_name_ref(p2) )) {
              p2 = (Polyline *)SvIV((SV*)SvRV( ST(3) ));
        } else {
              croak("p2 is not of type %s (got %s)", Slic3r::perl_class_name(p2), HvNAME(SvSTASH(SvRV(ST(3)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::split_at() -- p2 is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 249 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
     THIS->split_at(*point, p1, p2); 
#line 42302 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_is_straight); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_is_straight)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::is_straight() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 254 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      RETVAL = THIS->is_straight();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 42341 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	Clone<BoundingBox>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 268 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      RETVAL = THIS->bounding_box();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 42380 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<BoundingBox>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_remove_duplicate_points); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_remove_duplicate_points)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::remove_duplicate_points() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 282 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      THIS->remove_duplicate_points();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 42425 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_wkt); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_wkt)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Polyline *	THIS;
	std::string	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::wkt() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 295 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
    try {
      RETVAL = THIS->wkt();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 42463 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
    RETVALSV = newSVpvn_utf8( RETVAL.c_str(), RETVAL.length(), true );
	    RETVALSV = sv_2mortal(RETVALSV);
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_new)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "CLASS, ...");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Polyline *	RETVAL;
#line 311 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
        RETVAL = new Polyline ();
        // ST(0) is class name, ST(1) is first point
        RETVAL->points.resize(items-1);
        for (unsigned int i = 1; i < items; i++) {
            from_SV_check(ST(i), &RETVAL->points[i-1]);
        }
#line 42492 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Polyline_append); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_append)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "THIS, ...");
    {
	Polyline *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::append() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 323 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
        for (unsigned int i = 1; i < items; i++) {
            Point p;
            from_SV_check(ST(i), &p);
            THIS->points.push_back(p);
        }
#line 42533 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_append_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_append_polyline)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, polyline");
    {
	Polyline*	polyline;
	Polyline *	THIS;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(polyline) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(polyline) )) {
              polyline = (Polyline *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("polyline is not of type %s (got %s)", Slic3r::perl_class_name(polyline), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::append_polyline() -- polyline is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::append_polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 333 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
        for (Points::const_iterator it = polyline->points.begin(); it != polyline->points.end(); ++it) {
            THIS->points.push_back((*it));
        }
#line 42578 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_rotate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, angle, center_sv");
    {
	double	angle = (double)SvNV(ST(1))
;
	SV*	center_sv = ST(2)
;
	Polyline *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::rotate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 342 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
        Point center;
        from_SV_check(center_sv, &center);
        THIS->rotate(angle, center);
#line 42613 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Polyline_grow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Polyline_grow)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 5)
       croak_xs_usage(cv,  "THIS, delta, scale = CLIPPER_OFFSET_SCALE, joinType = ClipperLib::jtSquare, miterLimit = 3");
    {
	const float	delta = (const float)SvNV(ST(1))
;
	double	scale;
	ClipperLib::JoinType	joinType;
	double	miterLimit;
	Polyline *	THIS;
	Polygons	RETVAL;

	if (items < 3)
	    scale = CLIPPER_OFFSET_SCALE;
	else {
	    scale = (double)SvNV(ST(2))
;
	}

	if (items < 4)
	    joinType = ClipperLib::jtSquare;
	else {
	    joinType = (ClipperLib::JoinType)SvUV(ST(3))
;
	}

	if (items < 5)
	    miterLimit = 3;
	else {
	    miterLimit = (double)SvNV(ST(4))
;
	}

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Polyline *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Polyline::grow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 353 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp\""
        RETVAL = offset(*THIS, delta, scale, joinType, miterLimit);
#line 42669 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Polyline.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/ExPolygon.hpp"

XS_EUPXS(XS_Slic3r__ExPolygon_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 18 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 42732 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExPolygon_clone); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_clone)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;
	Clone<ExPolygon>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::clone() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 31 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
     RETVAL = THIS; 
#line 42762 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Clone<ExPolygon>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_arrayref); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_arrayref)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::arrayref() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 37 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
     RETVAL = to_AV(THIS); 
#line 42800 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;
	SV *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 43 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
     RETVAL = to_SV_pureperl(THIS); 
#line 42832 "buildtmp/XS.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_contour); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_contour)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;
	Ref<Polygon>	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::contour() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 49 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
     RETVAL = &(THIS->contour); 
#line 42864 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Ref<Polygon>::CLASS(), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_holes); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_holes)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;
	Polygons *	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::holes() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 55 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
     RETVAL = &(THIS->holes); 
#line 42902 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL->size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons ::iterator it = RETVAL->begin(); it != RETVAL->end(); ++it) {
	    av_store(av, i++, perl_to_SV_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_scale); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_scale)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, factor");
    {
	ExPolygon *	THIS;
	double	factor = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::scale() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 61 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
    try {
      THIS->scale( factor );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 42955 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExPolygon_translate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_translate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, x, y");
    {
	ExPolygon *	THIS;
	double	x = (double)SvNV(ST(1))
;
	double	y = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::translate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 74 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
    try {
      THIS->translate( x, y );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 42996 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__ExPolygon_area); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_area)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::area() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 87 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
    try {
      RETVAL = THIS->area();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 43035 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_is_valid); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_is_valid)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::is_valid() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 101 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
    try {
      RETVAL = THIS->is_valid();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 43075 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_contains_line); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_contains_line)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, line");
    {
	ExPolygon *	THIS;
	bool	RETVAL;
	dXSTARG;
	Line*	line;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::contains_line() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(line) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(line) )) {
              line = (Line *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("line is not of type %s (got %s)", Slic3r::perl_class_name(line), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::contains_line() -- line is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 115 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
     RETVAL = THIS->contains(*line); 
#line 43121 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_contains_polyline); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_contains_polyline)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, polyline");
    {
	ExPolygon *	THIS;
	bool	RETVAL;
	dXSTARG;
	Polyline*	polyline;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::contains_polyline() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(polyline) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(polyline) )) {
              polyline = (Polyline *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("polyline is not of type %s (got %s)", Slic3r::perl_class_name(polyline), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::contains_polyline() -- polyline is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 121 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
     RETVAL = THIS->contains(*polyline); 
#line 43167 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_contains_point); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_contains_point)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, point");
    {
	ExPolygon *	THIS;
	bool	RETVAL;
	dXSTARG;
	Point*	point;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::contains_point() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(point) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(point) )) {
              point = (Point *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("point is not of type %s (got %s)", Slic3r::perl_class_name(point), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::contains_point() -- point is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 127 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
     RETVAL = THIS->contains(*point); 
#line 43213 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_simplify); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_simplify)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, tolerance");
    {
	ExPolygon *	THIS;
	ExPolygons	RETVAL;
	double	tolerance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::simplify() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 133 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
    try {
      RETVAL = THIS->simplify( tolerance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 43254 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (ExPolygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_simplify_p); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_simplify_p)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, tolerance");
    {
	ExPolygon *	THIS;
	Polygons	RETVAL;
	double	tolerance = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::simplify_p() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 147 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
    try {
      RETVAL = THIS->simplify_p( tolerance );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 43308 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_medial_axis); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_medial_axis)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, max_width, min_width");
    {
	ExPolygon *	THIS;
	Polylines	RETVAL;
	double	max_width = (double)SvNV(ST(1))
;
	double	min_width = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::medial_axis() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 161 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
     THIS->medial_axis(max_width, min_width, &RETVAL); 
#line 43356 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polylines::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_get_trapezoids); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_get_trapezoids)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	ExPolygon *	THIS;
	Polygons	RETVAL;
	double	angle = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::get_trapezoids() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 167 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
     THIS->get_trapezoids(&RETVAL, angle); 
#line 43402 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_get_trapezoids2); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_get_trapezoids2)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	ExPolygon *	THIS;
	Polygons	RETVAL;
	double	angle = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::get_trapezoids2() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 173 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
     THIS->get_trapezoids2(&RETVAL, angle); 
#line 43448 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_triangulate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_triangulate)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::triangulate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 179 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
     THIS->triangulate(&RETVAL); 
#line 43492 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_triangulate_pp); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_triangulate_pp)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	ExPolygon *	THIS;
	Polygons	RETVAL;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::triangulate_pp() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 185 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
     THIS->triangulate_pp(&RETVAL); 
#line 43536 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    AV* av = newAV();
	    RETVALSV = newRV_noinc((SV*)av);
	    sv_2mortal(RETVALSV);
	    const unsigned int len = RETVAL.size();
	    if (len > 0) av_extend(av, len-1);
	    int i = 0;
    for (Polygons::const_iterator it = RETVAL.begin(); it != RETVAL.end(); ++it) {
	    av_store(av, i++, perl_to_SV_clone_ref(*it));
	    }
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_new)
{
    dVAR; dXSARGS;
    if (items < 1)
       croak_xs_usage(cv,  "CLASS, ...");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	ExPolygon *	RETVAL;
#line 193 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
        RETVAL = new ExPolygon ();
        // ST(0) is class name, ST(1) is contour and others are holes
        from_SV_check(ST(1), &RETVAL->contour);
        RETVAL->holes.resize(items-2);
        for (unsigned int i = 2; i < items; i++) {
            from_SV_check(ST(i), &RETVAL->holes[i-2]);
        }
#line 43574 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__ExPolygon_rotate); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__ExPolygon_rotate)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, angle, center_sv");
    {
	double	angle = (double)SvNV(ST(1))
;
	SV*	center_sv = ST(2)
;
	ExPolygon *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (ExPolygon *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::ExPolygon::rotate() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 208 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp\""
        Point center;
        from_SV_check(center_sv, &center);
        THIS->rotate(angle, center);
#line 43617 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/ExPolygon.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/Extruder.hpp"
#undef  xsp_constructor_class
#define xsp_constructor_class(c) (CLASS)

XS_EUPXS(XS_Slic3r__Extruder_new); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_new)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "CLASS, id, config");
    {
	char *	CLASS = (char *)SvPV_nolen(ST(0))
;
	Extruder *	RETVAL;
	unsigned int	id = (unsigned int)SvUV(ST(1))
;
	StaticPrintConfig*	config;

    if( sv_isobject(ST(2)) && (SvTYPE(SvRV(ST(2))) == SVt_PVMG) ) {
        if ( sv_isa(ST(2), Slic3r::perl_class_name(config) ) ||  sv_isa(ST(2), Slic3r::perl_class_name_ref(config) )) {
              config = (StaticPrintConfig *)SvIV((SV*)SvRV( ST(2) ));
        } else {
              croak("config is not of type %s (got %s)", Slic3r::perl_class_name(config), HvNAME(SvSTASH(SvRV(ST(2)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::new() -- config is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 21 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
     RETVAL = new Extruder (id, dynamic_cast<GCodeConfig*>(config)); 
#line 43665 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)

XS_EUPXS(XS_Slic3r__Extruder_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 30 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 43712 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Extruder_reset); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_reset)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::reset() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 43 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
    try {
      THIS->reset();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 43749 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Extruder_extrude); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_extrude)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, dE");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;
	double	dE = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::extrude() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 56 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
    try {
      RETVAL = THIS->extrude( dE );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 43790 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_retract); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_retract)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "THIS, length, restart_extra");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;
	double	length = (double)SvNV(ST(1))
;
	double	restart_extra = (double)SvNV(ST(2))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::retract() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 70 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
    try {
      RETVAL = THIS->retract( length, restart_extra );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 43834 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_unretract); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_unretract)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::unretract() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 84 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
    try {
      RETVAL = THIS->unretract();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 43874 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_e_per_mm); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_e_per_mm)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, mm3_per_mm");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;
	double	mm3_per_mm = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::e_per_mm() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 98 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
    try {
      RETVAL = THIS->e_per_mm( mm3_per_mm );
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 43916 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_extruded_volume); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_extruded_volume)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::extruded_volume() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 112 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
    try {
      RETVAL = THIS->extruded_volume();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 43956 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_used_filament); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_used_filament)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::used_filament() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 126 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
    try {
      RETVAL = THIS->used_filament();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 43996 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_id)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	unsigned int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 140 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
     RETVAL = THIS->id; 
#line 44028 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_E); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_E)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::E() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 146 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
     RETVAL = THIS->E; 
#line 44060 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_set_E); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_set_E)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::set_E() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 152 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
     RETVAL = THIS->E = val; 
#line 44094 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_absolute_E); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_absolute_E)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::absolute_E() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 158 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
     RETVAL = THIS->absolute_E; 
#line 44126 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_set_absolute_E); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_set_absolute_E)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::set_absolute_E() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 164 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
     RETVAL = THIS->absolute_E = val; 
#line 44160 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_retracted); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_retracted)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::retracted() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 170 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
     RETVAL = THIS->retracted; 
#line 44192 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_set_retracted); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_set_retracted)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::set_retracted() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 176 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
     RETVAL = THIS->retracted = val; 
#line 44226 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_restart_extra); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_restart_extra)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::restart_extra() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 182 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
     RETVAL = THIS->restart_extra; 
#line 44258 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_set_restart_extra); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_set_restart_extra)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, val");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;
	double	val = (double)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::set_restart_extra() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 188 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
     RETVAL = THIS->restart_extra = val; 
#line 44292 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_e_per_mm3); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_e_per_mm3)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::e_per_mm3() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 194 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
     RETVAL = THIS->e_per_mm3; 
#line 44324 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_retract_speed_mm_min); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_retract_speed_mm_min)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::retract_speed_mm_min() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 200 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
     RETVAL = THIS->retract_speed_mm_min; 
#line 44356 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_filament_diameter); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_filament_diameter)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::filament_diameter() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 206 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
    try {
      RETVAL = THIS->filament_diameter();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 44396 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_filament_density); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_filament_density)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::filament_density() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 220 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
    try {
      RETVAL = THIS->filament_density();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 44436 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_filament_cost); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_filament_cost)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::filament_cost() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 234 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
    try {
      RETVAL = THIS->filament_cost();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 44476 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_extrusion_multiplier); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_extrusion_multiplier)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::extrusion_multiplier() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 248 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
    try {
      RETVAL = THIS->extrusion_multiplier();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 44516 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_retract_length); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_retract_length)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::retract_length() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 262 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
    try {
      RETVAL = THIS->retract_length();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 44556 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_retract_lift); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_retract_lift)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::retract_lift() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 276 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
    try {
      RETVAL = THIS->retract_lift();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 44596 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_retract_speed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_retract_speed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	int	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::retract_speed() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 290 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
    try {
      RETVAL = THIS->retract_speed();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 44636 "buildtmp/XS.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_retract_restart_extra); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_retract_restart_extra)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::retract_restart_extra() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 304 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
    try {
      RETVAL = THIS->retract_restart_extra();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 44676 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_retract_length_toolchange); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_retract_length_toolchange)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::retract_length_toolchange() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 318 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
    try {
      RETVAL = THIS->retract_length_toolchange();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 44716 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Extruder_retract_restart_extra_toolchange); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Extruder_retract_restart_extra_toolchange)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Extruder *	THIS;
	double	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Extruder *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Extruder::retract_restart_extra_toolchange() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 332 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp\""
    try {
      RETVAL = THIS->retract_restart_extra_toolchange();
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 44756 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Extruder.xsp"' */


/* INCLUDE_COMMAND:  Including output of '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Filler.xsp"' from 'main.xs' */

#include <exception>

#undef  xsp_constructor_class
#define xsp_constructor_class(c) (c)
#include <xsinit.h>
#include "libslic3r/Fill/Fill.hpp"
#include "libslic3r/PolylineCollection.hpp"
#include "libslic3r/ExtrusionEntity.hpp"
#include "libslic3r/ExtrusionEntityCollection.hpp"

XS_EUPXS(XS_Slic3r__Filler_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Filler *	THIS;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::DESTROY() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 21 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
    try {
      delete THIS;
    }
    catch (std::exception& e) {
      croak("Caught C++ exception of type or derived from 'std::exception': %s", e.what());
    }
    catch (...) {
      croak("Caught C++ exception of unknown type");
    }
#line 44809 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_set_bounding_box); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_bounding_box)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, bbox");
    {
	Filler *	THIS;
	BoundingBox*	bbox;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_bounding_box() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(bbox) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(bbox) )) {
              bbox = (BoundingBox *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("bbox is not of type %s (got %s)", Slic3r::perl_class_name(bbox), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_bounding_box() -- bbox is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 34 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
     THIS->fill->bounding_box = *bbox; 
#line 44852 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_set_min_spacing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_min_spacing)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, spacing");
    {
	Filler *	THIS;
	coordf_t	spacing = (coordf_t)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_min_spacing() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 39 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
     THIS->fill->min_spacing = spacing; 
#line 44883 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_min_spacing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_min_spacing)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Filler *	THIS;
	coordf_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::min_spacing() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 44 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
     RETVAL = THIS->fill->min_spacing; 
#line 44914 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Filler_spacing); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_spacing)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Filler *	THIS;
	coordf_t	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::spacing() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 50 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
     RETVAL = THIS->fill->spacing(); 
#line 44946 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Filler_set_endpoints_overlap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_endpoints_overlap)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, overlap");
    {
	Filler *	THIS;
	float	overlap = (float)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_endpoints_overlap() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 56 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
     THIS->fill->endpoints_overlap = overlap; 
#line 44978 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_endpoints_overlap); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_endpoints_overlap)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Filler *	THIS;
	float	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::endpoints_overlap() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 61 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
     RETVAL = THIS->fill->endpoints_overlap; 
#line 45009 "buildtmp/XS.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Filler_set_layer_id); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_layer_id)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, layer_id");
    {
	Filler *	THIS;
	size_t	layer_id = (size_t)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_layer_id() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 67 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
     THIS->fill->layer_id = layer_id; 
#line 45041 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_set_z); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_z)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, z");
    {
	Filler *	THIS;
	coordf_t	z = (coordf_t)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_z() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 72 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
     THIS->fill->z = z; 
#line 45072 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_set_angle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_angle)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, angle");
    {
	Filler *	THIS;
	float	angle = (float)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_angle() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 77 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
     THIS->fill->angle = angle; 
#line 45103 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_set_link_max_length); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_link_max_length)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, len");
    {
	Filler *	THIS;
	coordf_t	len = (coordf_t)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_link_max_length() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 82 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
     THIS->fill->link_max_length = len; 
#line 45134 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_set_loop_clipping); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_loop_clipping)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, clipping");
    {
	Filler *	THIS;
	coordf_t	clipping = (coordf_t)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_loop_clipping() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 87 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
     THIS->fill->loop_clipping = clipping; 
#line 45165 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_use_bridge_flow); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_use_bridge_flow)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Filler *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::use_bridge_flow() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 92 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
     RETVAL = THIS->fill->use_bridge_flow(); 
#line 45196 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Filler_no_sort); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_no_sort)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "THIS");
    {
	Filler *	THIS;
	bool	RETVAL;
	dXSTARG;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::no_sort() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 98 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
     RETVAL = THIS->fill->no_sort(); 
#line 45228 "buildtmp/XS.c"
	XSprePUSH; PUSHu((UV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Filler_set_density); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_density)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, density");
    {
	Filler *	THIS;
	float	density = (float)SvNV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_density() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 104 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
     THIS->fill->density = density; 
#line 45260 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_set_dont_connect); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_dont_connect)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, dont_connect");
    {
	Filler *	THIS;
	bool	dont_connect = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_dont_connect() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 109 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
     THIS->fill->dont_connect = dont_connect; 
#line 45291 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_set_dont_adjust); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_dont_adjust)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, dont_adjust");
    {
	Filler *	THIS;
	bool	dont_adjust = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_dont_adjust() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 114 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
     THIS->fill->dont_adjust = dont_adjust; 
#line 45322 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler_set_complete); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_set_complete)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, complete");
    {
	Filler *	THIS;
	bool	complete = (bool)SvUV(ST(1))
;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::set_complete() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 119 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
     THIS->fill->complete = complete; 
#line 45353 "buildtmp/XS.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Slic3r__Filler__fill_surface); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler__fill_surface)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "THIS, surface");
    {
	Filler *	THIS;
	PolylineCollection *	RETVAL;
	Surface*	surface;

    if( sv_isobject(ST(0)) && (SvTYPE(SvRV(ST(0))) == SVt_PVMG) ) {
        if ( sv_isa(ST(0), Slic3r::perl_class_name(THIS) ) ||  sv_isa(ST(0), Slic3r::perl_class_name_ref(THIS) )) {
              THIS = (Filler *)SvIV((SV*)SvRV( ST(0) ));
        } else {
              croak("THIS is not of type %s (got %s)", Slic3r::perl_class_name(THIS), HvNAME(SvSTASH(SvRV(ST(0)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::_fill_surface() -- THIS is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;

    if( sv_isobject(ST(1)) && (SvTYPE(SvRV(ST(1))) == SVt_PVMG) ) {
        if ( sv_isa(ST(1), Slic3r::perl_class_name(surface) ) ||  sv_isa(ST(1), Slic3r::perl_class_name_ref(surface) )) {
              surface = (Surface *)SvIV((SV*)SvRV( ST(1) ));
        } else {
              croak("surface is not of type %s (got %s)", Slic3r::perl_class_name(surface), HvNAME(SvSTASH(SvRV(ST(1)))));
              XSRETURN_UNDEF;
        }
    } else {
        warn( "Slic3r::Filler::_fill_surface() -- surface is not a blessed SV reference" );
        XSRETURN_UNDEF;
    }
;
#line 124 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
            PolylineCollection *pc = NULL;
            if (THIS->fill != NULL) {
                pc = new PolylineCollection();
                pc->polylines = THIS->fill->fill_surface(*surface);
            }
            RETVAL =  pc;
#line 45402 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Slic3r__Filler_new_from_type); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Slic3r__Filler_new_from_type)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "CLASS, type");
    {
	char*	CLASS = (char *)SvPV_nolen(ST(0))
;
	std::string	type;
	Filler *	RETVAL;

    {
      size_t len;
      const char * c = SvPVutf8(ST(1), len);
      type = std::string(c, len);
    }
;
#line 139 "/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t \"/Users/jankovar/Slic3r/xs/xsp/typemap.xspt\"  \"/Users/jankovar/Slic3r/xs/xsp/Filler.xsp\""
        Filler *filler = new Filler();
        filler->fill = Fill::new_from_type(type);
        RETVAL = filler;
#line 45438 "buildtmp/XS.c"
	{
	    SV * RETVALSV;
	    RETVALSV = sv_newmortal();
	    if (RETVAL == NULL)
		XSRETURN_UNDEF;
	    sv_setref_pv( RETVALSV, Slic3r::perl_class_name(RETVAL), (void*)RETVAL );
	    ST(0) = RETVALSV;
	}
    }
    XSRETURN(1);
}


/* INCLUDE: Returning to 'main.xs' from '/usr/local/Cellar/perl/5.28.0/bin/perl -MExtUtils::XSpp::Cmd -e xspp -- -t "/Users/jankovar/Slic3r/xs/xsp/typemap.xspt"  "/Users/jankovar/Slic3r/xs/xsp/Filler.xsp"' */

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Slic3r__XS); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Slic3r__XS)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        newXS_deffile("Slic3r::SLAPrint::new", XS_Slic3r__SLAPrint_new);
        newXS_deffile("Slic3r::SLAPrint::DESTROY", XS_Slic3r__SLAPrint_DESTROY);
        newXS_deffile("Slic3r::SLAPrint::apply_config", XS_Slic3r__SLAPrint_apply_config);
        newXS_deffile("Slic3r::SLAPrint::slice", XS_Slic3r__SLAPrint_slice);
        newXS_deffile("Slic3r::SLAPrint::layer_count", XS_Slic3r__SLAPrint_layer_count);
        newXS_deffile("Slic3r::SLAPrint::config", XS_Slic3r__SLAPrint_config);
        newXS_deffile("Slic3r::SLAPrint::layer_slices", XS_Slic3r__SLAPrint_layer_slices);
        newXS_deffile("Slic3r::SLAPrint::layer_solid_infill", XS_Slic3r__SLAPrint_layer_solid_infill);
        newXS_deffile("Slic3r::SLAPrint::layer_perimeters", XS_Slic3r__SLAPrint_layer_perimeters);
        newXS_deffile("Slic3r::SLAPrint::layer_infill", XS_Slic3r__SLAPrint_layer_infill);
        newXS_deffile("Slic3r::SLAPrint::layer_solid", XS_Slic3r__SLAPrint_layer_solid);
        newXS_deffile("Slic3r::SLAPrint::write_svg", XS_Slic3r__SLAPrint_write_svg);
        newXS_deffile("Slic3r::SLAPrint::heights", XS_Slic3r__SLAPrint_heights);
        newXS_deffile("Slic3r::SLAPrint::sm_pillars", XS_Slic3r__SLAPrint_sm_pillars);
        newXS_deffile("Slic3r::GUI::disable_screensaver", XS_Slic3r__GUI_disable_screensaver);
        newXS_deffile("Slic3r::GUI::enable_screensaver", XS_Slic3r__GUI_enable_screensaver);
        newXS_deffile("Slic3r::Geometry::arrange", XS_Slic3r__Geometry_arrange);
        newXS_deffile("Slic3r::Geometry::directions_parallel", XS_Slic3r__Geometry_directions_parallel);
        newXS_deffile("Slic3r::Geometry::directions_parallel_within", XS_Slic3r__Geometry_directions_parallel_within);
        newXS_deffile("Slic3r::Geometry::convex_hull", XS_Slic3r__Geometry_convex_hull);
        newXS_deffile("Slic3r::Geometry::chained_path", XS_Slic3r__Geometry_chained_path);
        newXS_deffile("Slic3r::Geometry::chained_path_from", XS_Slic3r__Geometry_chained_path_from);
        newXS_deffile("Slic3r::Geometry::rad2deg", XS_Slic3r__Geometry_rad2deg);
        newXS_deffile("Slic3r::Geometry::rad2deg_dir", XS_Slic3r__Geometry_rad2deg_dir);
        newXS_deffile("Slic3r::Geometry::deg2rad", XS_Slic3r__Geometry_deg2rad);
        cv = newXSproto_portable("Slic3r::Geometry::X", XS_Slic3r__Geometry__constant, file, "");
        XSANY.any_i32 = X;
        cv = newXSproto_portable("Slic3r::Geometry::Y", XS_Slic3r__Geometry__constant, file, "");
        XSANY.any_i32 = Y;
        cv = newXSproto_portable("Slic3r::Geometry::Z", XS_Slic3r__Geometry__constant, file, "");
        XSANY.any_i32 = Z;
        cv = newXSproto_portable("Slic3r::Geometry::_constant", XS_Slic3r__Geometry__constant, file, "");
        XSANY.any_i32 = 0;
        newXS_deffile("Slic3r::MotionPlanner::new", XS_Slic3r__MotionPlanner_new);
        newXS_deffile("Slic3r::MotionPlanner::DESTROY", XS_Slic3r__MotionPlanner_DESTROY);
        newXS_deffile("Slic3r::MotionPlanner::islands_count", XS_Slic3r__MotionPlanner_islands_count);
        newXS_deffile("Slic3r::MotionPlanner::shortest_path", XS_Slic3r__MotionPlanner_shortest_path);
        newXS_deffile("Slic3r::Layer::Region::layer", XS_Slic3r__Layer__Region_layer);
        newXS_deffile("Slic3r::Layer::Region::region", XS_Slic3r__Layer__Region_region);
        newXS_deffile("Slic3r::Layer::Region::slices", XS_Slic3r__Layer__Region_slices);
        newXS_deffile("Slic3r::Layer::Region::thin_fills", XS_Slic3r__Layer__Region_thin_fills);
        newXS_deffile("Slic3r::Layer::Region::fill_surfaces", XS_Slic3r__Layer__Region_fill_surfaces);
        newXS_deffile("Slic3r::Layer::Region::bridged", XS_Slic3r__Layer__Region_bridged);
        newXS_deffile("Slic3r::Layer::Region::unsupported_bridge_edges", XS_Slic3r__Layer__Region_unsupported_bridge_edges);
        newXS_deffile("Slic3r::Layer::Region::perimeters", XS_Slic3r__Layer__Region_perimeters);
        newXS_deffile("Slic3r::Layer::Region::fills", XS_Slic3r__Layer__Region_fills);
        newXS_deffile("Slic3r::Layer::Region::flow", XS_Slic3r__Layer__Region_flow);
        newXS_deffile("Slic3r::Layer::Region::merge_slices", XS_Slic3r__Layer__Region_merge_slices);
        newXS_deffile("Slic3r::Layer::Region::prepare_fill_surfaces", XS_Slic3r__Layer__Region_prepare_fill_surfaces);
        newXS_deffile("Slic3r::Layer::Region::make_perimeters", XS_Slic3r__Layer__Region_make_perimeters);
        newXS_deffile("Slic3r::Layer::Region::infill_area_threshold", XS_Slic3r__Layer__Region_infill_area_threshold);
        newXS_deffile("Slic3r::Layer::as_layer", XS_Slic3r__Layer_as_layer);
        newXS_deffile("Slic3r::Layer::id", XS_Slic3r__Layer_id);
        newXS_deffile("Slic3r::Layer::set_id", XS_Slic3r__Layer_set_id);
        newXS_deffile("Slic3r::Layer::object", XS_Slic3r__Layer_object);
        newXS_deffile("Slic3r::Layer::upper_layer", XS_Slic3r__Layer_upper_layer);
        newXS_deffile("Slic3r::Layer::lower_layer", XS_Slic3r__Layer_lower_layer);
        newXS_deffile("Slic3r::Layer::slicing_errors", XS_Slic3r__Layer_slicing_errors);
        newXS_deffile("Slic3r::Layer::slice_z", XS_Slic3r__Layer_slice_z);
        newXS_deffile("Slic3r::Layer::print_z", XS_Slic3r__Layer_print_z);
        newXS_deffile("Slic3r::Layer::height", XS_Slic3r__Layer_height);
        newXS_deffile("Slic3r::Layer::set_print_z", XS_Slic3r__Layer_set_print_z);
        newXS_deffile("Slic3r::Layer::set_height", XS_Slic3r__Layer_set_height);
        newXS_deffile("Slic3r::Layer::set_upper_layer", XS_Slic3r__Layer_set_upper_layer);
        newXS_deffile("Slic3r::Layer::set_lower_layer", XS_Slic3r__Layer_set_lower_layer);
        newXS_deffile("Slic3r::Layer::has_upper_layer", XS_Slic3r__Layer_has_upper_layer);
        newXS_deffile("Slic3r::Layer::has_lower_layer", XS_Slic3r__Layer_has_lower_layer);
        newXS_deffile("Slic3r::Layer::region_count", XS_Slic3r__Layer_region_count);
        newXS_deffile("Slic3r::Layer::get_region", XS_Slic3r__Layer_get_region);
        newXS_deffile("Slic3r::Layer::add_region", XS_Slic3r__Layer_add_region);
        newXS_deffile("Slic3r::Layer::slices", XS_Slic3r__Layer_slices);
        newXS_deffile("Slic3r::Layer::ptr", XS_Slic3r__Layer_ptr);
        newXS_deffile("Slic3r::Layer::as_support_layer", XS_Slic3r__Layer_as_support_layer);
        newXS_deffile("Slic3r::Layer::make_slices", XS_Slic3r__Layer_make_slices);
        newXS_deffile("Slic3r::Layer::merge_slices", XS_Slic3r__Layer_merge_slices);
        newXS_deffile("Slic3r::Layer::any_internal_region_slice_contains_polyline", XS_Slic3r__Layer_any_internal_region_slice_contains_polyline);
        newXS_deffile("Slic3r::Layer::any_bottom_region_slice_contains_polyline", XS_Slic3r__Layer_any_bottom_region_slice_contains_polyline);
        newXS_deffile("Slic3r::Layer::make_perimeters", XS_Slic3r__Layer_make_perimeters);
        newXS_deffile("Slic3r::Layer::make_fills", XS_Slic3r__Layer_make_fills);
        newXS_deffile("Slic3r::Layer::Support::as_layer", XS_Slic3r__Layer__Support_as_layer);
        newXS_deffile("Slic3r::Layer::Support::support_islands", XS_Slic3r__Layer__Support_support_islands);
        newXS_deffile("Slic3r::Layer::Support::support_fills", XS_Slic3r__Layer__Support_support_fills);
        newXS_deffile("Slic3r::Layer::Support::support_interface_fills", XS_Slic3r__Layer__Support_support_interface_fills);
        newXS_deffile("Slic3r::Layer::Support::id", XS_Slic3r__Layer__Support_id);
        newXS_deffile("Slic3r::Layer::Support::set_id", XS_Slic3r__Layer__Support_set_id);
        newXS_deffile("Slic3r::Layer::Support::object", XS_Slic3r__Layer__Support_object);
        newXS_deffile("Slic3r::Layer::Support::upper_layer", XS_Slic3r__Layer__Support_upper_layer);
        newXS_deffile("Slic3r::Layer::Support::lower_layer", XS_Slic3r__Layer__Support_lower_layer);
        newXS_deffile("Slic3r::Layer::Support::slicing_errors", XS_Slic3r__Layer__Support_slicing_errors);
        newXS_deffile("Slic3r::Layer::Support::slice_z", XS_Slic3r__Layer__Support_slice_z);
        newXS_deffile("Slic3r::Layer::Support::print_z", XS_Slic3r__Layer__Support_print_z);
        newXS_deffile("Slic3r::Layer::Support::height", XS_Slic3r__Layer__Support_height);
        newXS_deffile("Slic3r::Layer::Support::set_upper_layer", XS_Slic3r__Layer__Support_set_upper_layer);
        newXS_deffile("Slic3r::Layer::Support::set_lower_layer", XS_Slic3r__Layer__Support_set_lower_layer);
        newXS_deffile("Slic3r::Layer::Support::has_upper_layer", XS_Slic3r__Layer__Support_has_upper_layer);
        newXS_deffile("Slic3r::Layer::Support::has_lower_layer", XS_Slic3r__Layer__Support_has_lower_layer);
        newXS_deffile("Slic3r::Layer::Support::region_count", XS_Slic3r__Layer__Support_region_count);
        newXS_deffile("Slic3r::Layer::Support::get_region", XS_Slic3r__Layer__Support_get_region);
        newXS_deffile("Slic3r::Layer::Support::add_region", XS_Slic3r__Layer__Support_add_region);
        newXS_deffile("Slic3r::Layer::Support::slices", XS_Slic3r__Layer__Support_slices);
        newXS_deffile("Slic3r::Layer::Support::any_internal_region_slice_contains_polyline", XS_Slic3r__Layer__Support_any_internal_region_slice_contains_polyline);
        newXS_deffile("Slic3r::Layer::Support::any_bottom_region_slice_contains_polyline", XS_Slic3r__Layer__Support_any_bottom_region_slice_contains_polyline);
        newXS_deffile("Slic3r::SlicingAdaptive::new", XS_Slic3r__SlicingAdaptive_new);
        newXS_deffile("Slic3r::SlicingAdaptive::DESTROY", XS_Slic3r__SlicingAdaptive_DESTROY);
        newXS_deffile("Slic3r::SlicingAdaptive::clear", XS_Slic3r__SlicingAdaptive_clear);
        newXS_deffile("Slic3r::SlicingAdaptive::add_mesh", XS_Slic3r__SlicingAdaptive_add_mesh);
        newXS_deffile("Slic3r::SlicingAdaptive::prepare", XS_Slic3r__SlicingAdaptive_prepare);
        newXS_deffile("Slic3r::SlicingAdaptive::next_layer_height", XS_Slic3r__SlicingAdaptive_next_layer_height);
        newXS_deffile("Slic3r::SlicingAdaptive::horizontal_facet_distance", XS_Slic3r__SlicingAdaptive_horizontal_facet_distance);
        newXS_deffile("Slic3r::ConditionalGCode::apply_math", XS_Slic3r__ConditionalGCode_apply_math);
        newXS_deffile("Slic3r::Surface::Collection::_new", XS_Slic3r__Surface__Collection__new);
        newXS_deffile("Slic3r::Surface::Collection::DESTROY", XS_Slic3r__Surface__Collection_DESTROY);
        newXS_deffile("Slic3r::Surface::Collection::clear", XS_Slic3r__Surface__Collection_clear);
        newXS_deffile("Slic3r::Surface::Collection::append", XS_Slic3r__Surface__Collection_append);
        newXS_deffile("Slic3r::Surface::Collection::count", XS_Slic3r__Surface__Collection_count);
        newXS_deffile("Slic3r::Surface::Collection::simplify", XS_Slic3r__Surface__Collection_simplify);
        newXS_deffile("Slic3r::Surface::Collection::arrayref", XS_Slic3r__Surface__Collection_arrayref);
        newXS_deffile("Slic3r::Surface::Collection::filter_by_type", XS_Slic3r__Surface__Collection_filter_by_type);
        newXS_deffile("Slic3r::Surface::Collection::replace", XS_Slic3r__Surface__Collection_replace);
        newXS_deffile("Slic3r::Surface::Collection::set_surface_type", XS_Slic3r__Surface__Collection_set_surface_type);
        newXS_deffile("Slic3r::Surface::Collection::group", XS_Slic3r__Surface__Collection_group);
#if XSubPPtmpAAAA
        newXS_deffile("Slic3r::GCode::Sender::new", XS_Slic3r__GCode__Sender_new);
        newXS_deffile("Slic3r::GCode::Sender::DESTROY", XS_Slic3r__GCode__Sender_DESTROY);
        newXS_deffile("Slic3r::GCode::Sender::connect", XS_Slic3r__GCode__Sender_connect);
        newXS_deffile("Slic3r::GCode::Sender::disconnect", XS_Slic3r__GCode__Sender_disconnect);
        newXS_deffile("Slic3r::GCode::Sender::is_connected", XS_Slic3r__GCode__Sender_is_connected);
        newXS_deffile("Slic3r::GCode::Sender::wait_connected", XS_Slic3r__GCode__Sender_wait_connected);
        newXS_deffile("Slic3r::GCode::Sender::queue_size", XS_Slic3r__GCode__Sender_queue_size);
        newXS_deffile("Slic3r::GCode::Sender::send", XS_Slic3r__GCode__Sender_send);
        newXS_deffile("Slic3r::GCode::Sender::pause_queue", XS_Slic3r__GCode__Sender_pause_queue);
        newXS_deffile("Slic3r::GCode::Sender::resume_queue", XS_Slic3r__GCode__Sender_resume_queue);
        newXS_deffile("Slic3r::GCode::Sender::purge_queue", XS_Slic3r__GCode__Sender_purge_queue);
        newXS_deffile("Slic3r::GCode::Sender::purge_log", XS_Slic3r__GCode__Sender_purge_log);
        newXS_deffile("Slic3r::GCode::Sender::getT", XS_Slic3r__GCode__Sender_getT);
        newXS_deffile("Slic3r::GCode::Sender::getB", XS_Slic3r__GCode__Sender_getB);
#endif
        newXS_deffile("Slic3r::VERSION", XS_Slic3r_VERSION);
        newXS_deffile("Slic3r::GITVERSION", XS_Slic3r_GITVERSION);
        newXS_deffile("Slic3r::xspp_test_croak_hangs_on_strawberry", XS_Slic3r_xspp_test_croak_hangs_on_strawberry);
        newXS_deffile("Slic3r::Flow::DESTROY", XS_Slic3r__Flow_DESTROY);
        newXS_deffile("Slic3r::Flow::_new", XS_Slic3r__Flow__new);
        newXS_deffile("Slic3r::Flow::set_height", XS_Slic3r__Flow_set_height);
        newXS_deffile("Slic3r::Flow::set_bridge", XS_Slic3r__Flow_set_bridge);
        newXS_deffile("Slic3r::Flow::clone", XS_Slic3r__Flow_clone);
        newXS_deffile("Slic3r::Flow::width", XS_Slic3r__Flow_width);
        newXS_deffile("Slic3r::Flow::height", XS_Slic3r__Flow_height);
        newXS_deffile("Slic3r::Flow::nozzle_diameter", XS_Slic3r__Flow_nozzle_diameter);
        newXS_deffile("Slic3r::Flow::bridge", XS_Slic3r__Flow_bridge);
        newXS_deffile("Slic3r::Flow::spacing", XS_Slic3r__Flow_spacing);
        newXS_deffile("Slic3r::Flow::spacing_to", XS_Slic3r__Flow_spacing_to);
        newXS_deffile("Slic3r::Flow::scaled_width", XS_Slic3r__Flow_scaled_width);
        newXS_deffile("Slic3r::Flow::scaled_spacing", XS_Slic3r__Flow_scaled_spacing);
        newXS_deffile("Slic3r::Flow::mm3_per_mm", XS_Slic3r__Flow_mm3_per_mm);
        newXS_deffile("Slic3r::Flow::_new_from_width", XS_Slic3r__Flow__new_from_width);
        newXS_deffile("Slic3r::Flow::_new_from_spacing", XS_Slic3r__Flow__new_from_spacing);
        cv = newXSproto_portable("Slic3r::Flow::FLOW_ROLE_EXTERNAL_PERIMETER", XS_Slic3r__Flow__constant, file, "");
        XSANY.any_i32 = frExternalPerimeter;
        cv = newXSproto_portable("Slic3r::Flow::FLOW_ROLE_INFILL", XS_Slic3r__Flow__constant, file, "");
        XSANY.any_i32 = frInfill;
        cv = newXSproto_portable("Slic3r::Flow::FLOW_ROLE_PERIMETER", XS_Slic3r__Flow__constant, file, "");
        XSANY.any_i32 = frPerimeter;
        cv = newXSproto_portable("Slic3r::Flow::FLOW_ROLE_SOLID_INFILL", XS_Slic3r__Flow__constant, file, "");
        XSANY.any_i32 = frSolidInfill;
        cv = newXSproto_portable("Slic3r::Flow::FLOW_ROLE_SUPPORT_MATERIAL", XS_Slic3r__Flow__constant, file, "");
        XSANY.any_i32 = frSupportMaterial;
        cv = newXSproto_portable("Slic3r::Flow::FLOW_ROLE_SUPPORT_MATERIAL_INTERFACE", XS_Slic3r__Flow__constant, file, "");
        XSANY.any_i32 = frSupportMaterialInterface;
        cv = newXSproto_portable("Slic3r::Flow::FLOW_ROLE_TOP_SOLID_INFILL", XS_Slic3r__Flow__constant, file, "");
        XSANY.any_i32 = frTopSolidInfill;
        cv = newXSproto_portable("Slic3r::Flow::_constant", XS_Slic3r__Flow__constant, file, "");
        XSANY.any_i32 = 0;
        newXS_deffile("Slic3r::Flow::solid_spacing", XS_Slic3r__Flow_solid_spacing);
        newXS_deffile("Slic3r::Point::new", XS_Slic3r__Point_new);
        newXS_deffile("Slic3r::Point::DESTROY", XS_Slic3r__Point_DESTROY);
        newXS_deffile("Slic3r::Point::clone", XS_Slic3r__Point_clone);
        newXS_deffile("Slic3r::Point::scale", XS_Slic3r__Point_scale);
        newXS_deffile("Slic3r::Point::translate", XS_Slic3r__Point_translate);
        newXS_deffile("Slic3r::Point::arrayref", XS_Slic3r__Point_arrayref);
        newXS_deffile("Slic3r::Point::pp", XS_Slic3r__Point_pp);
        newXS_deffile("Slic3r::Point::x", XS_Slic3r__Point_x);
        newXS_deffile("Slic3r::Point::y", XS_Slic3r__Point_y);
        newXS_deffile("Slic3r::Point::set_x", XS_Slic3r__Point_set_x);
        newXS_deffile("Slic3r::Point::set_y", XS_Slic3r__Point_set_y);
        newXS_deffile("Slic3r::Point::nearest_point_index", XS_Slic3r__Point_nearest_point_index);
        newXS_deffile("Slic3r::Point::nearest_point", XS_Slic3r__Point_nearest_point);
        newXS_deffile("Slic3r::Point::distance_to", XS_Slic3r__Point_distance_to);
        newXS_deffile("Slic3r::Point::distance_to_line", XS_Slic3r__Point_distance_to_line);
        newXS_deffile("Slic3r::Point::perp_distance_to_line", XS_Slic3r__Point_perp_distance_to_line);
        newXS_deffile("Slic3r::Point::ccw", XS_Slic3r__Point_ccw);
        newXS_deffile("Slic3r::Point::ccw_angle", XS_Slic3r__Point_ccw_angle);
        newXS_deffile("Slic3r::Point::projection_onto_polygon", XS_Slic3r__Point_projection_onto_polygon);
        newXS_deffile("Slic3r::Point::projection_onto_polyline", XS_Slic3r__Point_projection_onto_polyline);
        newXS_deffile("Slic3r::Point::projection_onto_line", XS_Slic3r__Point_projection_onto_line);
        newXS_deffile("Slic3r::Point::negative", XS_Slic3r__Point_negative);
        newXS_deffile("Slic3r::Point::coincides_with_epsilon", XS_Slic3r__Point_coincides_with_epsilon);
        newXS_deffile("Slic3r::Point::rotate", XS_Slic3r__Point_rotate);
        newXS_deffile("Slic3r::Point::coincides_with", XS_Slic3r__Point_coincides_with);
        newXS_deffile("Slic3r::Point3::new", XS_Slic3r__Point3_new);
        newXS_deffile("Slic3r::Point3::DESTROY", XS_Slic3r__Point3_DESTROY);
        newXS_deffile("Slic3r::Point3::clone", XS_Slic3r__Point3_clone);
        newXS_deffile("Slic3r::Point3::x", XS_Slic3r__Point3_x);
        newXS_deffile("Slic3r::Point3::y", XS_Slic3r__Point3_y);
        newXS_deffile("Slic3r::Point3::z", XS_Slic3r__Point3_z);
        newXS_deffile("Slic3r::Pointf::new", XS_Slic3r__Pointf_new);
        newXS_deffile("Slic3r::Pointf::DESTROY", XS_Slic3r__Pointf_DESTROY);
        newXS_deffile("Slic3r::Pointf::clone", XS_Slic3r__Pointf_clone);
        newXS_deffile("Slic3r::Pointf::arrayref", XS_Slic3r__Pointf_arrayref);
        newXS_deffile("Slic3r::Pointf::pp", XS_Slic3r__Pointf_pp);
        newXS_deffile("Slic3r::Pointf::x", XS_Slic3r__Pointf_x);
        newXS_deffile("Slic3r::Pointf::y", XS_Slic3r__Pointf_y);
        newXS_deffile("Slic3r::Pointf::set_x", XS_Slic3r__Pointf_set_x);
        newXS_deffile("Slic3r::Pointf::set_y", XS_Slic3r__Pointf_set_y);
        newXS_deffile("Slic3r::Pointf::translate", XS_Slic3r__Pointf_translate);
        newXS_deffile("Slic3r::Pointf::scale", XS_Slic3r__Pointf_scale);
        newXS_deffile("Slic3r::Pointf::rotate", XS_Slic3r__Pointf_rotate);
        newXS_deffile("Slic3r::Pointf::negative", XS_Slic3r__Pointf_negative);
        newXS_deffile("Slic3r::Pointf::vector_to", XS_Slic3r__Pointf_vector_to);
        newXS_deffile("Slic3r::Pointf3::new", XS_Slic3r__Pointf3_new);
        newXS_deffile("Slic3r::Pointf3::DESTROY", XS_Slic3r__Pointf3_DESTROY);
        newXS_deffile("Slic3r::Pointf3::clone", XS_Slic3r__Pointf3_clone);
        newXS_deffile("Slic3r::Pointf3::x", XS_Slic3r__Pointf3_x);
        newXS_deffile("Slic3r::Pointf3::y", XS_Slic3r__Pointf3_y);
        newXS_deffile("Slic3r::Pointf3::z", XS_Slic3r__Pointf3_z);
        newXS_deffile("Slic3r::Pointf3::set_x", XS_Slic3r__Pointf3_set_x);
        newXS_deffile("Slic3r::Pointf3::set_y", XS_Slic3r__Pointf3_set_y);
        newXS_deffile("Slic3r::Pointf3::set_z", XS_Slic3r__Pointf3_set_z);
        newXS_deffile("Slic3r::Pointf3::translate", XS_Slic3r__Pointf3_translate);
        newXS_deffile("Slic3r::Pointf3::scale", XS_Slic3r__Pointf3_scale);
        newXS_deffile("Slic3r::Pointf3::distance_to", XS_Slic3r__Pointf3_distance_to);
        newXS_deffile("Slic3r::Pointf3::negative", XS_Slic3r__Pointf3_negative);
        newXS_deffile("Slic3r::Pointf3::vector_to", XS_Slic3r__Pointf3_vector_to);
        newXS_deffile("Slic3r::Geometry::Clipper::offset", XS_Slic3r__Geometry__Clipper_offset);
        newXS_deffile("Slic3r::Geometry::Clipper::offset_ex", XS_Slic3r__Geometry__Clipper_offset_ex);
        newXS_deffile("Slic3r::Geometry::Clipper::offset2", XS_Slic3r__Geometry__Clipper_offset2);
        newXS_deffile("Slic3r::Geometry::Clipper::offset2_ex", XS_Slic3r__Geometry__Clipper_offset2_ex);
        newXS_deffile("Slic3r::Geometry::Clipper::diff", XS_Slic3r__Geometry__Clipper_diff);
        newXS_deffile("Slic3r::Geometry::Clipper::diff_ex", XS_Slic3r__Geometry__Clipper_diff_ex);
        newXS_deffile("Slic3r::Geometry::Clipper::diff_pl", XS_Slic3r__Geometry__Clipper_diff_pl);
        newXS_deffile("Slic3r::Geometry::Clipper::intersection", XS_Slic3r__Geometry__Clipper_intersection);
        newXS_deffile("Slic3r::Geometry::Clipper::intersection_ex", XS_Slic3r__Geometry__Clipper_intersection_ex);
        newXS_deffile("Slic3r::Geometry::Clipper::intersection_pl", XS_Slic3r__Geometry__Clipper_intersection_pl);
        newXS_deffile("Slic3r::Geometry::Clipper::intersection_ppl", XS_Slic3r__Geometry__Clipper_intersection_ppl);
        newXS_deffile("Slic3r::Geometry::Clipper::union", XS_Slic3r__Geometry__Clipper_union);
        newXS_deffile("Slic3r::Geometry::Clipper::union_ex", XS_Slic3r__Geometry__Clipper_union_ex);
        newXS_deffile("Slic3r::Geometry::Clipper::union_pt_chained", XS_Slic3r__Geometry__Clipper_union_pt_chained);
        newXS_deffile("Slic3r::Geometry::Clipper::simplify_polygons", XS_Slic3r__Geometry__Clipper_simplify_polygons);
        cv = newXS_deffile("Slic3r::Geometry::Clipper::CLIPPER_OFFSET_SCALE", XS_Slic3r__Geometry__Clipper__constant);
        XSANY.any_i32 = CLIPPER_OFFSET_SCALE;
        cv = newXS_deffile("Slic3r::Geometry::Clipper::JT_MITER", XS_Slic3r__Geometry__Clipper__constant);
        XSANY.any_i32 = jtMiter;
        cv = newXS_deffile("Slic3r::Geometry::Clipper::JT_ROUND", XS_Slic3r__Geometry__Clipper__constant);
        XSANY.any_i32 = jtRound;
        cv = newXS_deffile("Slic3r::Geometry::Clipper::JT_SQUARE", XS_Slic3r__Geometry__Clipper__constant);
        XSANY.any_i32 = jtSquare;
        cv = newXS_deffile("Slic3r::Geometry::Clipper::_constant", XS_Slic3r__Geometry__Clipper__constant);
        XSANY.any_i32 = 0;
        newXS_deffile("Slic3r::Geometry::Clipper::union_pt", XS_Slic3r__Geometry__Clipper_union_pt);
        newXS_deffile("Slic3r::TriangleMesh::new", XS_Slic3r__TriangleMesh_new);
        newXS_deffile("Slic3r::TriangleMesh::DESTROY", XS_Slic3r__TriangleMesh_DESTROY);
        newXS_deffile("Slic3r::TriangleMesh::clone", XS_Slic3r__TriangleMesh_clone);
        newXS_deffile("Slic3r::TriangleMesh::ReadSTLFile", XS_Slic3r__TriangleMesh_ReadSTLFile);
        newXS_deffile("Slic3r::TriangleMesh::write_ascii", XS_Slic3r__TriangleMesh_write_ascii);
        newXS_deffile("Slic3r::TriangleMesh::write_binary", XS_Slic3r__TriangleMesh_write_binary);
        newXS_deffile("Slic3r::TriangleMesh::check_topology", XS_Slic3r__TriangleMesh_check_topology);
        newXS_deffile("Slic3r::TriangleMesh::repair", XS_Slic3r__TriangleMesh_repair);
        newXS_deffile("Slic3r::TriangleMesh::volume", XS_Slic3r__TriangleMesh_volume);
        newXS_deffile("Slic3r::TriangleMesh::WriteOBJFile", XS_Slic3r__TriangleMesh_WriteOBJFile);
        newXS_deffile("Slic3r::TriangleMesh::scale", XS_Slic3r__TriangleMesh_scale);
        newXS_deffile("Slic3r::TriangleMesh::scale_xyz", XS_Slic3r__TriangleMesh_scale_xyz);
        newXS_deffile("Slic3r::TriangleMesh::translate", XS_Slic3r__TriangleMesh_translate);
        newXS_deffile("Slic3r::TriangleMesh::rotate_x", XS_Slic3r__TriangleMesh_rotate_x);
        newXS_deffile("Slic3r::TriangleMesh::rotate_y", XS_Slic3r__TriangleMesh_rotate_y);
        newXS_deffile("Slic3r::TriangleMesh::rotate_z", XS_Slic3r__TriangleMesh_rotate_z);
        newXS_deffile("Slic3r::TriangleMesh::mirror_x", XS_Slic3r__TriangleMesh_mirror_x);
        newXS_deffile("Slic3r::TriangleMesh::mirror_y", XS_Slic3r__TriangleMesh_mirror_y);
        newXS_deffile("Slic3r::TriangleMesh::mirror_z", XS_Slic3r__TriangleMesh_mirror_z);
        newXS_deffile("Slic3r::TriangleMesh::align_to_origin", XS_Slic3r__TriangleMesh_align_to_origin);
        newXS_deffile("Slic3r::TriangleMesh::rotate", XS_Slic3r__TriangleMesh_rotate);
        newXS_deffile("Slic3r::TriangleMesh::split", XS_Slic3r__TriangleMesh_split);
        newXS_deffile("Slic3r::TriangleMesh::cut_by_grid", XS_Slic3r__TriangleMesh_cut_by_grid);
        newXS_deffile("Slic3r::TriangleMesh::merge", XS_Slic3r__TriangleMesh_merge);
        newXS_deffile("Slic3r::TriangleMesh::horizontal_projection", XS_Slic3r__TriangleMesh_horizontal_projection);
        newXS_deffile("Slic3r::TriangleMesh::convex_hull", XS_Slic3r__TriangleMesh_convex_hull);
        newXS_deffile("Slic3r::TriangleMesh::bounding_box", XS_Slic3r__TriangleMesh_bounding_box);
        newXS_deffile("Slic3r::TriangleMesh::center", XS_Slic3r__TriangleMesh_center);
        newXS_deffile("Slic3r::TriangleMesh::facets_count", XS_Slic3r__TriangleMesh_facets_count);
        newXS_deffile("Slic3r::TriangleMesh::reset_repair_stats", XS_Slic3r__TriangleMesh_reset_repair_stats);
        newXS_deffile("Slic3r::TriangleMesh::reverse_normals", XS_Slic3r__TriangleMesh_reverse_normals);
        newXS_deffile("Slic3r::TriangleMesh::ReadFromPerl", XS_Slic3r__TriangleMesh_ReadFromPerl);
        newXS_deffile("Slic3r::TriangleMesh::stats", XS_Slic3r__TriangleMesh_stats);
        newXS_deffile("Slic3r::TriangleMesh::vertices", XS_Slic3r__TriangleMesh_vertices);
        newXS_deffile("Slic3r::TriangleMesh::facets", XS_Slic3r__TriangleMesh_facets);
        newXS_deffile("Slic3r::TriangleMesh::normals", XS_Slic3r__TriangleMesh_normals);
        newXS_deffile("Slic3r::TriangleMesh::size", XS_Slic3r__TriangleMesh_size);
        newXS_deffile("Slic3r::TriangleMesh::slice", XS_Slic3r__TriangleMesh_slice);
        newXS_deffile("Slic3r::TriangleMesh::slice_at", XS_Slic3r__TriangleMesh_slice_at);
        newXS_deffile("Slic3r::TriangleMesh::cut", XS_Slic3r__TriangleMesh_cut);
        newXS_deffile("Slic3r::TriangleMesh::bb3", XS_Slic3r__TriangleMesh_bb3);
        newXS_deffile("Slic3r::TriangleMesh::make_cube", XS_Slic3r__TriangleMesh_make_cube);
        newXS_deffile("Slic3r::TriangleMesh::make_cylinder", XS_Slic3r__TriangleMesh_make_cylinder);
        newXS_deffile("Slic3r::TriangleMesh::make_sphere", XS_Slic3r__TriangleMesh_make_sphere);
        newXS_deffile("Slic3r::TriangleMesh::hello_world", XS_Slic3r__TriangleMesh_hello_world);
        newXS_deffile("Slic3r::Geometry::BoundingBox::new", XS_Slic3r__Geometry__BoundingBox_new);
        newXS_deffile("Slic3r::Geometry::BoundingBox::DESTROY", XS_Slic3r__Geometry__BoundingBox_DESTROY);
        newXS_deffile("Slic3r::Geometry::BoundingBox::clone", XS_Slic3r__Geometry__BoundingBox_clone);
        newXS_deffile("Slic3r::Geometry::BoundingBox::merge", XS_Slic3r__Geometry__BoundingBox_merge);
        newXS_deffile("Slic3r::Geometry::BoundingBox::merge_point", XS_Slic3r__Geometry__BoundingBox_merge_point);
        newXS_deffile("Slic3r::Geometry::BoundingBox::scale", XS_Slic3r__Geometry__BoundingBox_scale);
        newXS_deffile("Slic3r::Geometry::BoundingBox::translate", XS_Slic3r__Geometry__BoundingBox_translate);
        newXS_deffile("Slic3r::Geometry::BoundingBox::offset", XS_Slic3r__Geometry__BoundingBox_offset);
        newXS_deffile("Slic3r::Geometry::BoundingBox::contains_point", XS_Slic3r__Geometry__BoundingBox_contains_point);
        newXS_deffile("Slic3r::Geometry::BoundingBox::polygon", XS_Slic3r__Geometry__BoundingBox_polygon);
        newXS_deffile("Slic3r::Geometry::BoundingBox::size", XS_Slic3r__Geometry__BoundingBox_size);
        newXS_deffile("Slic3r::Geometry::BoundingBox::center", XS_Slic3r__Geometry__BoundingBox_center);
        newXS_deffile("Slic3r::Geometry::BoundingBox::min_point", XS_Slic3r__Geometry__BoundingBox_min_point);
        newXS_deffile("Slic3r::Geometry::BoundingBox::max_point", XS_Slic3r__Geometry__BoundingBox_max_point);
        newXS_deffile("Slic3r::Geometry::BoundingBox::x_min", XS_Slic3r__Geometry__BoundingBox_x_min);
        newXS_deffile("Slic3r::Geometry::BoundingBox::x_max", XS_Slic3r__Geometry__BoundingBox_x_max);
        newXS_deffile("Slic3r::Geometry::BoundingBox::y_min", XS_Slic3r__Geometry__BoundingBox_y_min);
        newXS_deffile("Slic3r::Geometry::BoundingBox::y_max", XS_Slic3r__Geometry__BoundingBox_y_max);
        newXS_deffile("Slic3r::Geometry::BoundingBox::defined", XS_Slic3r__Geometry__BoundingBox_defined);
        newXS_deffile("Slic3r::Geometry::BoundingBox::new_from_points", XS_Slic3r__Geometry__BoundingBox_new_from_points);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::new", XS_Slic3r__Geometry__BoundingBoxf_new);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::DESTROY", XS_Slic3r__Geometry__BoundingBoxf_DESTROY);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::clone", XS_Slic3r__Geometry__BoundingBoxf_clone);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::merge", XS_Slic3r__Geometry__BoundingBoxf_merge);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::merge_point", XS_Slic3r__Geometry__BoundingBoxf_merge_point);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::scale", XS_Slic3r__Geometry__BoundingBoxf_scale);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::translate", XS_Slic3r__Geometry__BoundingBoxf_translate);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::contains_point", XS_Slic3r__Geometry__BoundingBoxf_contains_point);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::size", XS_Slic3r__Geometry__BoundingBoxf_size);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::center", XS_Slic3r__Geometry__BoundingBoxf_center);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::min_point", XS_Slic3r__Geometry__BoundingBoxf_min_point);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::max_point", XS_Slic3r__Geometry__BoundingBoxf_max_point);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::x_min", XS_Slic3r__Geometry__BoundingBoxf_x_min);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::x_max", XS_Slic3r__Geometry__BoundingBoxf_x_max);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::y_min", XS_Slic3r__Geometry__BoundingBoxf_y_min);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::y_max", XS_Slic3r__Geometry__BoundingBoxf_y_max);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::set_x_min", XS_Slic3r__Geometry__BoundingBoxf_set_x_min);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::set_x_max", XS_Slic3r__Geometry__BoundingBoxf_set_x_max);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::set_y_min", XS_Slic3r__Geometry__BoundingBoxf_set_y_min);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::set_y_max", XS_Slic3r__Geometry__BoundingBoxf_set_y_max);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::defined", XS_Slic3r__Geometry__BoundingBoxf_defined);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf::new_from_points", XS_Slic3r__Geometry__BoundingBoxf_new_from_points);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::new", XS_Slic3r__Geometry__BoundingBoxf3_new);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::DESTROY", XS_Slic3r__Geometry__BoundingBoxf3_DESTROY);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::clone", XS_Slic3r__Geometry__BoundingBoxf3_clone);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::merge", XS_Slic3r__Geometry__BoundingBoxf3_merge);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::merge_point", XS_Slic3r__Geometry__BoundingBoxf3_merge_point);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::scale", XS_Slic3r__Geometry__BoundingBoxf3_scale);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::translate", XS_Slic3r__Geometry__BoundingBoxf3_translate);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::size", XS_Slic3r__Geometry__BoundingBoxf3_size);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::center", XS_Slic3r__Geometry__BoundingBoxf3_center);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::min_point", XS_Slic3r__Geometry__BoundingBoxf3_min_point);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::max_point", XS_Slic3r__Geometry__BoundingBoxf3_max_point);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::x_min", XS_Slic3r__Geometry__BoundingBoxf3_x_min);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::x_max", XS_Slic3r__Geometry__BoundingBoxf3_x_max);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::y_min", XS_Slic3r__Geometry__BoundingBoxf3_y_min);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::y_max", XS_Slic3r__Geometry__BoundingBoxf3_y_max);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::z_min", XS_Slic3r__Geometry__BoundingBoxf3_z_min);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::z_max", XS_Slic3r__Geometry__BoundingBoxf3_z_max);
        newXS_deffile("Slic3r::Geometry::BoundingBoxf3::defined", XS_Slic3r__Geometry__BoundingBoxf3_defined);
        newXS_deffile("Slic3r::GCode::TimeEstimator::new", XS_Slic3r__GCode__TimeEstimator_new);
        newXS_deffile("Slic3r::GCode::TimeEstimator::DESTROY", XS_Slic3r__GCode__TimeEstimator_DESTROY);
        newXS_deffile("Slic3r::GCode::TimeEstimator::time", XS_Slic3r__GCode__TimeEstimator_time);
        newXS_deffile("Slic3r::GCode::TimeEstimator::parse", XS_Slic3r__GCode__TimeEstimator_parse);
        newXS_deffile("Slic3r::GCode::TimeEstimator::parse_file", XS_Slic3r__GCode__TimeEstimator_parse_file);
        newXS_deffile("Slic3r::Model::new", XS_Slic3r__Model_new);
        newXS_deffile("Slic3r::Model::DESTROY", XS_Slic3r__Model_DESTROY);
        newXS_deffile("Slic3r::Model::read_from_file", XS_Slic3r__Model_read_from_file);
        newXS_deffile("Slic3r::Model::clone", XS_Slic3r__Model_clone);
        newXS_deffile("Slic3r::Model::read_stl", XS_Slic3r__Model_read_stl);
        newXS_deffile("Slic3r::Model::read_obj", XS_Slic3r__Model_read_obj);
        newXS_deffile("Slic3r::Model::read_amf", XS_Slic3r__Model_read_amf);
        newXS_deffile("Slic3r::Model::read_tmf", XS_Slic3r__Model_read_tmf);
        newXS_deffile("Slic3r::Model::write_stl", XS_Slic3r__Model_write_stl);
        newXS_deffile("Slic3r::Model::write_obj", XS_Slic3r__Model_write_obj);
        newXS_deffile("Slic3r::Model::write_amf", XS_Slic3r__Model_write_amf);
        newXS_deffile("Slic3r::Model::write_tmf", XS_Slic3r__Model_write_tmf);
        newXS_deffile("Slic3r::Model::_add_object", XS_Slic3r__Model__add_object);
        newXS_deffile("Slic3r::Model::_add_object_clone", XS_Slic3r__Model__add_object_clone);
        newXS_deffile("Slic3r::Model::delete_object", XS_Slic3r__Model_delete_object);
        newXS_deffile("Slic3r::Model::clear_objects", XS_Slic3r__Model_clear_objects);
        newXS_deffile("Slic3r::Model::objects_count", XS_Slic3r__Model_objects_count);
        newXS_deffile("Slic3r::Model::get_object", XS_Slic3r__Model_get_object);
        newXS_deffile("Slic3r::Model::get_material", XS_Slic3r__Model_get_material);
        newXS_deffile("Slic3r::Model::add_material", XS_Slic3r__Model_add_material);
        newXS_deffile("Slic3r::Model::add_material_clone", XS_Slic3r__Model_add_material_clone);
        newXS_deffile("Slic3r::Model::has_material", XS_Slic3r__Model_has_material);
        newXS_deffile("Slic3r::Model::delete_material", XS_Slic3r__Model_delete_material);
        newXS_deffile("Slic3r::Model::clear_materials", XS_Slic3r__Model_clear_materials);
        newXS_deffile("Slic3r::Model::material_names", XS_Slic3r__Model_material_names);
        newXS_deffile("Slic3r::Model::material_count", XS_Slic3r__Model_material_count);
        newXS_deffile("Slic3r::Model::metadata_count", XS_Slic3r__Model_metadata_count);
        newXS_deffile("Slic3r::Model::has_objects_with_no_instances", XS_Slic3r__Model_has_objects_with_no_instances);
        newXS_deffile("Slic3r::Model::add_default_instances", XS_Slic3r__Model_add_default_instances);
        newXS_deffile("Slic3r::Model::bounding_box", XS_Slic3r__Model_bounding_box);
        newXS_deffile("Slic3r::Model::center_instances_around_point", XS_Slic3r__Model_center_instances_around_point);
        newXS_deffile("Slic3r::Model::align_instances_to_origin", XS_Slic3r__Model_align_instances_to_origin);
        newXS_deffile("Slic3r::Model::translate", XS_Slic3r__Model_translate);
        newXS_deffile("Slic3r::Model::mesh", XS_Slic3r__Model_mesh);
        newXS_deffile("Slic3r::Model::raw_mesh", XS_Slic3r__Model_raw_mesh);
        newXS_deffile("Slic3r::Model::objects", XS_Slic3r__Model_objects);
        newXS_deffile("Slic3r::Model::arrange_objects", XS_Slic3r__Model_arrange_objects);
        newXS_deffile("Slic3r::Model::duplicate", XS_Slic3r__Model_duplicate);
        newXS_deffile("Slic3r::Model::duplicate_objects", XS_Slic3r__Model_duplicate_objects);
        newXS_deffile("Slic3r::Model::duplicate_objects_grid", XS_Slic3r__Model_duplicate_objects_grid);
        newXS_deffile("Slic3r::Model::print_info", XS_Slic3r__Model_print_info);
        newXS_deffile("Slic3r::Model::looks_like_multipart_object", XS_Slic3r__Model_looks_like_multipart_object);
        newXS_deffile("Slic3r::Model::convert_multipart_object", XS_Slic3r__Model_convert_multipart_object);
        newXS_deffile("Slic3r::Model::repair", XS_Slic3r__Model_repair);
        newXS_deffile("Slic3r::Model::Material::model", XS_Slic3r__Model__Material_model);
        newXS_deffile("Slic3r::Model::Material::config", XS_Slic3r__Model__Material_config);
        newXS_deffile("Slic3r::Model::Material::get_attribute", XS_Slic3r__Model__Material_get_attribute);
        newXS_deffile("Slic3r::Model::Material::set_attribute", XS_Slic3r__Model__Material_set_attribute);
        newXS_deffile("Slic3r::Model::Material::attributes", XS_Slic3r__Model__Material_attributes);
        newXS_deffile("Slic3r::Model::Object::volumes", XS_Slic3r__Model__Object_volumes);
        newXS_deffile("Slic3r::Model::Object::instances", XS_Slic3r__Model__Object_instances);
        newXS_deffile("Slic3r::Model::Object::invalidate_bounding_box", XS_Slic3r__Model__Object_invalidate_bounding_box);
        newXS_deffile("Slic3r::Model::Object::update_bounding_box", XS_Slic3r__Model__Object_update_bounding_box);
        newXS_deffile("Slic3r::Model::Object::mesh", XS_Slic3r__Model__Object_mesh);
        newXS_deffile("Slic3r::Model::Object::raw_mesh", XS_Slic3r__Model__Object_raw_mesh);
        newXS_deffile("Slic3r::Model::Object::raw_bounding_box", XS_Slic3r__Model__Object_raw_bounding_box);
        newXS_deffile("Slic3r::Model::Object::instance_bounding_box", XS_Slic3r__Model__Object_instance_bounding_box);
        newXS_deffile("Slic3r::Model::Object::_bounding_box", XS_Slic3r__Model__Object__bounding_box);
        newXS_deffile("Slic3r::Model::Object::bounding_box", XS_Slic3r__Model__Object_bounding_box);
        newXS_deffile("Slic3r::Model::Object::_add_volume", XS_Slic3r__Model__Object__add_volume);
        newXS_deffile("Slic3r::Model::Object::_add_volume_clone", XS_Slic3r__Model__Object__add_volume_clone);
        newXS_deffile("Slic3r::Model::Object::delete_volume", XS_Slic3r__Model__Object_delete_volume);
        newXS_deffile("Slic3r::Model::Object::clear_volumes", XS_Slic3r__Model__Object_clear_volumes);
        newXS_deffile("Slic3r::Model::Object::volumes_count", XS_Slic3r__Model__Object_volumes_count);
        newXS_deffile("Slic3r::Model::Object::get_volume", XS_Slic3r__Model__Object_get_volume);
        newXS_deffile("Slic3r::Model::Object::_add_instance", XS_Slic3r__Model__Object__add_instance);
        newXS_deffile("Slic3r::Model::Object::_add_instance_clone", XS_Slic3r__Model__Object__add_instance_clone);
        newXS_deffile("Slic3r::Model::Object::delete_last_instance", XS_Slic3r__Model__Object_delete_last_instance);
        newXS_deffile("Slic3r::Model::Object::clear_instances", XS_Slic3r__Model__Object_clear_instances);
        newXS_deffile("Slic3r::Model::Object::instances_count", XS_Slic3r__Model__Object_instances_count);
        newXS_deffile("Slic3r::Model::Object::get_instance", XS_Slic3r__Model__Object_get_instance);
        newXS_deffile("Slic3r::Model::Object::name", XS_Slic3r__Model__Object_name);
        newXS_deffile("Slic3r::Model::Object::set_name", XS_Slic3r__Model__Object_set_name);
        newXS_deffile("Slic3r::Model::Object::input_file", XS_Slic3r__Model__Object_input_file);
        newXS_deffile("Slic3r::Model::Object::set_input_file", XS_Slic3r__Model__Object_set_input_file);
        newXS_deffile("Slic3r::Model::Object::config", XS_Slic3r__Model__Object_config);
        newXS_deffile("Slic3r::Model::Object::part_number", XS_Slic3r__Model__Object_part_number);
        newXS_deffile("Slic3r::Model::Object::model", XS_Slic3r__Model__Object_model);
        newXS_deffile("Slic3r::Model::Object::layer_height_ranges", XS_Slic3r__Model__Object_layer_height_ranges);
        newXS_deffile("Slic3r::Model::Object::set_layer_height_ranges", XS_Slic3r__Model__Object_set_layer_height_ranges);
        newXS_deffile("Slic3r::Model::Object::layer_height_spline", XS_Slic3r__Model__Object_layer_height_spline);
        newXS_deffile("Slic3r::Model::Object::set_layer_height_spline", XS_Slic3r__Model__Object_set_layer_height_spline);
        newXS_deffile("Slic3r::Model::Object::origin_translation", XS_Slic3r__Model__Object_origin_translation);
        newXS_deffile("Slic3r::Model::Object::set_origin_translation", XS_Slic3r__Model__Object_set_origin_translation);
        newXS_deffile("Slic3r::Model::Object::needed_repair", XS_Slic3r__Model__Object_needed_repair);
        newXS_deffile("Slic3r::Model::Object::materials_count", XS_Slic3r__Model__Object_materials_count);
        newXS_deffile("Slic3r::Model::Object::facets_count", XS_Slic3r__Model__Object_facets_count);
        newXS_deffile("Slic3r::Model::Object::align_to_ground", XS_Slic3r__Model__Object_align_to_ground);
        newXS_deffile("Slic3r::Model::Object::center_around_origin", XS_Slic3r__Model__Object_center_around_origin);
        newXS_deffile("Slic3r::Model::Object::translate", XS_Slic3r__Model__Object_translate);
        newXS_deffile("Slic3r::Model::Object::scale_xyz", XS_Slic3r__Model__Object_scale_xyz);
        newXS_deffile("Slic3r::Model::Object::rotate", XS_Slic3r__Model__Object_rotate);
        newXS_deffile("Slic3r::Model::Object::mirror", XS_Slic3r__Model__Object_mirror);
        newXS_deffile("Slic3r::Model::Object::transform_by_instance", XS_Slic3r__Model__Object_transform_by_instance);
        newXS_deffile("Slic3r::Model::Object::cut", XS_Slic3r__Model__Object_cut);
        newXS_deffile("Slic3r::Model::Object::split_object", XS_Slic3r__Model__Object_split_object);
        newXS_deffile("Slic3r::Model::Object::print_info", XS_Slic3r__Model__Object_print_info);
        newXS_deffile("Slic3r::Model::Object::repair", XS_Slic3r__Model__Object_repair);
        newXS_deffile("Slic3r::Model::Volume::object", XS_Slic3r__Model__Volume_object);
        newXS_deffile("Slic3r::Model::Volume::name", XS_Slic3r__Model__Volume_name);
        newXS_deffile("Slic3r::Model::Volume::set_name", XS_Slic3r__Model__Volume_set_name);
        newXS_deffile("Slic3r::Model::Volume::input_file", XS_Slic3r__Model__Volume_input_file);
        newXS_deffile("Slic3r::Model::Volume::set_input_file", XS_Slic3r__Model__Volume_set_input_file);
        newXS_deffile("Slic3r::Model::Volume::input_file_obj_idx", XS_Slic3r__Model__Volume_input_file_obj_idx);
        newXS_deffile("Slic3r::Model::Volume::set_input_file_obj_idx", XS_Slic3r__Model__Volume_set_input_file_obj_idx);
        newXS_deffile("Slic3r::Model::Volume::input_file_vol_idx", XS_Slic3r__Model__Volume_input_file_vol_idx);
        newXS_deffile("Slic3r::Model::Volume::set_input_file_vol_idx", XS_Slic3r__Model__Volume_set_input_file_vol_idx);
        newXS_deffile("Slic3r::Model::Volume::material_id", XS_Slic3r__Model__Volume_material_id);
        newXS_deffile("Slic3r::Model::Volume::set_material_id", XS_Slic3r__Model__Volume_set_material_id);
        newXS_deffile("Slic3r::Model::Volume::material", XS_Slic3r__Model__Volume_material);
        newXS_deffile("Slic3r::Model::Volume::bounding_box", XS_Slic3r__Model__Volume_bounding_box);
        newXS_deffile("Slic3r::Model::Volume::config", XS_Slic3r__Model__Volume_config);
        newXS_deffile("Slic3r::Model::Volume::mesh", XS_Slic3r__Model__Volume_mesh);
        newXS_deffile("Slic3r::Model::Volume::modifier", XS_Slic3r__Model__Volume_modifier);
        newXS_deffile("Slic3r::Model::Volume::set_modifier", XS_Slic3r__Model__Volume_set_modifier);
        newXS_deffile("Slic3r::Model::Volume::assign_unique_material", XS_Slic3r__Model__Volume_assign_unique_material);
        newXS_deffile("Slic3r::Model::Volume::extrude_tin", XS_Slic3r__Model__Volume_extrude_tin);
        newXS_deffile("Slic3r::Model::Instance::object", XS_Slic3r__Model__Instance_object);
        newXS_deffile("Slic3r::Model::Instance::rotation", XS_Slic3r__Model__Instance_rotation);
        newXS_deffile("Slic3r::Model::Instance::x_rotation", XS_Slic3r__Model__Instance_x_rotation);
        newXS_deffile("Slic3r::Model::Instance::y_rotation", XS_Slic3r__Model__Instance_y_rotation);
        newXS_deffile("Slic3r::Model::Instance::scaling_factor", XS_Slic3r__Model__Instance_scaling_factor);
        newXS_deffile("Slic3r::Model::Instance::scaling_vector", XS_Slic3r__Model__Instance_scaling_vector);
        newXS_deffile("Slic3r::Model::Instance::offset", XS_Slic3r__Model__Instance_offset);
        newXS_deffile("Slic3r::Model::Instance::z_translation", XS_Slic3r__Model__Instance_z_translation);
        newXS_deffile("Slic3r::Model::Instance::set_rotation", XS_Slic3r__Model__Instance_set_rotation);
        newXS_deffile("Slic3r::Model::Instance::set_x_rotation", XS_Slic3r__Model__Instance_set_x_rotation);
        newXS_deffile("Slic3r::Model::Instance::set_y_rotation", XS_Slic3r__Model__Instance_set_y_rotation);
        newXS_deffile("Slic3r::Model::Instance::set_scaling_factor", XS_Slic3r__Model__Instance_set_scaling_factor);
        newXS_deffile("Slic3r::Model::Instance::set_scaling_vector", XS_Slic3r__Model__Instance_set_scaling_vector);
        newXS_deffile("Slic3r::Model::Instance::set_offset", XS_Slic3r__Model__Instance_set_offset);
        newXS_deffile("Slic3r::Model::Instance::set_z_translation", XS_Slic3r__Model__Instance_set_z_translation);
        newXS_deffile("Slic3r::Model::Instance::transform_mesh", XS_Slic3r__Model__Instance_transform_mesh);
        newXS_deffile("Slic3r::Model::Instance::transform_polygon", XS_Slic3r__Model__Instance_transform_polygon);
        newXS_deffile("Slic3r::Config::new", XS_Slic3r__Config_new);
        newXS_deffile("Slic3r::Config::DESTROY", XS_Slic3r__Config_DESTROY);
        newXS_deffile("Slic3r::Config::has", XS_Slic3r__Config_has);
        newXS_deffile("Slic3r::Config::as_hash", XS_Slic3r__Config_as_hash);
        newXS_deffile("Slic3r::Config::get", XS_Slic3r__Config_get);
        newXS_deffile("Slic3r::Config::get_at", XS_Slic3r__Config_get_at);
        newXS_deffile("Slic3r::Config::set", XS_Slic3r__Config_set);
        newXS_deffile("Slic3r::Config::set_deserialize", XS_Slic3r__Config_set_deserialize);
        newXS_deffile("Slic3r::Config::set_ifndef", XS_Slic3r__Config_set_ifndef);
        newXS_deffile("Slic3r::Config::serialize", XS_Slic3r__Config_serialize);
        newXS_deffile("Slic3r::Config::get_abs_value", XS_Slic3r__Config_get_abs_value);
        newXS_deffile("Slic3r::Config::get_abs_value_over", XS_Slic3r__Config_get_abs_value_over);
        newXS_deffile("Slic3r::Config::apply", XS_Slic3r__Config_apply);
        newXS_deffile("Slic3r::Config::apply_only", XS_Slic3r__Config_apply_only);
        newXS_deffile("Slic3r::Config::diff", XS_Slic3r__Config_diff);
        newXS_deffile("Slic3r::Config::diff_static", XS_Slic3r__Config_diff_static);
        newXS_deffile("Slic3r::Config::equals", XS_Slic3r__Config_equals);
        newXS_deffile("Slic3r::Config::apply_static", XS_Slic3r__Config_apply_static);
        newXS_deffile("Slic3r::Config::get_keys", XS_Slic3r__Config_get_keys);
        newXS_deffile("Slic3r::Config::erase", XS_Slic3r__Config_erase);
        newXS_deffile("Slic3r::Config::clear", XS_Slic3r__Config_clear);
        newXS_deffile("Slic3r::Config::empty", XS_Slic3r__Config_empty);
        newXS_deffile("Slic3r::Config::normalize", XS_Slic3r__Config_normalize);
        newXS_deffile("Slic3r::Config::setenv", XS_Slic3r__Config_setenv);
        newXS_deffile("Slic3r::Config::min_object_distance", XS_Slic3r__Config_min_object_distance);
        newXS_deffile("Slic3r::Config::_load", XS_Slic3r__Config__load);
        newXS_deffile("Slic3r::Config::_save", XS_Slic3r__Config__save);
        newXS_deffile("Slic3r::Config::read_cli", XS_Slic3r__Config_read_cli);
        newXS_deffile("Slic3r::Config::Static::new_GCodeConfig", XS_Slic3r__Config__Static_new_GCodeConfig);
        newXS_deffile("Slic3r::Config::Static::new_PrintConfig", XS_Slic3r__Config__Static_new_PrintConfig);
        newXS_deffile("Slic3r::Config::Static::new_PrintObjectConfig", XS_Slic3r__Config__Static_new_PrintObjectConfig);
        newXS_deffile("Slic3r::Config::Static::new_PrintRegionConfig", XS_Slic3r__Config__Static_new_PrintRegionConfig);
        newXS_deffile("Slic3r::Config::Static::new_FullPrintConfig", XS_Slic3r__Config__Static_new_FullPrintConfig);
        newXS_deffile("Slic3r::Config::Static::new_SLAPrintConfig", XS_Slic3r__Config__Static_new_SLAPrintConfig);
        newXS_deffile("Slic3r::Config::Static::DESTROY", XS_Slic3r__Config__Static_DESTROY);
        newXS_deffile("Slic3r::Config::Static::has", XS_Slic3r__Config__Static_has);
        newXS_deffile("Slic3r::Config::Static::as_hash", XS_Slic3r__Config__Static_as_hash);
        newXS_deffile("Slic3r::Config::Static::get", XS_Slic3r__Config__Static_get);
        newXS_deffile("Slic3r::Config::Static::get_at", XS_Slic3r__Config__Static_get_at);
        newXS_deffile("Slic3r::Config::Static::set", XS_Slic3r__Config__Static_set);
        newXS_deffile("Slic3r::Config::Static::set_deserialize", XS_Slic3r__Config__Static_set_deserialize);
        newXS_deffile("Slic3r::Config::Static::set_ifndef", XS_Slic3r__Config__Static_set_ifndef);
        newXS_deffile("Slic3r::Config::Static::serialize", XS_Slic3r__Config__Static_serialize);
        newXS_deffile("Slic3r::Config::Static::get_abs_value", XS_Slic3r__Config__Static_get_abs_value);
        newXS_deffile("Slic3r::Config::Static::get_abs_value_over", XS_Slic3r__Config__Static_get_abs_value_over);
        newXS_deffile("Slic3r::Config::Static::apply_static", XS_Slic3r__Config__Static_apply_static);
        newXS_deffile("Slic3r::Config::Static::apply_dynamic", XS_Slic3r__Config__Static_apply_dynamic);
        newXS_deffile("Slic3r::Config::Static::get_keys", XS_Slic3r__Config__Static_get_keys);
        newXS_deffile("Slic3r::Config::Static::get_extrusion_axis", XS_Slic3r__Config__Static_get_extrusion_axis);
        newXS_deffile("Slic3r::Config::Static::setenv", XS_Slic3r__Config__Static_setenv);
        newXS_deffile("Slic3r::Config::Static::min_object_distance", XS_Slic3r__Config__Static_min_object_distance);
        newXS_deffile("Slic3r::Config::Static::_load", XS_Slic3r__Config__Static__load);
        newXS_deffile("Slic3r::Config::Static::_save", XS_Slic3r__Config__Static__save);
        newXS_deffile("Slic3r::Config::Static::dynamic", XS_Slic3r__Config__Static_dynamic);
        newXS_deffile("Slic3r::Config::print_config_def", XS_Slic3r__Config_print_config_def);
        newXS_deffile("Slic3r::LayerHeightSpline::new", XS_Slic3r__LayerHeightSpline_new);
        newXS_deffile("Slic3r::LayerHeightSpline::clone", XS_Slic3r__LayerHeightSpline_clone);
        newXS_deffile("Slic3r::LayerHeightSpline::setObjectHeight", XS_Slic3r__LayerHeightSpline_setObjectHeight);
        newXS_deffile("Slic3r::LayerHeightSpline::hasData", XS_Slic3r__LayerHeightSpline_hasData);
        newXS_deffile("Slic3r::LayerHeightSpline::setLayers", XS_Slic3r__LayerHeightSpline_setLayers);
        newXS_deffile("Slic3r::LayerHeightSpline::updateLayerHeights", XS_Slic3r__LayerHeightSpline_updateLayerHeights);
        newXS_deffile("Slic3r::LayerHeightSpline::layersUpdated", XS_Slic3r__LayerHeightSpline_layersUpdated);
        newXS_deffile("Slic3r::LayerHeightSpline::layerHeightsUpdated", XS_Slic3r__LayerHeightSpline_layerHeightsUpdated);
        newXS_deffile("Slic3r::LayerHeightSpline::clear", XS_Slic3r__LayerHeightSpline_clear);
        newXS_deffile("Slic3r::LayerHeightSpline::getOriginalLayers", XS_Slic3r__LayerHeightSpline_getOriginalLayers);
        newXS_deffile("Slic3r::LayerHeightSpline::getInterpolatedLayers", XS_Slic3r__LayerHeightSpline_getInterpolatedLayers);
        newXS_deffile("Slic3r::LayerHeightSpline::getLayerHeightAt", XS_Slic3r__LayerHeightSpline_getLayerHeightAt);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVertexArray::new", XS_Slic3r__GUI___3DScene__GLVertexArray_new);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVertexArray::DESTROY", XS_Slic3r__GUI___3DScene__GLVertexArray_DESTROY);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVertexArray::load_mesh", XS_Slic3r__GUI___3DScene__GLVertexArray_load_mesh);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVertexArray::size", XS_Slic3r__GUI___3DScene__GLVertexArray_size);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVertexArray::verts_ptr", XS_Slic3r__GUI___3DScene__GLVertexArray_verts_ptr);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVertexArray::norms_ptr", XS_Slic3r__GUI___3DScene__GLVertexArray_norms_ptr);
        newXS_deffile("Slic3r::GUI::_3DScene::GLVertexArray::get_point", XS_Slic3r__GUI___3DScene__GLVertexArray_get_point);
        newXS_deffile("Slic3r::GUI::_3DScene::_extrusionentity_to_verts_do", XS_Slic3r__GUI___3DScene__extrusionentity_to_verts_do);
        (void)newXSproto_portable("Slic3r::Print::SupportMaterial::MARGIN", XS_Slic3r__Print__SupportMaterial_MARGIN, file, "");
        newXS_deffile("Slic3r::GCode::Writer::new", XS_Slic3r__GCode__Writer_new);
        newXS_deffile("Slic3r::GCode::Writer::DESTROY", XS_Slic3r__GCode__Writer_DESTROY);
        newXS_deffile("Slic3r::GCode::Writer::config", XS_Slic3r__GCode__Writer_config);
        newXS_deffile("Slic3r::GCode::Writer::multiple_extruders", XS_Slic3r__GCode__Writer_multiple_extruders);
        newXS_deffile("Slic3r::GCode::Writer::extruder", XS_Slic3r__GCode__Writer_extruder);
        newXS_deffile("Slic3r::GCode::Writer::extrusion_axis", XS_Slic3r__GCode__Writer_extrusion_axis);
        newXS_deffile("Slic3r::GCode::Writer::apply_print_config", XS_Slic3r__GCode__Writer_apply_print_config);
        newXS_deffile("Slic3r::GCode::Writer::set_extruders", XS_Slic3r__GCode__Writer_set_extruders);
        newXS_deffile("Slic3r::GCode::Writer::notes", XS_Slic3r__GCode__Writer_notes);
        newXS_deffile("Slic3r::GCode::Writer::preamble", XS_Slic3r__GCode__Writer_preamble);
        newXS_deffile("Slic3r::GCode::Writer::postamble", XS_Slic3r__GCode__Writer_postamble);
        newXS_deffile("Slic3r::GCode::Writer::set_temperature", XS_Slic3r__GCode__Writer_set_temperature);
        newXS_deffile("Slic3r::GCode::Writer::set_bed_temperature", XS_Slic3r__GCode__Writer_set_bed_temperature);
        newXS_deffile("Slic3r::GCode::Writer::set_fan", XS_Slic3r__GCode__Writer_set_fan);
        newXS_deffile("Slic3r::GCode::Writer::set_acceleration", XS_Slic3r__GCode__Writer_set_acceleration);
        newXS_deffile("Slic3r::GCode::Writer::reset_e", XS_Slic3r__GCode__Writer_reset_e);
        newXS_deffile("Slic3r::GCode::Writer::update_progress", XS_Slic3r__GCode__Writer_update_progress);
        newXS_deffile("Slic3r::GCode::Writer::need_toolchange", XS_Slic3r__GCode__Writer_need_toolchange);
        newXS_deffile("Slic3r::GCode::Writer::set_extruder", XS_Slic3r__GCode__Writer_set_extruder);
        newXS_deffile("Slic3r::GCode::Writer::toolchange", XS_Slic3r__GCode__Writer_toolchange);
        newXS_deffile("Slic3r::GCode::Writer::set_speed", XS_Slic3r__GCode__Writer_set_speed);
        newXS_deffile("Slic3r::GCode::Writer::travel_to_xy", XS_Slic3r__GCode__Writer_travel_to_xy);
        newXS_deffile("Slic3r::GCode::Writer::travel_to_xyz", XS_Slic3r__GCode__Writer_travel_to_xyz);
        newXS_deffile("Slic3r::GCode::Writer::travel_to_z", XS_Slic3r__GCode__Writer_travel_to_z);
        newXS_deffile("Slic3r::GCode::Writer::will_move_z", XS_Slic3r__GCode__Writer_will_move_z);
        newXS_deffile("Slic3r::GCode::Writer::extrude_to_xy", XS_Slic3r__GCode__Writer_extrude_to_xy);
        newXS_deffile("Slic3r::GCode::Writer::extrude_to_xyz", XS_Slic3r__GCode__Writer_extrude_to_xyz);
        newXS_deffile("Slic3r::GCode::Writer::retract", XS_Slic3r__GCode__Writer_retract);
        newXS_deffile("Slic3r::GCode::Writer::retract_for_toolchange", XS_Slic3r__GCode__Writer_retract_for_toolchange);
        newXS_deffile("Slic3r::GCode::Writer::unretract", XS_Slic3r__GCode__Writer_unretract);
        newXS_deffile("Slic3r::GCode::Writer::lift", XS_Slic3r__GCode__Writer_lift);
        newXS_deffile("Slic3r::GCode::Writer::unlift", XS_Slic3r__GCode__Writer_unlift);
        newXS_deffile("Slic3r::GCode::Writer::get_position", XS_Slic3r__GCode__Writer_get_position);
        newXS_deffile("Slic3r::GCode::Writer::extruders", XS_Slic3r__GCode__Writer_extruders);
        newXS_deffile("Slic3r::Surface::DESTROY", XS_Slic3r__Surface_DESTROY);
        newXS_deffile("Slic3r::Surface::expolygon", XS_Slic3r__Surface_expolygon);
        newXS_deffile("Slic3r::Surface::thickness", XS_Slic3r__Surface_thickness);
        newXS_deffile("Slic3r::Surface::thickness_layers", XS_Slic3r__Surface_thickness_layers);
        newXS_deffile("Slic3r::Surface::area", XS_Slic3r__Surface_area);
        newXS_deffile("Slic3r::Surface::is_solid", XS_Slic3r__Surface_is_solid);
        newXS_deffile("Slic3r::Surface::is_external", XS_Slic3r__Surface_is_external);
        newXS_deffile("Slic3r::Surface::is_internal", XS_Slic3r__Surface_is_internal);
        newXS_deffile("Slic3r::Surface::is_bottom", XS_Slic3r__Surface_is_bottom);
        newXS_deffile("Slic3r::Surface::is_top", XS_Slic3r__Surface_is_top);
        newXS_deffile("Slic3r::Surface::is_bridge", XS_Slic3r__Surface_is_bridge);
        newXS_deffile("Slic3r::Surface::_new", XS_Slic3r__Surface__new);
        newXS_deffile("Slic3r::Surface::surface_type", XS_Slic3r__Surface_surface_type);
        newXS_deffile("Slic3r::Surface::bridge_angle", XS_Slic3r__Surface_bridge_angle);
        newXS_deffile("Slic3r::Surface::extra_perimeters", XS_Slic3r__Surface_extra_perimeters);
        newXS_deffile("Slic3r::Surface::polygons", XS_Slic3r__Surface_polygons);
        newXS_deffile("Slic3r::Surface::offset", XS_Slic3r__Surface_offset);
        cv = newXSproto_portable("Slic3r::Surface::S_TYPE_BOTTOM", XS_Slic3r__Surface__constant, file, "");
        XSANY.any_i32 = stBottom;
        cv = newXSproto_portable("Slic3r::Surface::S_TYPE_BRIDGE", XS_Slic3r__Surface__constant, file, "");
        XSANY.any_i32 = stBridge;
        cv = newXSproto_portable("Slic3r::Surface::S_TYPE_INTERNAL", XS_Slic3r__Surface__constant, file, "");
        XSANY.any_i32 = stInternal;
        cv = newXSproto_portable("Slic3r::Surface::S_TYPE_SOLID", XS_Slic3r__Surface__constant, file, "");
        XSANY.any_i32 = stSolid;
        cv = newXSproto_portable("Slic3r::Surface::S_TYPE_TOP", XS_Slic3r__Surface__constant, file, "");
        XSANY.any_i32 = stTop;
        cv = newXSproto_portable("Slic3r::Surface::S_TYPE_VOID", XS_Slic3r__Surface__constant, file, "");
        XSANY.any_i32 = stVoid;
        cv = newXSproto_portable("Slic3r::Surface::_constant", XS_Slic3r__Surface__constant, file, "");
        XSANY.any_i32 = 0;
        newXS_deffile("Slic3r::GCode::AvoidCrossingPerimeters::new", XS_Slic3r__GCode__AvoidCrossingPerimeters_new);
        newXS_deffile("Slic3r::GCode::AvoidCrossingPerimeters::DESTROY", XS_Slic3r__GCode__AvoidCrossingPerimeters_DESTROY);
        newXS_deffile("Slic3r::GCode::AvoidCrossingPerimeters::init_external_mp", XS_Slic3r__GCode__AvoidCrossingPerimeters_init_external_mp);
        newXS_deffile("Slic3r::GCode::AvoidCrossingPerimeters::init_layer_mp", XS_Slic3r__GCode__AvoidCrossingPerimeters_init_layer_mp);
        newXS_deffile("Slic3r::GCode::AvoidCrossingPerimeters::travel_to", XS_Slic3r__GCode__AvoidCrossingPerimeters_travel_to);
        newXS_deffile("Slic3r::GCode::AvoidCrossingPerimeters::use_external_mp", XS_Slic3r__GCode__AvoidCrossingPerimeters_use_external_mp);
        newXS_deffile("Slic3r::GCode::AvoidCrossingPerimeters::set_use_external_mp", XS_Slic3r__GCode__AvoidCrossingPerimeters_set_use_external_mp);
        newXS_deffile("Slic3r::GCode::AvoidCrossingPerimeters::use_external_mp_once", XS_Slic3r__GCode__AvoidCrossingPerimeters_use_external_mp_once);
        newXS_deffile("Slic3r::GCode::AvoidCrossingPerimeters::set_use_external_mp_once", XS_Slic3r__GCode__AvoidCrossingPerimeters_set_use_external_mp_once);
        newXS_deffile("Slic3r::GCode::AvoidCrossingPerimeters::disable_once", XS_Slic3r__GCode__AvoidCrossingPerimeters_disable_once);
        newXS_deffile("Slic3r::GCode::AvoidCrossingPerimeters::set_disable_once", XS_Slic3r__GCode__AvoidCrossingPerimeters_set_disable_once);
        newXS_deffile("Slic3r::GCode::OozePrevention::new", XS_Slic3r__GCode__OozePrevention_new);
        newXS_deffile("Slic3r::GCode::OozePrevention::DESTROY", XS_Slic3r__GCode__OozePrevention_DESTROY);
        newXS_deffile("Slic3r::GCode::OozePrevention::enable", XS_Slic3r__GCode__OozePrevention_enable);
        newXS_deffile("Slic3r::GCode::OozePrevention::set_enable", XS_Slic3r__GCode__OozePrevention_set_enable);
        newXS_deffile("Slic3r::GCode::OozePrevention::standby_points", XS_Slic3r__GCode__OozePrevention_standby_points);
        newXS_deffile("Slic3r::GCode::OozePrevention::set_standby_points", XS_Slic3r__GCode__OozePrevention_set_standby_points);
        newXS_deffile("Slic3r::GCode::OozePrevention::pre_toolchange", XS_Slic3r__GCode__OozePrevention_pre_toolchange);
        newXS_deffile("Slic3r::GCode::OozePrevention::post_toolchange", XS_Slic3r__GCode__OozePrevention_post_toolchange);
        newXS_deffile("Slic3r::GCode::Wipe::new", XS_Slic3r__GCode__Wipe_new);
        newXS_deffile("Slic3r::GCode::Wipe::DESTROY", XS_Slic3r__GCode__Wipe_DESTROY);
        newXS_deffile("Slic3r::GCode::Wipe::has_path", XS_Slic3r__GCode__Wipe_has_path);
        newXS_deffile("Slic3r::GCode::Wipe::reset_path", XS_Slic3r__GCode__Wipe_reset_path);
        newXS_deffile("Slic3r::GCode::Wipe::wipe", XS_Slic3r__GCode__Wipe_wipe);
        newXS_deffile("Slic3r::GCode::Wipe::enable", XS_Slic3r__GCode__Wipe_enable);
        newXS_deffile("Slic3r::GCode::Wipe::set_enable", XS_Slic3r__GCode__Wipe_set_enable);
        newXS_deffile("Slic3r::GCode::Wipe::path", XS_Slic3r__GCode__Wipe_path);
        newXS_deffile("Slic3r::GCode::Wipe::set_path", XS_Slic3r__GCode__Wipe_set_path);
        newXS_deffile("Slic3r::GCode::CoolingBuffer::new", XS_Slic3r__GCode__CoolingBuffer_new);
        newXS_deffile("Slic3r::GCode::CoolingBuffer::DESTROY", XS_Slic3r__GCode__CoolingBuffer_DESTROY);
        newXS_deffile("Slic3r::GCode::CoolingBuffer::gcodegen", XS_Slic3r__GCode__CoolingBuffer_gcodegen);
        newXS_deffile("Slic3r::GCode::CoolingBuffer::append", XS_Slic3r__GCode__CoolingBuffer_append);
        newXS_deffile("Slic3r::GCode::CoolingBuffer::flush", XS_Slic3r__GCode__CoolingBuffer_flush);
        newXS_deffile("Slic3r::GCode::SpiralVase::new", XS_Slic3r__GCode__SpiralVase_new);
        newXS_deffile("Slic3r::GCode::SpiralVase::DESTROY", XS_Slic3r__GCode__SpiralVase_DESTROY);
        newXS_deffile("Slic3r::GCode::SpiralVase::enable", XS_Slic3r__GCode__SpiralVase_enable);
        newXS_deffile("Slic3r::GCode::SpiralVase::set_enable", XS_Slic3r__GCode__SpiralVase_set_enable);
        newXS_deffile("Slic3r::GCode::SpiralVase::process_layer", XS_Slic3r__GCode__SpiralVase_process_layer);
        newXS_deffile("Slic3r::GCode::new", XS_Slic3r__GCode_new);
        newXS_deffile("Slic3r::GCode::DESTROY", XS_Slic3r__GCode_DESTROY);
        newXS_deffile("Slic3r::GCode::origin", XS_Slic3r__GCode_origin);
        newXS_deffile("Slic3r::GCode::config", XS_Slic3r__GCode_config);
        newXS_deffile("Slic3r::GCode::writer", XS_Slic3r__GCode_writer);
        newXS_deffile("Slic3r::GCode::placeholder_parser", XS_Slic3r__GCode_placeholder_parser);
        newXS_deffile("Slic3r::GCode::set_placeholder_parser", XS_Slic3r__GCode_set_placeholder_parser);
        newXS_deffile("Slic3r::GCode::ooze_prevention", XS_Slic3r__GCode_ooze_prevention);
        newXS_deffile("Slic3r::GCode::wipe", XS_Slic3r__GCode_wipe);
        newXS_deffile("Slic3r::GCode::avoid_crossing_perimeters", XS_Slic3r__GCode_avoid_crossing_perimeters);
        newXS_deffile("Slic3r::GCode::enable_loop_clipping", XS_Slic3r__GCode_enable_loop_clipping);
        newXS_deffile("Slic3r::GCode::set_enable_loop_clipping", XS_Slic3r__GCode_set_enable_loop_clipping);
        newXS_deffile("Slic3r::GCode::enable_cooling_markers", XS_Slic3r__GCode_enable_cooling_markers);
        newXS_deffile("Slic3r::GCode::set_enable_cooling_markers", XS_Slic3r__GCode_set_enable_cooling_markers);
        newXS_deffile("Slic3r::GCode::layer_count", XS_Slic3r__GCode_layer_count);
        newXS_deffile("Slic3r::GCode::set_layer_count", XS_Slic3r__GCode_set_layer_count);
        newXS_deffile("Slic3r::GCode::layer_index", XS_Slic3r__GCode_layer_index);
        newXS_deffile("Slic3r::GCode::set_layer_index", XS_Slic3r__GCode_set_layer_index);
        newXS_deffile("Slic3r::GCode::has_layer", XS_Slic3r__GCode_has_layer);
        newXS_deffile("Slic3r::GCode::layer", XS_Slic3r__GCode_layer);
        newXS_deffile("Slic3r::GCode::set_layer", XS_Slic3r__GCode_set_layer);
        newXS_deffile("Slic3r::GCode::first_layer", XS_Slic3r__GCode_first_layer);
        newXS_deffile("Slic3r::GCode::set_first_layer", XS_Slic3r__GCode_set_first_layer);
        newXS_deffile("Slic3r::GCode::elapsed_time", XS_Slic3r__GCode_elapsed_time);
        newXS_deffile("Slic3r::GCode::set_elapsed_time", XS_Slic3r__GCode_set_elapsed_time);
        newXS_deffile("Slic3r::GCode::last_pos_defined", XS_Slic3r__GCode_last_pos_defined);
        newXS_deffile("Slic3r::GCode::last_pos", XS_Slic3r__GCode_last_pos);
        newXS_deffile("Slic3r::GCode::set_last_pos", XS_Slic3r__GCode_set_last_pos);
        newXS_deffile("Slic3r::GCode::volumetric_speed", XS_Slic3r__GCode_volumetric_speed);
        newXS_deffile("Slic3r::GCode::set_volumetric_speed", XS_Slic3r__GCode_set_volumetric_speed);
        newXS_deffile("Slic3r::GCode::apply_print_config", XS_Slic3r__GCode_apply_print_config);
        newXS_deffile("Slic3r::GCode::set_extruders", XS_Slic3r__GCode_set_extruders);
        newXS_deffile("Slic3r::GCode::set_origin", XS_Slic3r__GCode_set_origin);
        newXS_deffile("Slic3r::GCode::preamble", XS_Slic3r__GCode_preamble);
        newXS_deffile("Slic3r::GCode::notes", XS_Slic3r__GCode_notes);
        newXS_deffile("Slic3r::GCode::change_layer", XS_Slic3r__GCode_change_layer);
        newXS_deffile("Slic3r::GCode::extrude_loop", XS_Slic3r__GCode_extrude_loop);
        newXS_deffile("Slic3r::GCode::extrude_path", XS_Slic3r__GCode_extrude_path);
        newXS_deffile("Slic3r::GCode::travel_to", XS_Slic3r__GCode_travel_to);
        newXS_deffile("Slic3r::GCode::needs_retraction", XS_Slic3r__GCode_needs_retraction);
        newXS_deffile("Slic3r::GCode::retract", XS_Slic3r__GCode_retract);
        newXS_deffile("Slic3r::GCode::unretract", XS_Slic3r__GCode_unretract);
        newXS_deffile("Slic3r::GCode::set_extruder", XS_Slic3r__GCode_set_extruder);
        newXS_deffile("Slic3r::GCode::point_to_gcode", XS_Slic3r__GCode_point_to_gcode);
        newXS_deffile("Slic3r::GCode::extrude", XS_Slic3r__GCode_extrude);
        newXS_deffile("Slic3r::Line::DESTROY", XS_Slic3r__Line_DESTROY);
        newXS_deffile("Slic3r::Line::clone", XS_Slic3r__Line_clone);
        newXS_deffile("Slic3r::Line::arrayref", XS_Slic3r__Line_arrayref);
        newXS_deffile("Slic3r::Line::pp", XS_Slic3r__Line_pp);
        newXS_deffile("Slic3r::Line::a", XS_Slic3r__Line_a);
        newXS_deffile("Slic3r::Line::b", XS_Slic3r__Line_b);
        newXS_deffile("Slic3r::Line::reverse", XS_Slic3r__Line_reverse);
        newXS_deffile("Slic3r::Line::scale", XS_Slic3r__Line_scale);
        newXS_deffile("Slic3r::Line::translate", XS_Slic3r__Line_translate);
        newXS_deffile("Slic3r::Line::length", XS_Slic3r__Line_length);
        newXS_deffile("Slic3r::Line::atan2_", XS_Slic3r__Line_atan2_);
        newXS_deffile("Slic3r::Line::orientation", XS_Slic3r__Line_orientation);
        newXS_deffile("Slic3r::Line::direction", XS_Slic3r__Line_direction);
        newXS_deffile("Slic3r::Line::parallel_to", XS_Slic3r__Line_parallel_to);
        newXS_deffile("Slic3r::Line::parallel_to_line", XS_Slic3r__Line_parallel_to_line);
        newXS_deffile("Slic3r::Line::midpoint", XS_Slic3r__Line_midpoint);
        newXS_deffile("Slic3r::Line::point_at", XS_Slic3r__Line_point_at);
        newXS_deffile("Slic3r::Line::intersection_infinite", XS_Slic3r__Line_intersection_infinite);
        newXS_deffile("Slic3r::Line::as_polyline", XS_Slic3r__Line_as_polyline);
        newXS_deffile("Slic3r::Line::normal", XS_Slic3r__Line_normal);
        newXS_deffile("Slic3r::Line::vector", XS_Slic3r__Line_vector);
        newXS_deffile("Slic3r::Line::ccw", XS_Slic3r__Line_ccw);
        newXS_deffile("Slic3r::Line::new", XS_Slic3r__Line_new);
        newXS_deffile("Slic3r::Line::rotate", XS_Slic3r__Line_rotate);
        newXS_deffile("Slic3r::Line::coincides_with", XS_Slic3r__Line_coincides_with);
        newXS_deffile("Slic3r::Linef3::new", XS_Slic3r__Linef3_new);
        newXS_deffile("Slic3r::Linef3::DESTROY", XS_Slic3r__Linef3_DESTROY);
        newXS_deffile("Slic3r::Linef3::clone", XS_Slic3r__Linef3_clone);
        newXS_deffile("Slic3r::Linef3::a", XS_Slic3r__Linef3_a);
        newXS_deffile("Slic3r::Linef3::b", XS_Slic3r__Linef3_b);
        newXS_deffile("Slic3r::Linef3::intersect_plane", XS_Slic3r__Linef3_intersect_plane);
        newXS_deffile("Slic3r::Linef3::scale", XS_Slic3r__Linef3_scale);
        newXS_deffile("Slic3r::Polygon::DESTROY", XS_Slic3r__Polygon_DESTROY);
        newXS_deffile("Slic3r::Polygon::clone", XS_Slic3r__Polygon_clone);
        newXS_deffile("Slic3r::Polygon::arrayref", XS_Slic3r__Polygon_arrayref);
        newXS_deffile("Slic3r::Polygon::pp", XS_Slic3r__Polygon_pp);
        newXS_deffile("Slic3r::Polygon::scale", XS_Slic3r__Polygon_scale);
        newXS_deffile("Slic3r::Polygon::translate", XS_Slic3r__Polygon_translate);
        newXS_deffile("Slic3r::Polygon::reverse", XS_Slic3r__Polygon_reverse);
        newXS_deffile("Slic3r::Polygon::lines", XS_Slic3r__Polygon_lines);
        newXS_deffile("Slic3r::Polygon::split_at_vertex", XS_Slic3r__Polygon_split_at_vertex);
        newXS_deffile("Slic3r::Polygon::split_at_index", XS_Slic3r__Polygon_split_at_index);
        newXS_deffile("Slic3r::Polygon::split_at_first_point", XS_Slic3r__Polygon_split_at_first_point);
        newXS_deffile("Slic3r::Polygon::equally_spaced_points", XS_Slic3r__Polygon_equally_spaced_points);
        newXS_deffile("Slic3r::Polygon::length", XS_Slic3r__Polygon_length);
        newXS_deffile("Slic3r::Polygon::area", XS_Slic3r__Polygon_area);
        newXS_deffile("Slic3r::Polygon::is_counter_clockwise", XS_Slic3r__Polygon_is_counter_clockwise);
        newXS_deffile("Slic3r::Polygon::is_clockwise", XS_Slic3r__Polygon_is_clockwise);
        newXS_deffile("Slic3r::Polygon::make_counter_clockwise", XS_Slic3r__Polygon_make_counter_clockwise);
        newXS_deffile("Slic3r::Polygon::make_clockwise", XS_Slic3r__Polygon_make_clockwise);
        newXS_deffile("Slic3r::Polygon::is_valid", XS_Slic3r__Polygon_is_valid);
        newXS_deffile("Slic3r::Polygon::first_point", XS_Slic3r__Polygon_first_point);
        newXS_deffile("Slic3r::Polygon::contains_point", XS_Slic3r__Polygon_contains_point);
        newXS_deffile("Slic3r::Polygon::simplify", XS_Slic3r__Polygon_simplify);
        newXS_deffile("Slic3r::Polygon::triangulate_convex", XS_Slic3r__Polygon_triangulate_convex);
        newXS_deffile("Slic3r::Polygon::centroid", XS_Slic3r__Polygon_centroid);
        newXS_deffile("Slic3r::Polygon::bounding_box", XS_Slic3r__Polygon_bounding_box);
        newXS_deffile("Slic3r::Polygon::wkt", XS_Slic3r__Polygon_wkt);
        newXS_deffile("Slic3r::Polygon::concave_points", XS_Slic3r__Polygon_concave_points);
        newXS_deffile("Slic3r::Polygon::convex_points", XS_Slic3r__Polygon_convex_points);
        newXS_deffile("Slic3r::Polygon::intersection", XS_Slic3r__Polygon_intersection);
        newXS_deffile("Slic3r::Polygon::new", XS_Slic3r__Polygon_new);
        newXS_deffile("Slic3r::Polygon::rotate", XS_Slic3r__Polygon_rotate);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::new", XS_Slic3r__Layer__PerimeterGenerator_new);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::DESTROY", XS_Slic3r__Layer__PerimeterGenerator_DESTROY);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::set_lower_slices", XS_Slic3r__Layer__PerimeterGenerator_set_lower_slices);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::set_layer_id", XS_Slic3r__Layer__PerimeterGenerator_set_layer_id);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::set_perimeter_flow", XS_Slic3r__Layer__PerimeterGenerator_set_perimeter_flow);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::set_ext_perimeter_flow", XS_Slic3r__Layer__PerimeterGenerator_set_ext_perimeter_flow);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::set_overhang_flow", XS_Slic3r__Layer__PerimeterGenerator_set_overhang_flow);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::set_solid_infill_flow", XS_Slic3r__Layer__PerimeterGenerator_set_solid_infill_flow);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::config", XS_Slic3r__Layer__PerimeterGenerator_config);
        newXS_deffile("Slic3r::Layer::PerimeterGenerator::process", XS_Slic3r__Layer__PerimeterGenerator_process);
        newXS_deffile("Slic3r::GCode::PlaceholderParser::new", XS_Slic3r__GCode__PlaceholderParser_new);
        newXS_deffile("Slic3r::GCode::PlaceholderParser::DESTROY", XS_Slic3r__GCode__PlaceholderParser_DESTROY);
        newXS_deffile("Slic3r::GCode::PlaceholderParser::clone", XS_Slic3r__GCode__PlaceholderParser_clone);
        newXS_deffile("Slic3r::GCode::PlaceholderParser::update_timestamp", XS_Slic3r__GCode__PlaceholderParser_update_timestamp);
        newXS_deffile("Slic3r::GCode::PlaceholderParser::apply_env_variables", XS_Slic3r__GCode__PlaceholderParser_apply_env_variables);
        newXS_deffile("Slic3r::GCode::PlaceholderParser::apply_config", XS_Slic3r__GCode__PlaceholderParser_apply_config);
        newXS_deffile("Slic3r::GCode::PlaceholderParser::set", XS_Slic3r__GCode__PlaceholderParser_set);
        newXS_deffile("Slic3r::GCode::PlaceholderParser::set_multiple", XS_Slic3r__GCode__PlaceholderParser_set_multiple);
        newXS_deffile("Slic3r::GCode::PlaceholderParser::process", XS_Slic3r__GCode__PlaceholderParser_process);
        newXS_deffile("Slic3r::ExtrusionPath::DESTROY", XS_Slic3r__ExtrusionPath_DESTROY);
        newXS_deffile("Slic3r::ExtrusionPath::arrayref", XS_Slic3r__ExtrusionPath_arrayref);
        newXS_deffile("Slic3r::ExtrusionPath::pp", XS_Slic3r__ExtrusionPath_pp);
        newXS_deffile("Slic3r::ExtrusionPath::pop_back", XS_Slic3r__ExtrusionPath_pop_back);
        newXS_deffile("Slic3r::ExtrusionPath::reverse", XS_Slic3r__ExtrusionPath_reverse);
        newXS_deffile("Slic3r::ExtrusionPath::lines", XS_Slic3r__ExtrusionPath_lines);
        newXS_deffile("Slic3r::ExtrusionPath::first_point", XS_Slic3r__ExtrusionPath_first_point);
        newXS_deffile("Slic3r::ExtrusionPath::last_point", XS_Slic3r__ExtrusionPath_last_point);
        newXS_deffile("Slic3r::ExtrusionPath::clip_end", XS_Slic3r__ExtrusionPath_clip_end);
        newXS_deffile("Slic3r::ExtrusionPath::simplify", XS_Slic3r__ExtrusionPath_simplify);
        newXS_deffile("Slic3r::ExtrusionPath::length", XS_Slic3r__ExtrusionPath_length);
        newXS_deffile("Slic3r::ExtrusionPath::is_perimeter", XS_Slic3r__ExtrusionPath_is_perimeter);
        newXS_deffile("Slic3r::ExtrusionPath::is_infill", XS_Slic3r__ExtrusionPath_is_infill);
        newXS_deffile("Slic3r::ExtrusionPath::is_solid_infill", XS_Slic3r__ExtrusionPath_is_solid_infill);
        newXS_deffile("Slic3r::ExtrusionPath::is_bridge", XS_Slic3r__ExtrusionPath_is_bridge);
        newXS_deffile("Slic3r::ExtrusionPath::grow", XS_Slic3r__ExtrusionPath_grow);
        newXS_deffile("Slic3r::ExtrusionPath::as_polyline", XS_Slic3r__ExtrusionPath_as_polyline);
        newXS_deffile("Slic3r::ExtrusionPath::_new", XS_Slic3r__ExtrusionPath__new);
        newXS_deffile("Slic3r::ExtrusionPath::polyline", XS_Slic3r__ExtrusionPath_polyline);
        newXS_deffile("Slic3r::ExtrusionPath::role", XS_Slic3r__ExtrusionPath_role);
        newXS_deffile("Slic3r::ExtrusionPath::mm3_per_mm", XS_Slic3r__ExtrusionPath_mm3_per_mm);
        newXS_deffile("Slic3r::ExtrusionPath::width", XS_Slic3r__ExtrusionPath_width);
        newXS_deffile("Slic3r::ExtrusionPath::height", XS_Slic3r__ExtrusionPath_height);
        newXS_deffile("Slic3r::ExtrusionPath::append", XS_Slic3r__ExtrusionPath_append);
        newXS_deffile("Slic3r::ExtrusionPath::intersect_expolygons", XS_Slic3r__ExtrusionPath_intersect_expolygons);
        newXS_deffile("Slic3r::ExtrusionPath::subtract_expolygons", XS_Slic3r__ExtrusionPath_subtract_expolygons);
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_BRIDGE", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erBridgeInfill;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_EXTERNAL_PERIMETER", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erExternalPerimeter;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_FILL", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erInternalInfill;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_GAPFILL", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erGapFill;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_NONE", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erNone;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_OVERHANG_PERIMETER", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erOverhangPerimeter;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_PERIMETER", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erPerimeter;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_SKIRT", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erSkirt;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_SOLIDFILL", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erSolidInfill;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_SUPPORTMATERIAL", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erSupportMaterial;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_SUPPORTMATERIAL_INTERFACE", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erSupportMaterialInterface;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::EXTR_ROLE_TOPSOLIDFILL", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = erTopSolidInfill;
        cv = newXSproto_portable("Slic3r::ExtrusionPath::_constant", XS_Slic3r__ExtrusionPath__constant, file, "");
        XSANY.any_i32 = 0;
        newXS_deffile("Slic3r::ExPolygon::Collection::DESTROY", XS_Slic3r__ExPolygon__Collection_DESTROY);
        newXS_deffile("Slic3r::ExPolygon::Collection::clone", XS_Slic3r__ExPolygon__Collection_clone);
        newXS_deffile("Slic3r::ExPolygon::Collection::clear", XS_Slic3r__ExPolygon__Collection_clear);
        newXS_deffile("Slic3r::ExPolygon::Collection::scale", XS_Slic3r__ExPolygon__Collection_scale);
        newXS_deffile("Slic3r::ExPolygon::Collection::translate", XS_Slic3r__ExPolygon__Collection_translate);
        newXS_deffile("Slic3r::ExPolygon::Collection::rotate", XS_Slic3r__ExPolygon__Collection_rotate);
        newXS_deffile("Slic3r::ExPolygon::Collection::count", XS_Slic3r__ExPolygon__Collection_count);
        newXS_deffile("Slic3r::ExPolygon::Collection::contains_point", XS_Slic3r__ExPolygon__Collection_contains_point);
        newXS_deffile("Slic3r::ExPolygon::Collection::contains_line", XS_Slic3r__ExPolygon__Collection_contains_line);
        newXS_deffile("Slic3r::ExPolygon::Collection::contains_polyline", XS_Slic3r__ExPolygon__Collection_contains_polyline);
        newXS_deffile("Slic3r::ExPolygon::Collection::simplify", XS_Slic3r__ExPolygon__Collection_simplify);
        newXS_deffile("Slic3r::ExPolygon::Collection::polygons", XS_Slic3r__ExPolygon__Collection_polygons);
        newXS_deffile("Slic3r::ExPolygon::Collection::convex_hull", XS_Slic3r__ExPolygon__Collection_convex_hull);
        newXS_deffile("Slic3r::ExPolygon::Collection::new", XS_Slic3r__ExPolygon__Collection_new);
        newXS_deffile("Slic3r::ExPolygon::Collection::arrayref", XS_Slic3r__ExPolygon__Collection_arrayref);
        newXS_deffile("Slic3r::ExPolygon::Collection::pp", XS_Slic3r__ExPolygon__Collection_pp);
        newXS_deffile("Slic3r::ExPolygon::Collection::append", XS_Slic3r__ExPolygon__Collection_append);
        newXS_deffile("Slic3r::Polyline::Collection::DESTROY", XS_Slic3r__Polyline__Collection_DESTROY);
        newXS_deffile("Slic3r::Polyline::Collection::clone", XS_Slic3r__Polyline__Collection_clone);
        newXS_deffile("Slic3r::Polyline::Collection::clear", XS_Slic3r__Polyline__Collection_clear);
        newXS_deffile("Slic3r::Polyline::Collection::chained_path", XS_Slic3r__Polyline__Collection_chained_path);
        newXS_deffile("Slic3r::Polyline::Collection::chained_path_from", XS_Slic3r__Polyline__Collection_chained_path_from);
        newXS_deffile("Slic3r::Polyline::Collection::count", XS_Slic3r__Polyline__Collection_count);
        newXS_deffile("Slic3r::Polyline::Collection::leftmost_point", XS_Slic3r__Polyline__Collection_leftmost_point);
        newXS_deffile("Slic3r::Polyline::Collection::new", XS_Slic3r__Polyline__Collection_new);
        newXS_deffile("Slic3r::Polyline::Collection::arrayref", XS_Slic3r__Polyline__Collection_arrayref);
        newXS_deffile("Slic3r::Polyline::Collection::pp", XS_Slic3r__Polyline__Collection_pp);
        newXS_deffile("Slic3r::Polyline::Collection::append", XS_Slic3r__Polyline__Collection_append);
        cv = newXSproto_portable("Slic3r::Print::State::STEP_BRIM", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = psBrim;
        cv = newXSproto_portable("Slic3r::Print::State::STEP_DETECT_SURFACES", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = posDetectSurfaces;
        cv = newXSproto_portable("Slic3r::Print::State::STEP_INFILL", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = posInfill;
        cv = newXSproto_portable("Slic3r::Print::State::STEP_LAYERS", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = posLayers;
        cv = newXSproto_portable("Slic3r::Print::State::STEP_PERIMETERS", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = posPerimeters;
        cv = newXSproto_portable("Slic3r::Print::State::STEP_PREPARE_INFILL", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = posPrepareInfill;
        cv = newXSproto_portable("Slic3r::Print::State::STEP_SKIRT", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = psSkirt;
        cv = newXSproto_portable("Slic3r::Print::State::STEP_SLICE", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = posSlice;
        cv = newXSproto_portable("Slic3r::Print::State::STEP_SUPPORTMATERIAL", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = posSupportMaterial;
        cv = newXSproto_portable("Slic3r::Print::State::_constant", XS_Slic3r__Print__State__constant, file, "");
        XSANY.any_i32 = 0;
        newXS_deffile("Slic3r::Print::Region::config", XS_Slic3r__Print__Region_config);
        newXS_deffile("Slic3r::Print::Region::print", XS_Slic3r__Print__Region_print);
        newXS_deffile("Slic3r::Print::Region::flow", XS_Slic3r__Print__Region_flow);
        newXS_deffile("Slic3r::Print::Object::add_region_volume", XS_Slic3r__Print__Object_add_region_volume);
        newXS_deffile("Slic3r::Print::Object::get_region_volumes", XS_Slic3r__Print__Object_get_region_volumes);
        newXS_deffile("Slic3r::Print::Object::region_count", XS_Slic3r__Print__Object_region_count);
        newXS_deffile("Slic3r::Print::Object::print", XS_Slic3r__Print__Object_print);
        newXS_deffile("Slic3r::Print::Object::model_object", XS_Slic3r__Print__Object_model_object);
        newXS_deffile("Slic3r::Print::Object::config", XS_Slic3r__Print__Object_config);
        newXS_deffile("Slic3r::Print::Object::copies", XS_Slic3r__Print__Object_copies);
        newXS_deffile("Slic3r::Print::Object::layer_height_ranges", XS_Slic3r__Print__Object_layer_height_ranges);
        newXS_deffile("Slic3r::Print::Object::layer_height_spline", XS_Slic3r__Print__Object_layer_height_spline);
        newXS_deffile("Slic3r::Print::Object::size", XS_Slic3r__Print__Object_size);
        newXS_deffile("Slic3r::Print::Object::bounding_box", XS_Slic3r__Print__Object_bounding_box);
        newXS_deffile("Slic3r::Print::Object::_copies_shift", XS_Slic3r__Print__Object__copies_shift);
        newXS_deffile("Slic3r::Print::Object::support_material_extruders", XS_Slic3r__Print__Object_support_material_extruders);
        newXS_deffile("Slic3r::Print::Object::extruders", XS_Slic3r__Print__Object_extruders);
        newXS_deffile("Slic3r::Print::Object::typed_slices", XS_Slic3r__Print__Object_typed_slices);
        newXS_deffile("Slic3r::Print::Object::set_typed_slices", XS_Slic3r__Print__Object_set_typed_slices);
        newXS_deffile("Slic3r::Print::Object::_shifted_copies", XS_Slic3r__Print__Object__shifted_copies);
        newXS_deffile("Slic3r::Print::Object::set_shifted_copies", XS_Slic3r__Print__Object_set_shifted_copies);
        newXS_deffile("Slic3r::Print::Object::add_copy", XS_Slic3r__Print__Object_add_copy);
        newXS_deffile("Slic3r::Print::Object::delete_last_copy", XS_Slic3r__Print__Object_delete_last_copy);
        newXS_deffile("Slic3r::Print::Object::delete_all_copies", XS_Slic3r__Print__Object_delete_all_copies);
        newXS_deffile("Slic3r::Print::Object::set_copies", XS_Slic3r__Print__Object_set_copies);
        newXS_deffile("Slic3r::Print::Object::reload_model_instances", XS_Slic3r__Print__Object_reload_model_instances);
        newXS_deffile("Slic3r::Print::Object::set_layer_height_ranges", XS_Slic3r__Print__Object_set_layer_height_ranges);
        newXS_deffile("Slic3r::Print::Object::total_layer_count", XS_Slic3r__Print__Object_total_layer_count);
        newXS_deffile("Slic3r::Print::Object::layer_count", XS_Slic3r__Print__Object_layer_count);
        newXS_deffile("Slic3r::Print::Object::clear_layers", XS_Slic3r__Print__Object_clear_layers);
        newXS_deffile("Slic3r::Print::Object::get_layer", XS_Slic3r__Print__Object_get_layer);
        newXS_deffile("Slic3r::Print::Object::add_layer", XS_Slic3r__Print__Object_add_layer);
        newXS_deffile("Slic3r::Print::Object::delete_layer", XS_Slic3r__Print__Object_delete_layer);
        newXS_deffile("Slic3r::Print::Object::support_material_flow", XS_Slic3r__Print__Object_support_material_flow);
        newXS_deffile("Slic3r::Print::Object::support_layer_count", XS_Slic3r__Print__Object_support_layer_count);
        newXS_deffile("Slic3r::Print::Object::clear_support_layers", XS_Slic3r__Print__Object_clear_support_layers);
        newXS_deffile("Slic3r::Print::Object::get_support_layer", XS_Slic3r__Print__Object_get_support_layer);
        newXS_deffile("Slic3r::Print::Object::add_support_layer", XS_Slic3r__Print__Object_add_support_layer);
        newXS_deffile("Slic3r::Print::Object::delete_support_layer", XS_Slic3r__Print__Object_delete_support_layer);
        newXS_deffile("Slic3r::Print::Object::invalidate_step", XS_Slic3r__Print__Object_invalidate_step);
        newXS_deffile("Slic3r::Print::Object::invalidate_all_steps", XS_Slic3r__Print__Object_invalidate_all_steps);
        newXS_deffile("Slic3r::Print::Object::step_done", XS_Slic3r__Print__Object_step_done);
        newXS_deffile("Slic3r::Print::Object::set_step_done", XS_Slic3r__Print__Object_set_step_done);
        newXS_deffile("Slic3r::Print::Object::set_step_started", XS_Slic3r__Print__Object_set_step_started);
        newXS_deffile("Slic3r::Print::Object::detect_surfaces_type", XS_Slic3r__Print__Object_detect_surfaces_type);
        newXS_deffile("Slic3r::Print::Object::process_external_surfaces", XS_Slic3r__Print__Object_process_external_surfaces);
        newXS_deffile("Slic3r::Print::Object::bridge_over_infill", XS_Slic3r__Print__Object_bridge_over_infill);
        newXS_deffile("Slic3r::Print::Object::combine_infill", XS_Slic3r__Print__Object_combine_infill);
        newXS_deffile("Slic3r::Print::Object::discover_horizontal_shells", XS_Slic3r__Print__Object_discover_horizontal_shells);
        newXS_deffile("Slic3r::Print::Object::clip_fill_surfaces", XS_Slic3r__Print__Object_clip_fill_surfaces);
        newXS_deffile("Slic3r::Print::Object::slice", XS_Slic3r__Print__Object_slice);
        newXS_deffile("Slic3r::Print::Object::_slice", XS_Slic3r__Print__Object__slice);
        newXS_deffile("Slic3r::Print::Object::_slice_region", XS_Slic3r__Print__Object__slice_region);
        newXS_deffile("Slic3r::Print::Object::make_perimeters", XS_Slic3r__Print__Object_make_perimeters);
        newXS_deffile("Slic3r::Print::Object::prepare_infill", XS_Slic3r__Print__Object_prepare_infill);
        newXS_deffile("Slic3r::Print::Object::infill", XS_Slic3r__Print__Object_infill);
        newXS_deffile("Slic3r::Print::Object::_simplify_slices", XS_Slic3r__Print__Object__simplify_slices);
        newXS_deffile("Slic3r::Print::Object::ptr", XS_Slic3r__Print__Object_ptr);
        newXS_deffile("Slic3r::Print::new", XS_Slic3r__Print_new);
        newXS_deffile("Slic3r::Print::DESTROY", XS_Slic3r__Print_DESTROY);
        newXS_deffile("Slic3r::Print::config", XS_Slic3r__Print_config);
        newXS_deffile("Slic3r::Print::default_object_config", XS_Slic3r__Print_default_object_config);
        newXS_deffile("Slic3r::Print::default_region_config", XS_Slic3r__Print_default_region_config);
        newXS_deffile("Slic3r::Print::placeholder_parser", XS_Slic3r__Print_placeholder_parser);
        newXS_deffile("Slic3r::Print::skirt", XS_Slic3r__Print_skirt);
        newXS_deffile("Slic3r::Print::brim", XS_Slic3r__Print_brim);
        newXS_deffile("Slic3r::Print::objects", XS_Slic3r__Print_objects);
        newXS_deffile("Slic3r::Print::clear_objects", XS_Slic3r__Print_clear_objects);
        newXS_deffile("Slic3r::Print::get_object", XS_Slic3r__Print_get_object);
        newXS_deffile("Slic3r::Print::delete_object", XS_Slic3r__Print_delete_object);
        newXS_deffile("Slic3r::Print::reload_object", XS_Slic3r__Print_reload_object);
        newXS_deffile("Slic3r::Print::reload_model_instances", XS_Slic3r__Print_reload_model_instances);
        newXS_deffile("Slic3r::Print::object_count", XS_Slic3r__Print_object_count);
        newXS_deffile("Slic3r::Print::regions", XS_Slic3r__Print_regions);
        newXS_deffile("Slic3r::Print::get_region", XS_Slic3r__Print_get_region);
        newXS_deffile("Slic3r::Print::add_region", XS_Slic3r__Print_add_region);
        newXS_deffile("Slic3r::Print::region_count", XS_Slic3r__Print_region_count);
        newXS_deffile("Slic3r::Print::invalidate_step", XS_Slic3r__Print_invalidate_step);
        newXS_deffile("Slic3r::Print::invalidate_all_steps", XS_Slic3r__Print_invalidate_all_steps);
        newXS_deffile("Slic3r::Print::step_done", XS_Slic3r__Print_step_done);
        newXS_deffile("Slic3r::Print::object_step_done", XS_Slic3r__Print_object_step_done);
        newXS_deffile("Slic3r::Print::set_step_done", XS_Slic3r__Print_set_step_done);
        newXS_deffile("Slic3r::Print::set_step_started", XS_Slic3r__Print_set_step_started);
        newXS_deffile("Slic3r::Print::object_extruders", XS_Slic3r__Print_object_extruders);
        newXS_deffile("Slic3r::Print::support_material_extruders", XS_Slic3r__Print_support_material_extruders);
        newXS_deffile("Slic3r::Print::extruders", XS_Slic3r__Print_extruders);
        newXS_deffile("Slic3r::Print::brim_extruder", XS_Slic3r__Print_brim_extruder);
        newXS_deffile("Slic3r::Print::clear_filament_stats", XS_Slic3r__Print_clear_filament_stats);
        newXS_deffile("Slic3r::Print::set_filament_stats", XS_Slic3r__Print_set_filament_stats);
        newXS_deffile("Slic3r::Print::filament_stats", XS_Slic3r__Print_filament_stats);
        newXS_deffile("Slic3r::Print::_simplify_slices", XS_Slic3r__Print__simplify_slices);
        newXS_deffile("Slic3r::Print::max_allowed_layer_height", XS_Slic3r__Print_max_allowed_layer_height);
        newXS_deffile("Slic3r::Print::has_support_material", XS_Slic3r__Print_has_support_material);
        newXS_deffile("Slic3r::Print::auto_assign_extruders", XS_Slic3r__Print_auto_assign_extruders);
        newXS_deffile("Slic3r::Print::output_filename", XS_Slic3r__Print_output_filename);
        newXS_deffile("Slic3r::Print::output_filepath", XS_Slic3r__Print_output_filepath);
        newXS_deffile("Slic3r::Print::add_model_object", XS_Slic3r__Print_add_model_object);
        newXS_deffile("Slic3r::Print::apply_config", XS_Slic3r__Print_apply_config);
        newXS_deffile("Slic3r::Print::apply_static_config", XS_Slic3r__Print_apply_static_config);
        newXS_deffile("Slic3r::Print::has_infinite_skirt", XS_Slic3r__Print_has_infinite_skirt);
        newXS_deffile("Slic3r::Print::has_skirt", XS_Slic3r__Print_has_skirt);
        newXS_deffile("Slic3r::Print::_validate", XS_Slic3r__Print__validate);
        newXS_deffile("Slic3r::Print::bounding_box", XS_Slic3r__Print_bounding_box);
        newXS_deffile("Slic3r::Print::total_bounding_box", XS_Slic3r__Print_total_bounding_box);
        newXS_deffile("Slic3r::Print::skirt_first_layer_height", XS_Slic3r__Print_skirt_first_layer_height);
        newXS_deffile("Slic3r::Print::brim_flow", XS_Slic3r__Print_brim_flow);
        newXS_deffile("Slic3r::Print::skirt_flow", XS_Slic3r__Print_skirt_flow);
        newXS_deffile("Slic3r::Print::make_skirt", XS_Slic3r__Print_make_skirt);
        newXS_deffile("Slic3r::Print::_make_brim", XS_Slic3r__Print__make_brim);
        newXS_deffile("Slic3r::Print::total_used_filament", XS_Slic3r__Print_total_used_filament);
        newXS_deffile("Slic3r::Print::total_extruded_volume", XS_Slic3r__Print_total_extruded_volume);
        newXS_deffile("Slic3r::Print::total_weight", XS_Slic3r__Print_total_weight);
        newXS_deffile("Slic3r::Print::total_cost", XS_Slic3r__Print_total_cost);
        newXS_deffile("Slic3r::ExtrusionLoop::new", XS_Slic3r__ExtrusionLoop_new);
        newXS_deffile("Slic3r::ExtrusionLoop::DESTROY", XS_Slic3r__ExtrusionLoop_DESTROY);
        newXS_deffile("Slic3r::ExtrusionLoop::clone", XS_Slic3r__ExtrusionLoop_clone);
        newXS_deffile("Slic3r::ExtrusionLoop::reverse", XS_Slic3r__ExtrusionLoop_reverse);
        newXS_deffile("Slic3r::ExtrusionLoop::make_clockwise", XS_Slic3r__ExtrusionLoop_make_clockwise);
        newXS_deffile("Slic3r::ExtrusionLoop::make_counter_clockwise", XS_Slic3r__ExtrusionLoop_make_counter_clockwise);
        newXS_deffile("Slic3r::ExtrusionLoop::first_point", XS_Slic3r__ExtrusionLoop_first_point);
        newXS_deffile("Slic3r::ExtrusionLoop::last_point", XS_Slic3r__ExtrusionLoop_last_point);
        newXS_deffile("Slic3r::ExtrusionLoop::polygon", XS_Slic3r__ExtrusionLoop_polygon);
        newXS_deffile("Slic3r::ExtrusionLoop::append", XS_Slic3r__ExtrusionLoop_append);
        newXS_deffile("Slic3r::ExtrusionLoop::length", XS_Slic3r__ExtrusionLoop_length);
        newXS_deffile("Slic3r::ExtrusionLoop::split_at_vertex", XS_Slic3r__ExtrusionLoop_split_at_vertex);
        newXS_deffile("Slic3r::ExtrusionLoop::split_at", XS_Slic3r__ExtrusionLoop_split_at);
        newXS_deffile("Slic3r::ExtrusionLoop::clip_end", XS_Slic3r__ExtrusionLoop_clip_end);
        newXS_deffile("Slic3r::ExtrusionLoop::has_overhang_point", XS_Slic3r__ExtrusionLoop_has_overhang_point);
        newXS_deffile("Slic3r::ExtrusionLoop::is_perimeter", XS_Slic3r__ExtrusionLoop_is_perimeter);
        newXS_deffile("Slic3r::ExtrusionLoop::is_infill", XS_Slic3r__ExtrusionLoop_is_infill);
        newXS_deffile("Slic3r::ExtrusionLoop::is_solid_infill", XS_Slic3r__ExtrusionLoop_is_solid_infill);
        newXS_deffile("Slic3r::ExtrusionLoop::grow", XS_Slic3r__ExtrusionLoop_grow);
        newXS_deffile("Slic3r::ExtrusionLoop::as_polyline", XS_Slic3r__ExtrusionLoop_as_polyline);
        newXS_deffile("Slic3r::ExtrusionLoop::arrayref", XS_Slic3r__ExtrusionLoop_arrayref);
        newXS_deffile("Slic3r::ExtrusionLoop::role", XS_Slic3r__ExtrusionLoop_role);
        cv = newXSproto_portable("Slic3r::ExtrusionLoop::EXTRL_ROLE_CONTOUR_INTERNAL_PERIMETER", XS_Slic3r__ExtrusionLoop__constant, file, "");
        XSANY.any_i32 = elrContourInternalPerimeter;
        cv = newXSproto_portable("Slic3r::ExtrusionLoop::EXTRL_ROLE_DEFAULT", XS_Slic3r__ExtrusionLoop__constant, file, "");
        XSANY.any_i32 = elrDefault;
        cv = newXSproto_portable("Slic3r::ExtrusionLoop::EXTRL_ROLE_SKIRT", XS_Slic3r__ExtrusionLoop__constant, file, "");
        XSANY.any_i32 = elrSkirt;
        cv = newXSproto_portable("Slic3r::ExtrusionLoop::_constant", XS_Slic3r__ExtrusionLoop__constant, file, "");
        XSANY.any_i32 = 0;
        newXS_deffile("Slic3r::BridgeDetector::DESTROY", XS_Slic3r__BridgeDetector_DESTROY);
        newXS_deffile("Slic3r::BridgeDetector::detect_angle", XS_Slic3r__BridgeDetector_detect_angle);
        newXS_deffile("Slic3r::BridgeDetector::coverage", XS_Slic3r__BridgeDetector_coverage);
        newXS_deffile("Slic3r::BridgeDetector::coverage_by_angle", XS_Slic3r__BridgeDetector_coverage_by_angle);
        newXS_deffile("Slic3r::BridgeDetector::unsupported_edges", XS_Slic3r__BridgeDetector_unsupported_edges);
        newXS_deffile("Slic3r::BridgeDetector::unsupported_edges_by_angle", XS_Slic3r__BridgeDetector_unsupported_edges_by_angle);
        newXS_deffile("Slic3r::BridgeDetector::angle", XS_Slic3r__BridgeDetector_angle);
        newXS_deffile("Slic3r::BridgeDetector::resolution", XS_Slic3r__BridgeDetector_resolution);
        newXS_deffile("Slic3r::BridgeDetector::new", XS_Slic3r__BridgeDetector_new);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::_new", XS_Slic3r__ExtrusionPath__Collection__new);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::DESTROY", XS_Slic3r__ExtrusionPath__Collection_DESTROY);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::clone", XS_Slic3r__ExtrusionPath__Collection_clone);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::reverse", XS_Slic3r__ExtrusionPath__Collection_reverse);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::clear", XS_Slic3r__ExtrusionPath__Collection_clear);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::chained_path", XS_Slic3r__ExtrusionPath__Collection_chained_path);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::chained_path_from", XS_Slic3r__ExtrusionPath__Collection_chained_path_from);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::first_point", XS_Slic3r__ExtrusionPath__Collection_first_point);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::last_point", XS_Slic3r__ExtrusionPath__Collection_last_point);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::count", XS_Slic3r__ExtrusionPath__Collection_count);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::items_count", XS_Slic3r__ExtrusionPath__Collection_items_count);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::flatten", XS_Slic3r__ExtrusionPath__Collection_flatten);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::min_mm3_per_mm", XS_Slic3r__ExtrusionPath__Collection_min_mm3_per_mm);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::empty", XS_Slic3r__ExtrusionPath__Collection_empty);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::orig_indices", XS_Slic3r__ExtrusionPath__Collection_orig_indices);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::grow", XS_Slic3r__ExtrusionPath__Collection_grow);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::arrayref", XS_Slic3r__ExtrusionPath__Collection_arrayref);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::append", XS_Slic3r__ExtrusionPath__Collection_append);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::no_sort", XS_Slic3r__ExtrusionPath__Collection_no_sort);
        newXS_deffile("Slic3r::ExtrusionPath::Collection::chained_path_indices", XS_Slic3r__ExtrusionPath__Collection_chained_path_indices);
        newXS_deffile("Slic3r::Polyline::DESTROY", XS_Slic3r__Polyline_DESTROY);
        newXS_deffile("Slic3r::Polyline::clone", XS_Slic3r__Polyline_clone);
        newXS_deffile("Slic3r::Polyline::arrayref", XS_Slic3r__Polyline_arrayref);
        newXS_deffile("Slic3r::Polyline::pp", XS_Slic3r__Polyline_pp);
        newXS_deffile("Slic3r::Polyline::scale", XS_Slic3r__Polyline_scale);
        newXS_deffile("Slic3r::Polyline::translate", XS_Slic3r__Polyline_translate);
        newXS_deffile("Slic3r::Polyline::pop_back", XS_Slic3r__Polyline_pop_back);
        newXS_deffile("Slic3r::Polyline::reverse", XS_Slic3r__Polyline_reverse);
        newXS_deffile("Slic3r::Polyline::lines", XS_Slic3r__Polyline_lines);
        newXS_deffile("Slic3r::Polyline::first_point", XS_Slic3r__Polyline_first_point);
        newXS_deffile("Slic3r::Polyline::last_point", XS_Slic3r__Polyline_last_point);
        newXS_deffile("Slic3r::Polyline::equally_spaced_points", XS_Slic3r__Polyline_equally_spaced_points);
        newXS_deffile("Slic3r::Polyline::length", XS_Slic3r__Polyline_length);
        newXS_deffile("Slic3r::Polyline::is_valid", XS_Slic3r__Polyline_is_valid);
        newXS_deffile("Slic3r::Polyline::clip_end", XS_Slic3r__Polyline_clip_end);
        newXS_deffile("Slic3r::Polyline::clip_start", XS_Slic3r__Polyline_clip_start);
        newXS_deffile("Slic3r::Polyline::extend_end", XS_Slic3r__Polyline_extend_end);
        newXS_deffile("Slic3r::Polyline::extend_start", XS_Slic3r__Polyline_extend_start);
        newXS_deffile("Slic3r::Polyline::simplify", XS_Slic3r__Polyline_simplify);
        newXS_deffile("Slic3r::Polyline::simplify_by_visibility", XS_Slic3r__Polyline_simplify_by_visibility);
        newXS_deffile("Slic3r::Polyline::split_at", XS_Slic3r__Polyline_split_at);
        newXS_deffile("Slic3r::Polyline::is_straight", XS_Slic3r__Polyline_is_straight);
        newXS_deffile("Slic3r::Polyline::bounding_box", XS_Slic3r__Polyline_bounding_box);
        newXS_deffile("Slic3r::Polyline::remove_duplicate_points", XS_Slic3r__Polyline_remove_duplicate_points);
        newXS_deffile("Slic3r::Polyline::wkt", XS_Slic3r__Polyline_wkt);
        newXS_deffile("Slic3r::Polyline::new", XS_Slic3r__Polyline_new);
        newXS_deffile("Slic3r::Polyline::append", XS_Slic3r__Polyline_append);
        newXS_deffile("Slic3r::Polyline::append_polyline", XS_Slic3r__Polyline_append_polyline);
        newXS_deffile("Slic3r::Polyline::rotate", XS_Slic3r__Polyline_rotate);
        newXS_deffile("Slic3r::Polyline::grow", XS_Slic3r__Polyline_grow);
        newXS_deffile("Slic3r::ExPolygon::DESTROY", XS_Slic3r__ExPolygon_DESTROY);
        newXS_deffile("Slic3r::ExPolygon::clone", XS_Slic3r__ExPolygon_clone);
        newXS_deffile("Slic3r::ExPolygon::arrayref", XS_Slic3r__ExPolygon_arrayref);
        newXS_deffile("Slic3r::ExPolygon::pp", XS_Slic3r__ExPolygon_pp);
        newXS_deffile("Slic3r::ExPolygon::contour", XS_Slic3r__ExPolygon_contour);
        newXS_deffile("Slic3r::ExPolygon::holes", XS_Slic3r__ExPolygon_holes);
        newXS_deffile("Slic3r::ExPolygon::scale", XS_Slic3r__ExPolygon_scale);
        newXS_deffile("Slic3r::ExPolygon::translate", XS_Slic3r__ExPolygon_translate);
        newXS_deffile("Slic3r::ExPolygon::area", XS_Slic3r__ExPolygon_area);
        newXS_deffile("Slic3r::ExPolygon::is_valid", XS_Slic3r__ExPolygon_is_valid);
        newXS_deffile("Slic3r::ExPolygon::contains_line", XS_Slic3r__ExPolygon_contains_line);
        newXS_deffile("Slic3r::ExPolygon::contains_polyline", XS_Slic3r__ExPolygon_contains_polyline);
        newXS_deffile("Slic3r::ExPolygon::contains_point", XS_Slic3r__ExPolygon_contains_point);
        newXS_deffile("Slic3r::ExPolygon::simplify", XS_Slic3r__ExPolygon_simplify);
        newXS_deffile("Slic3r::ExPolygon::simplify_p", XS_Slic3r__ExPolygon_simplify_p);
        newXS_deffile("Slic3r::ExPolygon::medial_axis", XS_Slic3r__ExPolygon_medial_axis);
        newXS_deffile("Slic3r::ExPolygon::get_trapezoids", XS_Slic3r__ExPolygon_get_trapezoids);
        newXS_deffile("Slic3r::ExPolygon::get_trapezoids2", XS_Slic3r__ExPolygon_get_trapezoids2);
        newXS_deffile("Slic3r::ExPolygon::triangulate", XS_Slic3r__ExPolygon_triangulate);
        newXS_deffile("Slic3r::ExPolygon::triangulate_pp", XS_Slic3r__ExPolygon_triangulate_pp);
        newXS_deffile("Slic3r::ExPolygon::new", XS_Slic3r__ExPolygon_new);
        newXS_deffile("Slic3r::ExPolygon::rotate", XS_Slic3r__ExPolygon_rotate);
        newXS_deffile("Slic3r::Extruder::new", XS_Slic3r__Extruder_new);
        newXS_deffile("Slic3r::Extruder::DESTROY", XS_Slic3r__Extruder_DESTROY);
        newXS_deffile("Slic3r::Extruder::reset", XS_Slic3r__Extruder_reset);
        newXS_deffile("Slic3r::Extruder::extrude", XS_Slic3r__Extruder_extrude);
        newXS_deffile("Slic3r::Extruder::retract", XS_Slic3r__Extruder_retract);
        newXS_deffile("Slic3r::Extruder::unretract", XS_Slic3r__Extruder_unretract);
        newXS_deffile("Slic3r::Extruder::e_per_mm", XS_Slic3r__Extruder_e_per_mm);
        newXS_deffile("Slic3r::Extruder::extruded_volume", XS_Slic3r__Extruder_extruded_volume);
        newXS_deffile("Slic3r::Extruder::used_filament", XS_Slic3r__Extruder_used_filament);
        newXS_deffile("Slic3r::Extruder::id", XS_Slic3r__Extruder_id);
        newXS_deffile("Slic3r::Extruder::E", XS_Slic3r__Extruder_E);
        newXS_deffile("Slic3r::Extruder::set_E", XS_Slic3r__Extruder_set_E);
        newXS_deffile("Slic3r::Extruder::absolute_E", XS_Slic3r__Extruder_absolute_E);
        newXS_deffile("Slic3r::Extruder::set_absolute_E", XS_Slic3r__Extruder_set_absolute_E);
        newXS_deffile("Slic3r::Extruder::retracted", XS_Slic3r__Extruder_retracted);
        newXS_deffile("Slic3r::Extruder::set_retracted", XS_Slic3r__Extruder_set_retracted);
        newXS_deffile("Slic3r::Extruder::restart_extra", XS_Slic3r__Extruder_restart_extra);
        newXS_deffile("Slic3r::Extruder::set_restart_extra", XS_Slic3r__Extruder_set_restart_extra);
        newXS_deffile("Slic3r::Extruder::e_per_mm3", XS_Slic3r__Extruder_e_per_mm3);
        newXS_deffile("Slic3r::Extruder::retract_speed_mm_min", XS_Slic3r__Extruder_retract_speed_mm_min);
        newXS_deffile("Slic3r::Extruder::filament_diameter", XS_Slic3r__Extruder_filament_diameter);
        newXS_deffile("Slic3r::Extruder::filament_density", XS_Slic3r__Extruder_filament_density);
        newXS_deffile("Slic3r::Extruder::filament_cost", XS_Slic3r__Extruder_filament_cost);
        newXS_deffile("Slic3r::Extruder::extrusion_multiplier", XS_Slic3r__Extruder_extrusion_multiplier);
        newXS_deffile("Slic3r::Extruder::retract_length", XS_Slic3r__Extruder_retract_length);
        newXS_deffile("Slic3r::Extruder::retract_lift", XS_Slic3r__Extruder_retract_lift);
        newXS_deffile("Slic3r::Extruder::retract_speed", XS_Slic3r__Extruder_retract_speed);
        newXS_deffile("Slic3r::Extruder::retract_restart_extra", XS_Slic3r__Extruder_retract_restart_extra);
        newXS_deffile("Slic3r::Extruder::retract_length_toolchange", XS_Slic3r__Extruder_retract_length_toolchange);
        newXS_deffile("Slic3r::Extruder::retract_restart_extra_toolchange", XS_Slic3r__Extruder_retract_restart_extra_toolchange);
        newXS_deffile("Slic3r::Filler::DESTROY", XS_Slic3r__Filler_DESTROY);
        newXS_deffile("Slic3r::Filler::set_bounding_box", XS_Slic3r__Filler_set_bounding_box);
        newXS_deffile("Slic3r::Filler::set_min_spacing", XS_Slic3r__Filler_set_min_spacing);
        newXS_deffile("Slic3r::Filler::min_spacing", XS_Slic3r__Filler_min_spacing);
        newXS_deffile("Slic3r::Filler::spacing", XS_Slic3r__Filler_spacing);
        newXS_deffile("Slic3r::Filler::set_endpoints_overlap", XS_Slic3r__Filler_set_endpoints_overlap);
        newXS_deffile("Slic3r::Filler::endpoints_overlap", XS_Slic3r__Filler_endpoints_overlap);
        newXS_deffile("Slic3r::Filler::set_layer_id", XS_Slic3r__Filler_set_layer_id);
        newXS_deffile("Slic3r::Filler::set_z", XS_Slic3r__Filler_set_z);
        newXS_deffile("Slic3r::Filler::set_angle", XS_Slic3r__Filler_set_angle);
        newXS_deffile("Slic3r::Filler::set_link_max_length", XS_Slic3r__Filler_set_link_max_length);
        newXS_deffile("Slic3r::Filler::set_loop_clipping", XS_Slic3r__Filler_set_loop_clipping);
        newXS_deffile("Slic3r::Filler::use_bridge_flow", XS_Slic3r__Filler_use_bridge_flow);
        newXS_deffile("Slic3r::Filler::no_sort", XS_Slic3r__Filler_no_sort);
        newXS_deffile("Slic3r::Filler::set_density", XS_Slic3r__Filler_set_density);
        newXS_deffile("Slic3r::Filler::set_dont_connect", XS_Slic3r__Filler_set_dont_connect);
        newXS_deffile("Slic3r::Filler::set_dont_adjust", XS_Slic3r__Filler_set_dont_adjust);
        newXS_deffile("Slic3r::Filler::set_complete", XS_Slic3r__Filler_set_complete);
        newXS_deffile("Slic3r::Filler::_fill_surface", XS_Slic3r__Filler__fill_surface);
        newXS_deffile("Slic3r::Filler::new_from_type", XS_Slic3r__Filler_new_from_type);

    /* Initialisation Section */

#if XSubPPtmpAAAA
#endif
#line 46669 "buildtmp/XS.c"

    /* End of Initialisation Section */

#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

