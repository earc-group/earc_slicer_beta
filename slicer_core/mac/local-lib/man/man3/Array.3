.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Array 3"
.TH Array 3 "2016-10-05" "perl v5.28.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenGL::Array \- Perl Array handling and conversion between Perl arrays and C array pointers.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use OpenGL qw(GL_FLOAT);
\&
\&    my $array = OpenGL::Array\->new(4, GL_FLOAT);
\&    my $c_ptr = $array\->ptr(); # can be passed to OpenGL _c based functions
\&    $array\->calc(\*(Aqcol,27,+\*(Aq);
\&    my @val = $array\->retrieve(0, 4);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
OpenGL::Array (\s-1OGA\s0) objects provide Perl Array handling and conversion
between Perl arrays and C array pointers.
.PP
Due to the difference between how Perl and C handle pointers, all Perl
OpenGL (\s-1POGL\s0) APIs that require pointers are suffixed with _c. OGAs
provide a means to convert Perl arrays into C pointers that can be
passed into these APIs.
.PP
Many \s-1POGL\s0 _c APIs also have a _s version to support \s-1SDL\s0's packed
string APIs; \s-1OGA\s0 provides APIs to convert between C arrays and packed
strings.
.PP
\&\s-1POGL\s0 also provides many _p APIs that accept native Perl arrays, or in
some cases OGAs directly. In the case of VBOs, OGAs may be bound to
\&\s-1GPU\s0 buffers, automatically switching buffers at render time.
.PP
Note: Since OGAs are stored as typed C arrays, there is no
conversion/copy/casting when passing them to \s-1POGL\s0 APIs, resulting in
significant performance improvements over other non-compiled bindings
(\s-1SDL,\s0 PyOpenGL, etc).
.SH "CREATING OpenGL::Array OBJECTS"
.IX Header "CREATING OpenGL::Array OBJECTS"
.ie n .IP """new""" 4
.el .IP "\f(CWnew\fR" 4
.IX Item "new"
.Vb 1
\&    my $array = OpenGL::Array\->new($count,@types);
.Ve
.Sp
Creates an empty array object of \f(CW$count\fR rows made up data types \f(CW@types\fR.
.ie n .IP """new_list""" 4
.el .IP "\f(CWnew_list\fR" 4
.IX Item "new_list"
.Vb 1
\&    my $array = OpenGL::Array\->new_list($type,@data);
.Ve
.Sp
Creates and populates a uniform array object made up \f(CW@data\fR of type \f(CW$type\fR.
.ie n .IP """new_pointer""" 4
.el .IP "\f(CWnew_pointer\fR" 4
.IX Item "new_pointer"
.Vb 1
\&    my $array = OpenGL::Array\->new_pointer($type,ptr,$elements);
.Ve
.Sp
Creates an array object wrapper around a C pointer ptr of type \f(CW$type\fR
and array length \f(CW$elements\fR. Caches C pointer directly; does not copy
data.
.Sp
Note: because OpenGL::Arrays store to direct memory addresses, it is
possible to assign to the array the pointer was obtained from and the
results will be available in the array created by new_pointer \- and
vice versa (because they are viewing portions of the same memory).
.ie n .IP """new_scalar""" 4
.el .IP "\f(CWnew_scalar\fR" 4
.IX Item "new_scalar"
.Vb 2
\&    my $str = pack \*(AqC*\*(Aq, 1 .. 255;
\&    my $array = OpenGL::Array\->new_scalar(GL_UNSIGNED_BYTE, $str, length($str));
.Ve
.Sp
Creates an array object from a perl scalar.
.ie n .IP """new_from_pointer""" 4
.el .IP "\f(CWnew_from_pointer\fR" 4
.IX Item "new_from_pointer"
.Vb 2
\&    my $array1 = OpenGL::Array\->new_list(GL_UNSIGNED_BYTE, 1..9);
\&    my $array2 = OpenGL::Array\->new_from_pointer($array1\->ptr(), 9);
.Ve
.Sp
Special case, creates a uniform \s-1GL_UNSIGNED_BYTE\s0 from a pointer.
.SH "USING OpenGL::Array OBJECT'S C POINTERS"
.IX Header "USING OpenGL::Array OBJECT'S C POINTERS"
OpenGL::Array objects are Perl references; in order to use them in
OpenGL APIs that expect C pointers, you need to use the native
pointer:
.PP
.Vb 3
\&      my $array = OpenGL::Array\->new(4, GL_INT);
\&      glGetIntegerv_c(GL_VIEWPORT, $array\->ptr);
\&      my @viewport = $array\->retrieve(0, 4);
.Ve
.SH "OpenGL::Array ACCESSORS"
.IX Header "OpenGL::Array ACCESSORS"
.ie n .IP """assign""" 4
.el .IP "\f(CWassign\fR" 4
.IX Item "assign"
.Vb 1
\&    $array\->assign($pos, @data);
.Ve
.Sp
Sets array data starting at element position \f(CW$pos\fR using \f(CW@data\fR.
.ie n .IP """assign_data""" 4
.el .IP "\f(CWassign_data\fR" 4
.IX Item "assign_data"
.Vb 1
\&    $array\->assign_data($pos, $data);
.Ve
.Sp
Sets array data element position \f(CW$pos\fR using packed string \f(CW$data\fR.
.ie n .IP """retrieve""" 4
.el .IP "\f(CWretrieve\fR" 4
.IX Item "retrieve"
.Vb 1
\&    my @data = $array\->retrieve($pos, $len);
.Ve
.Sp
Returns an array of \f(CW$len\fR elements from an array object.
.ie n .IP """retrieve_data""" 4
.el .IP "\f(CWretrieve_data\fR" 4
.IX Item "retrieve_data"
.Vb 1
\&    my $data = $array\->retrieve_data($pos, $len);
.Ve
.Sp
Returns a packed string of length \f(CW$len\fR bytes from an array object.
.ie n .IP """elements""" 4
.el .IP "\f(CWelements\fR" 4
.IX Item "elements"
.Vb 1
\&    my $count = $array\->elements();
.Ve
.Sp
Returns the element count from an array object.
.ie n .IP """ptr""" 4
.el .IP "\f(CWptr\fR" 4
.IX Item "ptr"
.Vb 1
\&    ptr = $array\->ptr(); # typically passed to opengl _c functions
.Ve
.Sp
Returns a C pointer to an array object.
.Sp
Returns a C pointer to an array object.
.ie n .IP """offset""" 4
.el .IP "\f(CWoffset\fR" 4
.IX Item "offset"
.Vb 1
\&    ptr = $array\->offset($pos);
.Ve
.Sp
Returns a C pointer to the \f(CW$pos\fR element of an array object.
.ie n .IP """update_ptr""" 4
.el .IP "\f(CWupdate_ptr\fR" 4
.IX Item "update_ptr"
.Vb 1
\&    $array\->update_pointer($ptr);
.Ve
.Sp
Points the existing OpenGL::Array to a different data pointer.
.SH "BINDING TO VBOs"
.IX Header "BINDING TO VBOs"
Helps abstract Vertex Array and \s-1VBO\s0 rendering.
.PP
# Requires GL_ARB_vertex_buffer_object extension and \s-1POGL 0.55_01\s0 or newer
.ie n .IP """bind""" 4
.el .IP "\f(CWbind\fR" 4
.IX Item "bind"
.Vb 1
\&    $array\->bind($id);
.Ve
.Sp
Binds a \s-1GPU\s0 buffer to an array object.  If bound, glXxxPointer_p APIs
will call glBindBufferARB.
.ie n .IP """bound""" 4
.el .IP "\f(CWbound\fR" 4
.IX Item "bound"
.Vb 1
\&    my $id = $array\->bound();
.Ve
.Sp
Return bound buffer \s-1ID,\s0 or 0 if not bound.
.SH "AFFINE TRANSFORMS ON OpenGL::Array OBJECTS"
.IX Header "AFFINE TRANSFORMS ON OpenGL::Array OBJECTS"
Eventually, this \s-1API\s0 will abstract \s-1CPU\s0 vs GPU-based affine transforms
for the best performance.
.ie n .IP """affine""" 4
.el .IP "\f(CWaffine\fR" 4
.IX Item "affine"
.Vb 1
\&    $array\->affine($xform);
\&
\&    # $xform is an NxN OpenGL::Array object used to transform $array.
\&
\&    #N must be one element wider than the width of the array.
.Ve
.SH "Calc: POPULATING AND MANIPULATING OpenGL::Array OBJECTS"
.IX Header "Calc: POPULATING AND MANIPULATING OpenGL::Array OBJECTS"
.ie n .IP """calc""" 4
.el .IP "\f(CWcalc\fR" 4
.IX Item "calc"
Used to populate or mathematically modify an \s-1POGL\s0 array. Uses Reverse
Polish Notation (\s-1RPN\s0) for mathematical operations.  At the moment, any
array used with calc must be made of only of \s-1GL_FLOAT\s0 types.
.Sp
.Vb 1
\&    $array\->calc($value);
.Ve
.Sp
Populates the array with \f(CW$value\fR.
.Sp
.Vb 1
\&    $array\->calc(@values);
.Ve
.Sp
Populates each row of the array with \f(CW@values\fR, assuming rows have the
same width as the length of \f(CW@values\fR.  If the number of passed values
must be evenly divisible by the number of elements in the array.
The number of values becomes the number of \*(L"columns.\*(R"  The number of
\&\*(L"rows\*(R" is the total number of elements of the array divided by the
columns.
.Sp
.Vb 1
\&    $array\->calc(1.0, \*(Aq3,*\*(Aq, \*(Aq2,*,rand,+\*(Aq, \*(Aq\*(Aq);
.Ve
.Sp
Resets the first column of each row to 1.0; multiplies the values in
the second column by 3; multiplies the third column by 2, then adds a
random number between 0 and 1; leaves the fourth column alone.  During
this particular calc operation there would be 4 columns.
.Sp
\&\f(CW\*(C`calc\*(C'\fR maintains a push/pop stack and a \*(L"register\*(R" for each column.
.Sp
\&\f(CW\*(C`calc\*(C'\fR also allows for other OpenGL::Arrays to be passed in.  If
multiple arrays are passed they must all have the same number of
elements.  Only the calling array will be operated on, but as each
element is visited, the values from the other arrays are pre-added to
the stack (in reverse order).
.Sp
.Vb 1
\&    $array\->calc($array2, $array3, $array4, @values);
.Ve
.Sp
calc currently suports the following primitives:
.RS 4
.ie n .IP """!""" 4
.el .IP "\f(CW!\fR" 4
.IX Item "!"
Logical \*(L"Not\*(R" for End of Stack (S0) for the current column; becomes
1.0 if empty or 0. otherwise 1.0
.ie n .IP """\-""" 4
.el .IP "\f(CW\-\fR" 4
.IX Item "-"
Arithmetic Negation of S0
.ie n .IP """+""" 4
.el .IP "\f(CW+\fR" 4
.IX Item "+"
Add S0 and Next on Stack (S1), pop operands and push result (Result)
.ie n .IP """*""" 4
.el .IP "\f(CW*\fR" 4
.IX Item "*"
Multiply S0 and S1; Result
.ie n .IP """/""" 4
.el .IP "\f(CW/\fR" 4
.IX Item "/"
Divide S1 by S0; Result
.ie n .IP """%""" 4
.el .IP "\f(CW%\fR" 4
.IX Item "%"
S1 Modulus S0; Result
.ie n .IP """=""" 4
.el .IP "\f(CW=\fR" 4
.IX Item "="
Test S0 equality to S1; pop operands and push non-zero (1.0) for true,
otherwise 0.0 (Boolean)
.ie n .IP """>""" 4
.el .IP "\f(CW>\fR" 4
.IX Item ">"
Test if S0 Greater than S1; Boolean
.ie n .IP """<""" 4
.el .IP "\f(CW<\fR" 4
.IX Item "<"
Test if S0 Lesser than S1; Boolean
.ie n .IP """?""" 4
.el .IP "\f(CW?\fR" 4
.IX Item "?"
If S0 is true (non-zero), pop S0 and S1; otherwise pop s0\-3, push s1
.ie n .IP """pop""" 4
.el .IP "\f(CWpop\fR" 4
.IX Item "pop"
Pop s0
.ie n .IP """rand""" 4
.el .IP "\f(CWrand\fR" 4
.IX Item "rand"
Push a random number from 0.0 to 1.0
.ie n .IP """dup""" 4
.el .IP "\f(CWdup\fR" 4
.IX Item "dup"
Push a copy of S0
.ie n .IP """swap""" 4
.el .IP "\f(CWswap\fR" 4
.IX Item "swap"
Swap values of S0 and S1
.ie n .IP """set""" 4
.el .IP "\f(CWset\fR" 4
.IX Item "set"
Copy S0 to the column's Register
.ie n .IP """get""" 4
.el .IP "\f(CWget\fR" 4
.IX Item "get"
Push the column's Register onto the column's Stack
.ie n .IP """store""" 4
.el .IP "\f(CWstore\fR" 4
.IX Item "store"
Pop S0, and copy the values from the matching row of the passed
OpenGL::Array at that index.  Values are copied into the current
column registers.
.Sp
.Vb 4
\&  my $o1 = OpenGL::Array\->new_list(GL_FLOAT, 1, 2, 3,  4, 5, 6);
\&  my $o2 = OpenGL::Array\->new_list(GL_FLOAT, 7, 8 ,9,  10, 11, 12);
\&  $o1\->calc($o2, "1,store,get","","get");
\&  $o1\->retreive(0,6) will be (7, 2, 9,  10, 5, 12)
.Ve
.ie n .IP """load""" 4
.el .IP "\f(CWload\fR" 4
.IX Item "load"
Pop S0, and set the values of the matching row of the passed
OpenGL::Array named at that index.  Values are copied from the current
column registers.
.Sp
.Vb 4
\&  my $o1 = OpenGL::Array\->new_list(GL_FLOAT, 1, 2, 3,  4, 5, 6);
\&  my $o2 = OpenGL::Array\->new_list(GL_FLOAT, 7, 8 ,9,  10, 11, 12);
\&  $o1\->calc($o2, "set","", "set,1,load");
\&  $o2\->retreive(0,6) will be (1, 0, 3,  5, 0, 6)
.Ve
.ie n .IP """colget""" 4
.el .IP "\f(CWcolget\fR" 4
.IX Item "colget"
Pop S0, and push the column S0 value onto the current stack.
.Sp
.Vb 3
\&   $o = OpenGL::Array\->new_list(GL_FLOAT, 1, 2, 3,  4, 5, 6);
\&   $o\->calc(\*(Aq2,colget\*(Aq,\*(Aq\*(Aq,\*(Aq\*(Aq);
\&   # $o\->retreive(0,6) will be (3, 2, 3, 6, 5, 6)
.Ve
.ie n .IP """colset""" 4
.el .IP "\f(CWcolset\fR" 4
.IX Item "colset"
Pop S0, and set the column S0 value to the new top of the stack.
.Sp
.Vb 3
\&   $o = OpenGL::Array\->new_list(GL_FLOAT, 1, 2, 3,  4, 5, 6);
\&   $o\->calc(\*(Aq27,2,colset\*(Aq,\*(Aq\*(Aq,\*(Aq\*(Aq);
\&   # $o\->retreive(0,6) will be (1, 2, 27,  4, 5, 27)
.Ve
.ie n .IP """rowget""" 4
.el .IP "\f(CWrowget\fR" 4
.IX Item "rowget"
Pop S0 and S1, and push the column S0 value from row S1 onto the current stack.
.Sp
.Vb 3
\&   $o = OpenGL::Array\->new_list(GL_FLOAT, 1, 2, 3,  4, 5, 6);
\&   $o\->calc(\*(Aq1,2,rowget\*(Aq,\*(Aq\*(Aq,\*(Aq\*(Aq);
\&   # $o\->retreive(0,6) equiv (6, 2, 3,  6, 5, 6)
.Ve
.ie n .IP """rowset""" 4
.el .IP "\f(CWrowset\fR" 4
.IX Item "rowset"
Pop S0 and S1, and set the column S0 value of row S1 to the new top of the stack.
.Sp
.Vb 3
\&   $o = OpenGL::Array\->new_list(GL_FLOAT, 1, 2, 3,  4, 5, 6);
\&   $o\->calc(\*(Aq27,1,2,rowset\*(Aq,\*(Aq\*(Aq,\*(Aq\*(Aq);
\&   # $o\->retreive(0,6) will be (1, 2, 3,  4, 5, 27)
.Ve
.ie n .IP """end""" 4
.el .IP "\f(CWend\fR" 4
.IX Item "end"
End processing; column unchanged
.ie n .IP """endif""" 4
.el .IP "\f(CWendif\fR" 4
.IX Item "endif"
Pop S0, End if true; column unchanged
.ie n .IP """endrow""" 4
.el .IP "\f(CWendrow\fR" 4
.IX Item "endrow"
End processing of current row; column unchanged
.ie n .IP """endrowif""" 4
.el .IP "\f(CWendrowif\fR" 4
.IX Item "endrowif"
Pop S0, End processing of current row if true; column unchanged
.ie n .IP """return""" 4
.el .IP "\f(CWreturn\fR" 4
.IX Item "return"
End processing; column value set to s0
.ie n .IP """returnif""" 4
.el .IP "\f(CWreturnif\fR" 4
.IX Item "returnif"
Pop S0, End if true; column value set to s0
.ie n .IP """returnrow""" 4
.el .IP "\f(CWreturnrow\fR" 4
.IX Item "returnrow"
End processing of current row; column value set to s0
.ie n .IP """returnrowif""" 4
.el .IP "\f(CWreturnrowif\fR" 4
.IX Item "returnrowif"
Pop S0, End processing of current row if true; column value set to s0
.ie n .IP """if""" 4
.el .IP "\f(CWif\fR" 4
.IX Item "if"
alias to \f(CW\*(C`?\*(C'\fR
.ie n .IP """or""" 4
.el .IP "\f(CWor\fR" 4
.IX Item "or"
alias to \f(CW\*(C`+\*(C'\fR
.ie n .IP """and""" 4
.el .IP "\f(CWand\fR" 4
.IX Item "and"
alias to \f(CW\*(C`*\*(C'\fR
.ie n .IP """inc""" 4
.el .IP "\f(CWinc\fR" 4
.IX Item "inc"
Add 1 to S0
.ie n .IP """dec""" 4
.el .IP "\f(CWdec\fR" 4
.IX Item "dec"
Subtract 1 from S0
.ie n .IP """sum""" 4
.el .IP "\f(CWsum\fR" 4
.IX Item "sum"
Add and pop everything in stack; push result
.ie n .IP """avg""" 4
.el .IP "\f(CWavg\fR" 4
.IX Item "avg"
Average and pop everything in stack; push result
.ie n .IP """abs""" 4
.el .IP "\f(CWabs\fR" 4
.IX Item "abs"
Replace S0 with its absolute value
.ie n .IP """power""" 4
.el .IP "\f(CWpower\fR" 4
.IX Item "power"
Raise S1 to the power of S0; Result
.ie n .IP """min""" 4
.el .IP "\f(CWmin\fR" 4
.IX Item "min"
The lower of S0 and S1; Result
.ie n .IP """max""" 4
.el .IP "\f(CWmax\fR" 4
.IX Item "max"
The higher of S0 and S1; Result
.ie n .IP """sin""" 4
.el .IP "\f(CWsin\fR" 4
.IX Item "sin"
Sine of S0 in Radians; Result
.ie n .IP """cos""" 4
.el .IP "\f(CWcos\fR" 4
.IX Item "cos"
Cosine of S0; Result
.ie n .IP """tan""" 4
.el .IP "\f(CWtan\fR" 4
.IX Item "tan"
Tangent of S0; Result
.ie n .IP """atan2""" 4
.el .IP "\f(CWatan2\fR" 4
.IX Item "atan2"
ArcTangent of S1 over s0; Result
.ie n .IP """count""" 4
.el .IP "\f(CWcount\fR" 4
.IX Item "count"
Push the number of elements in the array
.ie n .IP """index""" 4
.el .IP "\f(CWindex\fR" 4
.IX Item "index"
Push the current element index (zero-based)
.ie n .IP """columns""" 4
.el .IP "\f(CWcolumns\fR" 4
.IX Item "columns"
Push the number of columns in the array
.ie n .IP """column""" 4
.el .IP "\f(CWcolumn\fR" 4
.IX Item "column"
Push the current column index
.ie n .IP """rows""" 4
.el .IP "\f(CWrows\fR" 4
.IX Item "rows"
Push the number of rows in the array
.ie n .IP """row""" 4
.el .IP "\f(CWrow\fR" 4
.IX Item "row"
Push the current row index
.ie n .IP """pi""" 4
.el .IP "\f(CWpi\fR" 4
.IX Item "pi"
Push the the value of \s-1PI\s0 (but remember calc is just for floats)
.ie n .IP """dump""" 4
.el .IP "\f(CWdump\fR" 4
.IX Item "dump"
Print a dump of the current stack to standard out.
.Sp
.Vb 1
\&    OpenGL::Array\->new_list(GL_FLOAT,7)\->calc("dup,dec,2,swap,10,4,set,dump");
.Ve
.Sp
Would print:
.Sp
.Vb 7
\&    \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-(row: 0, col: 0)\-\-\-\-
\&    Register: 4.0000000
\&    Stack  4: 7.0000000
\&    Stack  3: 2.0000000
\&    Stack  2: 6.0000000
\&    Stack  1: 10.0000000
\&    Stack  0: 4.0000000
.Ve
.RE
.RS 4
.RE
.SH "AUTHOR"
.IX Header "AUTHOR"
Bulk of documentation taken from http://graphcomp.com/pogl.cgi?v=0111s3p1&r=s3p6
.PP
Additions by Paul Seamons
