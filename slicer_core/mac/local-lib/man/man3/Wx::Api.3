.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Wx::Api 3"
.TH Wx::Api 3 "2014-03-08" "perl v5.28.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
API \- wxPerl extension API documentation
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "\s-1WXPL_API_VERSION\s0"
.IX Subsection "WXPL_API_VERSION"
An integer value used to differentiate wxPerl versions, it is guaranteed to
be non-decreasing. wxPerl 0.15 value is 0150; wxPerl 1.00 value will be
1000, wxPerl 2.12 value will be 2120.
.PP
\&\fIIntroduced in wxPerl 0.15\fR
.SS "wxPli_create_evthandler"
.IX Subsection "wxPli_create_evthandler"
.Vb 2
\&  SV* wxPli_create_evthandler( pTHX_ wxEvtHandler* object,
\&                               const char* classname );
.Ve
.PP
Creates a new hash reference, blessed into \f(CW\*(C`classname\*(C'\fR,
and binds\f(CW\*(C`object\*(C'\fR to it.
.PP
\&\fIIntroduced in wxPerl 0.16\fR
.SS "wxPli_evthandler_2_sv"
.IX Subsection "wxPli_evthandler_2_sv"
.Vb 1
\&  SV* wxPli_evthandler_2_sv( pTHX_ SV* var, wxEvtHandler* evth );
.Ve
.PP
Same as wxPli_object_2_sv, but works with \f(CW\*(C`wxEvtHandler\*(C'\fR\-derived
classes, which includes all \f(CW\*(C`wxWindow\*(C'\fR\-derived classes.
.PP
\&\fIIntroduced in wxPerl 0.16\fR
.SS "wxPli_get_class"
.IX Subsection "wxPli_get_class"
.Vb 1
\&  const char* wxPli_get_class( pTHX_ SV* ref );
.Ve
.PP
The \*(C+ equivalent of \f(CW\*(C`$class = ref( $obj ) || $obj\*(C'\fR; the pointer
returned by the function is potentially temporary.
.SS "wxPli_non_object_2_sv"
.IX Subsection "wxPli_non_object_2_sv"
.Vb 1
\&  SV* wxPli_non_object_2_sv( pTHX_ SV* var, void* data, const char* package );
.Ve
.PP
Binds a generic pointer to an \f(CW\*(C`SV*\*(C'\fR, and returns it; the new binding
is blessed into the given \f(CW\*(C`package\*(C'\fR.
.PP
\&\fIIntroduced before wxPerl 0.14\fR
.SS "wxPli_object_2_sv"
.IX Subsection "wxPli_object_2_sv"
.Vb 1
\&  SV* wxPli_object_2_sv( pTHX_ SV* var, wxObject* object );
.Ve
.PP
Binds a \f(CW\*(C`wxObject*\*(C'\fR pointer to an \f(CW\*(C`SV*\*(C'\fR, and returns it.  If the
object is already bound to an \f(CW\*(C`SV*\*(C'\fR, returns a reference to the
existing \f(CW\*(C`SV*\*(C'\fR, otherwise, it creates a new binding; in the latter
case, the new \f(CW\*(C`SV*\*(C'\fR is blessed into a package obtained through the
wxWidgets \s-1RTTI\s0 system.
.PP
\&\fIIntroduced before wxPerl 0.14\fR
.SS "wxPli_push_arguments"
.IX Subsection "wxPli_push_arguments"
.Vb 1
\&  void wxPli_push_arguments( pTHX_ SV*** stack, const char* argtypes, ... );
\&
\&  // example
\&  wxPli_push_arguments( aTHX_ SP, "iP", 12, "foo" );
.Ve
.PP
Pushes a variable number of arguments on the perl stack,
it is useful for passing parameters to a Perl function. The
\&\f(CW\*(C`argtypes\*(C'\fR string describes the types of subsequent arguments, each
character of the string specifying the type of a single
argument. Possible values are:
.IP "b" 4
.IX Item "b"
a \f(CW\*(C`bool\*(C'\fR value
.IP "i" 4
.IX Item "i"
an \f(CW\*(C`int\*(C'\fR value
.IP "l" 4
.IX Item "l"
a \f(CW\*(C`long\*(C'\fR value
.IP "L" 4
.IX Item "L"
an \f(CW\*(C`unsigned long\*(C'\fR value
.IP "d" 4
.IX Item "d"
a \f(CW\*(C`double\*(C'\fR value
.IP "p" 4
.IX Item "p"
a \f(CW\*(C`char*\*(C'\fR value
.IP "w" 4
.IX Item "w"
a \f(CW\*(C`wxChar*\*(C'\fR value
.IP "P" 4
.IX Item "P"
a \f(CW\*(C`wxString*\*(C'\fR value
.IP "S" 4
.IX Item "S"
a \f(CW\*(C`SV*\*(C'\fR, a \fBcopy\fR of the \s-1SV\s0 is pushed on the stack
.IP "s" 4
.IX Item "s"
a \f(CW\*(C`SV*\*(C'\fR, the pointer itself is pushed on the stack
.IP "O" 4
.IX Item "O"
a \f(CW\*(C`wxObject*\*(C'\fR, the function will internally call \f(CW\*(C`wxPli_object_2_sv\*(C'\fR
and push the result on the stack.
.IP "o" 4
.IX Item "o"
this is the only type that uses 2 parameters: the first is a \f(CW\*(C`void*\*(C'\fR,
the second a \f(CW\*(C`char*\*(C'\fR; the function will internally call
\&\f(CW\*(C`wxPli_non_object_2_sv\*(C'\fR and push the result on the stack.
.PP
\&\fIIntroduced before wxPerl 0.14\fR
.SS "wxPli_sv_2_object"
.IX Subsection "wxPli_sv_2_object"
.Vb 1
\&  void* wxPli_sv_2_object( pTHX_ SV* scalar, const char* classname );
.Ve
.PP
Extracts a bound pointer from a perl reference, checking that
the reference belongs to the correct class (\fBdie()\fRs on failure),
and returns it. If \f(CW\*(C`classname\*(C'\fR is \f(CW\*(C`NULL\*(C'\fR, the check is not done.
.PP
\&\fIIntroduced before wxPerl 0.14\fR
.SS "wxPli_wxChar_2_sv"
.IX Subsection "wxPli_wxChar_2_sv"
.Vb 1
\&  SV* wxPli_wxChar_2_sv( pTHX_ const wxChar* str, SV* out );
.Ve
.PP
Stores a string into a \f(CW\*(C`SV*\*(C'\fR, and returns the \f(CW\*(C`SV*\*(C'\fR.
.PP
\&\fIIntroduced before wxPerl 0.14\fR
.SS "wxPli_wxString_2_sv"
.IX Subsection "wxPli_wxString_2_sv"
.Vb 1
\&  SV* wxPli_wxString_2_sv( pTHX_ const wxString& str, SV* out );
.Ve
.PP
Stores a string into a \f(CW\*(C`SV*\*(C'\fR, and returns the \f(CW\*(C`SV*\*(C'\fR.
.PP
\&\fIIntroduced before wxPerl 0.14\fR
.SH "AUTHOR"
.IX Header "AUTHOR"
Mattia Barbon <mbarbon at cpan dot org>
