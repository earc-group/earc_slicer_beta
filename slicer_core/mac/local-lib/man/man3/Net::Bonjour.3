.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Net::Bonjour 3"
.TH Net::Bonjour 3 "2009-02-28" "perl v5.28.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Bonjour \- Module for DNS service discovery (Apple's Bonjour)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Net::Bonjour;
\&        
\&        my $res = Net::Bonjour\->new(<service>[, <protocol>]);
\&
\&        $res\->discover;
\&
\&        foreach my $entry ( $res\->entries ) {
\&                printf "%s %s:%s\en", $entry\->name, $entry\->address, $entry\->port;
\&        }
.Ve
.PP
Or the cyclical way:
.PP
.Vb 1
\&        use Net::Bonjour;
\&
\&        my $res = Net::Bonjour\->new(<service>[, <protocol>]);
\&               
\&        $res\->discover;
\&
\&        while ( 1 ) {
\&           foreach my $entry ( $res\->entries ) {
\&                   print $entry\->name, "\en";
\&           }
\&           $res\->discover;
\&        }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Net::Bonjour is a set of modules that allow one to discover local services via multicast \s-1DNS\s0 (mDNS) 
or enterprise services via traditional \s-1DNS.\s0  This method of service discovery has been branded as 
Bonjour by Apple Computer.
.SS "Base Object"
.IX Subsection "Base Object"
The base object would be of the Net::Bonjour class.  This object contains the resolver for \s-1DNS\s0 service discovery.
.SS "Entry Object"
.IX Subsection "Entry Object"
The base object (Net::Bonjour) will return entry objects of the class Net::Bonjour::Entry.
.SH "METHODS"
.IX Header "METHODS"
.SS "new([<service>, <protocol>, <domain>])"
.IX Subsection "new([<service>, <protocol>, <domain>])"
Creates a new Net::Bonjour discovery object.  First argument specifies the service to discover, 
e.g.  http, ftp, afpovertcp, and ssh.  The second argument specifies the protocol, i.e. tcp or udp.  
\&\fIThe default protocol is \s-1TCP\s0\fR. The third argument specifies the discovery domain, the default is 'local'.
.PP
If no arguments are specified, the resulting Net::Bonjour object will be empty and will not perform an 
automatic discovery upon creation.
.SS "all_services([<domain>])"
.IX Subsection "all_services([<domain>])"
Returns an array of new Net::Renedezvous objects for each service type advertised in the domain. The argument 
specifies the discovery domain, the default is 'local'.  Please note that the resulting Net::Bonjour objects 
will not have performed a discovery during the creation.  Therefore, the discovery process will need to be run
prior to retriving a list of entries for that Net::Bonjour object.
.SS "domain([<domain>])"
.IX Subsection "domain([<domain>])"
Get/sets current discovery domain.  By default, the discovery domain is 'local'.  Discovery for the 'local'
domain is done via \s-1MDNS\s0 while all other domains will be done via traditional \s-1DNS.\s0
.SS "discover"
.IX Subsection "discover"
Repeats the discovery process and reloads the entry list from this discovery.
.SS "entries"
.IX Subsection "entries"
Returns an array of Net::Renedezvous::Entry objects for the last discovery.
.SS "protocol([<protocol>])"
.IX Subsection "protocol([<protocol>])"
Get/sets current protocol of the service type, i.e. \s-1TCP\s0 or \s-1UDP.\s0  Please note that this is not the protocol for 
\&\s-1DNS\s0 connection.
.SS "service([<service type>])"
.IX Subsection "service([<service type>])"
Get/sets current service type.
.SS "shift_entry"
.IX Subsection "shift_entry"
Shifts off the first entry of the last discovery.  The returned object will be a Net::Bonjour::Entry object.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.SS "Print out a list of local websites"
.IX Subsection "Print out a list of local websites"
.Vb 1
\&        print "<HTML><TITLE>Local Websites</TITLE>";
\&        
\&        use Net::Bonjour;
\&
\&        my $res = Net::Bonjour\->new(\*(Aqhttp\*(Aq);
\&        $res\->discover;
\&
\&        foreach my $entry ( $res\->entries) {
\&                printf "<A HREF=\*(Aqhttp://%s%s\*(Aq>%s</A><BR>", $entry\->address, 
\&                        $entry\->attribute(\*(Aqpath\*(Aq), $entry\->name; 
\&        }
\&        
\&        print "</HTML>";
.Ve
.SS "Find a service and connect to it"
.IX Subsection "Find a service and connect to it"
.Vb 2
\&        use Socket;
\&        use Net::Bonjour;
\&        
\&        my $res = Net::Bonjour\->new(\*(Aqcustom\*(Aq);
\&        $res\->discover;
\&        
\&        my $entry = $res\->shift_entry;
\&        
\&        socket SOCK, PF_INET, SOCK_STREAM, scalar(getprotobyname(\*(Aqtcp\*(Aq));
\&        
\&        connect SOCK, $entry\->sockaddr;
\&        
\&        print SOCK "Send a message to the service";
\&        
\&        while ($line = <SOCK>) { print $line; }
\&        
\&        close SOCK;
.Ve
.SS "Find all service types and print."
.IX Subsection "Find all service types and print."
.Vb 1
\&        use Net::Bonjour;
\&
\&        foreach my $res ( Net::Bonjour\->all_services ) {
\&                printf "%s (%s)\en", $res\->service, $res\->protocol;
\&        }
.Ve
.SS "Find and print all service types and entries."
.IX Subsection "Find and print all service types and entries."
.Vb 1
\&        use Net::Bonjour;
\&
\&        foreach my $res ( Net::Bonjour\->all_services ) {
\&                printf "\-\- %s (%s) \-\-\-\en", $res\->service, $res\->protocol;
\&                $res\->discover;
\&                foreach my $entry ( $res\->entries) {
\&                        printf "\et%s (%s:%s)\en", $entry\->name, $entry\->address, $entry\->port;   
\&                }
\&        }
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Net::Bonjour::Entry
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software and can be distributed or modified under the same terms as Perl itself.
.PP
Bonjour (in this context) is a trademark of Apple Computer, Inc.
.SH "AUTHORS"
.IX Header "AUTHORS"
The Net::Bonjour module was created by George Chlipala <george@walnutcs.com>
